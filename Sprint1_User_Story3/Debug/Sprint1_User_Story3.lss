
Sprint1_User_Story3.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000626a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000060  00800060  0000626a  000062fe  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000651  008000c0  008000c0  0000635e  2**0
                  ALLOC
  3 .stab         00009c90  00000000  00000000  00006360  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000056d3  00000000  00000000  0000fff0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 9c 10 	jmp	0x2138	; 0x2138 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ea e6       	ldi	r30, 0x6A	; 106
      68:	f2 e6       	ldi	r31, 0x62	; 98
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a0 3c       	cpi	r26, 0xC0	; 192
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	a0 ec       	ldi	r26, 0xC0	; 192
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a1 31       	cpi	r26, 0x11	; 17
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 4e 30 	call	0x609c	; 0x609c <main>
      8a:	0c 94 33 31 	jmp	0x6266	; 0x6266 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <DIO_init>:
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	cd b7       	in	r28, 0x3d	; 61
      98:	de b7       	in	r29, 0x3e	; 62
      9a:	2b 97       	sbiw	r28, 0x0b	; 11
      9c:	0f b6       	in	r0, 0x3f	; 63
      9e:	f8 94       	cli
      a0:	de bf       	out	0x3e, r29	; 62
      a2:	0f be       	out	0x3f, r0	; 63
      a4:	cd bf       	out	0x3d, r28	; 61
      a6:	81 e0       	ldi	r24, 0x01	; 1
      a8:	8a 83       	std	Y+2, r24	; 0x02
      aa:	19 82       	std	Y+1, r1	; 0x01
      ac:	19 82       	std	Y+1, r1	; 0x01
      ae:	b2 c4       	rjmp	.+2404   	; 0xa14 <__stack+0x1b5>
      b0:	89 81       	ldd	r24, Y+1	; 0x01
      b2:	28 2f       	mov	r18, r24
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	c9 01       	movw	r24, r18
      b8:	88 0f       	add	r24, r24
      ba:	99 1f       	adc	r25, r25
      bc:	88 0f       	add	r24, r24
      be:	99 1f       	adc	r25, r25
      c0:	82 0f       	add	r24, r18
      c2:	93 1f       	adc	r25, r19
      c4:	fc 01       	movw	r30, r24
      c6:	e7 58       	subi	r30, 0x87	; 135
      c8:	ff 4f       	sbci	r31, 0xFF	; 255
      ca:	80 81       	ld	r24, Z
      cc:	88 30       	cpi	r24, 0x08	; 8
      ce:	20 f0       	brcs	.+8      	; 0xd8 <DIO_init+0x46>
      d0:	1a 82       	std	Y+2, r1	; 0x02
      d2:	2a 81       	ldd	r18, Y+2	; 0x02
      d4:	2b 87       	std	Y+11, r18	; 0x0b
      d6:	a4 c4       	rjmp	.+2376   	; 0xa20 <__stack+0x1c1>
      d8:	89 81       	ldd	r24, Y+1	; 0x01
      da:	28 2f       	mov	r18, r24
      dc:	30 e0       	ldi	r19, 0x00	; 0
      de:	c9 01       	movw	r24, r18
      e0:	88 0f       	add	r24, r24
      e2:	99 1f       	adc	r25, r25
      e4:	88 0f       	add	r24, r24
      e6:	99 1f       	adc	r25, r25
      e8:	82 0f       	add	r24, r18
      ea:	93 1f       	adc	r25, r19
      ec:	fc 01       	movw	r30, r24
      ee:	e6 58       	subi	r30, 0x86	; 134
      f0:	ff 4f       	sbci	r31, 0xFF	; 255
      f2:	80 81       	ld	r24, Z
      f4:	81 30       	cpi	r24, 0x01	; 1
      f6:	09 f0       	breq	.+2      	; 0xfa <DIO_init+0x68>
      f8:	b0 c0       	rjmp	.+352    	; 0x25a <DIO_init+0x1c8>
      fa:	89 81       	ldd	r24, Y+1	; 0x01
      fc:	28 2f       	mov	r18, r24
      fe:	30 e0       	ldi	r19, 0x00	; 0
     100:	c9 01       	movw	r24, r18
     102:	88 0f       	add	r24, r24
     104:	99 1f       	adc	r25, r25
     106:	88 0f       	add	r24, r24
     108:	99 1f       	adc	r25, r25
     10a:	82 0f       	add	r24, r18
     10c:	93 1f       	adc	r25, r19
     10e:	fc 01       	movw	r30, r24
     110:	e8 58       	subi	r30, 0x88	; 136
     112:	ff 4f       	sbci	r31, 0xFF	; 255
     114:	80 81       	ld	r24, Z
     116:	28 2f       	mov	r18, r24
     118:	30 e0       	ldi	r19, 0x00	; 0
     11a:	3a 87       	std	Y+10, r19	; 0x0a
     11c:	29 87       	std	Y+9, r18	; 0x09
     11e:	89 85       	ldd	r24, Y+9	; 0x09
     120:	9a 85       	ldd	r25, Y+10	; 0x0a
     122:	81 30       	cpi	r24, 0x01	; 1
     124:	91 05       	cpc	r25, r1
     126:	b9 f1       	breq	.+110    	; 0x196 <DIO_init+0x104>
     128:	29 85       	ldd	r18, Y+9	; 0x09
     12a:	3a 85       	ldd	r19, Y+10	; 0x0a
     12c:	22 30       	cpi	r18, 0x02	; 2
     12e:	31 05       	cpc	r19, r1
     130:	2c f4       	brge	.+10     	; 0x13c <DIO_init+0xaa>
     132:	89 85       	ldd	r24, Y+9	; 0x09
     134:	9a 85       	ldd	r25, Y+10	; 0x0a
     136:	00 97       	sbiw	r24, 0x00	; 0
     138:	71 f0       	breq	.+28     	; 0x156 <DIO_init+0xc4>
     13a:	8d c0       	rjmp	.+282    	; 0x256 <DIO_init+0x1c4>
     13c:	29 85       	ldd	r18, Y+9	; 0x09
     13e:	3a 85       	ldd	r19, Y+10	; 0x0a
     140:	22 30       	cpi	r18, 0x02	; 2
     142:	31 05       	cpc	r19, r1
     144:	09 f4       	brne	.+2      	; 0x148 <DIO_init+0xb6>
     146:	47 c0       	rjmp	.+142    	; 0x1d6 <DIO_init+0x144>
     148:	89 85       	ldd	r24, Y+9	; 0x09
     14a:	9a 85       	ldd	r25, Y+10	; 0x0a
     14c:	83 30       	cpi	r24, 0x03	; 3
     14e:	91 05       	cpc	r25, r1
     150:	09 f4       	brne	.+2      	; 0x154 <DIO_init+0xc2>
     152:	61 c0       	rjmp	.+194    	; 0x216 <DIO_init+0x184>
     154:	80 c0       	rjmp	.+256    	; 0x256 <DIO_init+0x1c4>
     156:	aa e3       	ldi	r26, 0x3A	; 58
     158:	b0 e0       	ldi	r27, 0x00	; 0
     15a:	ea e3       	ldi	r30, 0x3A	; 58
     15c:	f0 e0       	ldi	r31, 0x00	; 0
     15e:	40 81       	ld	r20, Z
     160:	89 81       	ldd	r24, Y+1	; 0x01
     162:	28 2f       	mov	r18, r24
     164:	30 e0       	ldi	r19, 0x00	; 0
     166:	c9 01       	movw	r24, r18
     168:	88 0f       	add	r24, r24
     16a:	99 1f       	adc	r25, r25
     16c:	88 0f       	add	r24, r24
     16e:	99 1f       	adc	r25, r25
     170:	82 0f       	add	r24, r18
     172:	93 1f       	adc	r25, r19
     174:	fc 01       	movw	r30, r24
     176:	e7 58       	subi	r30, 0x87	; 135
     178:	ff 4f       	sbci	r31, 0xFF	; 255
     17a:	80 81       	ld	r24, Z
     17c:	28 2f       	mov	r18, r24
     17e:	30 e0       	ldi	r19, 0x00	; 0
     180:	81 e0       	ldi	r24, 0x01	; 1
     182:	90 e0       	ldi	r25, 0x00	; 0
     184:	02 2e       	mov	r0, r18
     186:	02 c0       	rjmp	.+4      	; 0x18c <DIO_init+0xfa>
     188:	88 0f       	add	r24, r24
     18a:	99 1f       	adc	r25, r25
     18c:	0a 94       	dec	r0
     18e:	e2 f7       	brpl	.-8      	; 0x188 <DIO_init+0xf6>
     190:	84 2b       	or	r24, r20
     192:	8c 93       	st	X, r24
     194:	b5 c2       	rjmp	.+1386   	; 0x700 <DIO_init+0x66e>
     196:	a7 e3       	ldi	r26, 0x37	; 55
     198:	b0 e0       	ldi	r27, 0x00	; 0
     19a:	e7 e3       	ldi	r30, 0x37	; 55
     19c:	f0 e0       	ldi	r31, 0x00	; 0
     19e:	40 81       	ld	r20, Z
     1a0:	89 81       	ldd	r24, Y+1	; 0x01
     1a2:	28 2f       	mov	r18, r24
     1a4:	30 e0       	ldi	r19, 0x00	; 0
     1a6:	c9 01       	movw	r24, r18
     1a8:	88 0f       	add	r24, r24
     1aa:	99 1f       	adc	r25, r25
     1ac:	88 0f       	add	r24, r24
     1ae:	99 1f       	adc	r25, r25
     1b0:	82 0f       	add	r24, r18
     1b2:	93 1f       	adc	r25, r19
     1b4:	fc 01       	movw	r30, r24
     1b6:	e7 58       	subi	r30, 0x87	; 135
     1b8:	ff 4f       	sbci	r31, 0xFF	; 255
     1ba:	80 81       	ld	r24, Z
     1bc:	28 2f       	mov	r18, r24
     1be:	30 e0       	ldi	r19, 0x00	; 0
     1c0:	81 e0       	ldi	r24, 0x01	; 1
     1c2:	90 e0       	ldi	r25, 0x00	; 0
     1c4:	02 2e       	mov	r0, r18
     1c6:	02 c0       	rjmp	.+4      	; 0x1cc <DIO_init+0x13a>
     1c8:	88 0f       	add	r24, r24
     1ca:	99 1f       	adc	r25, r25
     1cc:	0a 94       	dec	r0
     1ce:	e2 f7       	brpl	.-8      	; 0x1c8 <DIO_init+0x136>
     1d0:	84 2b       	or	r24, r20
     1d2:	8c 93       	st	X, r24
     1d4:	95 c2       	rjmp	.+1322   	; 0x700 <DIO_init+0x66e>
     1d6:	a4 e3       	ldi	r26, 0x34	; 52
     1d8:	b0 e0       	ldi	r27, 0x00	; 0
     1da:	e4 e3       	ldi	r30, 0x34	; 52
     1dc:	f0 e0       	ldi	r31, 0x00	; 0
     1de:	40 81       	ld	r20, Z
     1e0:	89 81       	ldd	r24, Y+1	; 0x01
     1e2:	28 2f       	mov	r18, r24
     1e4:	30 e0       	ldi	r19, 0x00	; 0
     1e6:	c9 01       	movw	r24, r18
     1e8:	88 0f       	add	r24, r24
     1ea:	99 1f       	adc	r25, r25
     1ec:	88 0f       	add	r24, r24
     1ee:	99 1f       	adc	r25, r25
     1f0:	82 0f       	add	r24, r18
     1f2:	93 1f       	adc	r25, r19
     1f4:	fc 01       	movw	r30, r24
     1f6:	e7 58       	subi	r30, 0x87	; 135
     1f8:	ff 4f       	sbci	r31, 0xFF	; 255
     1fa:	80 81       	ld	r24, Z
     1fc:	28 2f       	mov	r18, r24
     1fe:	30 e0       	ldi	r19, 0x00	; 0
     200:	81 e0       	ldi	r24, 0x01	; 1
     202:	90 e0       	ldi	r25, 0x00	; 0
     204:	02 2e       	mov	r0, r18
     206:	02 c0       	rjmp	.+4      	; 0x20c <DIO_init+0x17a>
     208:	88 0f       	add	r24, r24
     20a:	99 1f       	adc	r25, r25
     20c:	0a 94       	dec	r0
     20e:	e2 f7       	brpl	.-8      	; 0x208 <DIO_init+0x176>
     210:	84 2b       	or	r24, r20
     212:	8c 93       	st	X, r24
     214:	75 c2       	rjmp	.+1258   	; 0x700 <DIO_init+0x66e>
     216:	a1 e3       	ldi	r26, 0x31	; 49
     218:	b0 e0       	ldi	r27, 0x00	; 0
     21a:	e1 e3       	ldi	r30, 0x31	; 49
     21c:	f0 e0       	ldi	r31, 0x00	; 0
     21e:	40 81       	ld	r20, Z
     220:	89 81       	ldd	r24, Y+1	; 0x01
     222:	28 2f       	mov	r18, r24
     224:	30 e0       	ldi	r19, 0x00	; 0
     226:	c9 01       	movw	r24, r18
     228:	88 0f       	add	r24, r24
     22a:	99 1f       	adc	r25, r25
     22c:	88 0f       	add	r24, r24
     22e:	99 1f       	adc	r25, r25
     230:	82 0f       	add	r24, r18
     232:	93 1f       	adc	r25, r19
     234:	fc 01       	movw	r30, r24
     236:	e7 58       	subi	r30, 0x87	; 135
     238:	ff 4f       	sbci	r31, 0xFF	; 255
     23a:	80 81       	ld	r24, Z
     23c:	28 2f       	mov	r18, r24
     23e:	30 e0       	ldi	r19, 0x00	; 0
     240:	81 e0       	ldi	r24, 0x01	; 1
     242:	90 e0       	ldi	r25, 0x00	; 0
     244:	02 2e       	mov	r0, r18
     246:	02 c0       	rjmp	.+4      	; 0x24c <DIO_init+0x1ba>
     248:	88 0f       	add	r24, r24
     24a:	99 1f       	adc	r25, r25
     24c:	0a 94       	dec	r0
     24e:	e2 f7       	brpl	.-8      	; 0x248 <DIO_init+0x1b6>
     250:	84 2b       	or	r24, r20
     252:	8c 93       	st	X, r24
     254:	55 c2       	rjmp	.+1194   	; 0x700 <DIO_init+0x66e>
     256:	1a 82       	std	Y+2, r1	; 0x02
     258:	53 c2       	rjmp	.+1190   	; 0x700 <DIO_init+0x66e>
     25a:	89 81       	ldd	r24, Y+1	; 0x01
     25c:	28 2f       	mov	r18, r24
     25e:	30 e0       	ldi	r19, 0x00	; 0
     260:	c9 01       	movw	r24, r18
     262:	88 0f       	add	r24, r24
     264:	99 1f       	adc	r25, r25
     266:	88 0f       	add	r24, r24
     268:	99 1f       	adc	r25, r25
     26a:	82 0f       	add	r24, r18
     26c:	93 1f       	adc	r25, r19
     26e:	fc 01       	movw	r30, r24
     270:	e6 58       	subi	r30, 0x86	; 134
     272:	ff 4f       	sbci	r31, 0xFF	; 255
     274:	80 81       	ld	r24, Z
     276:	88 23       	and	r24, r24
     278:	09 f0       	breq	.+2      	; 0x27c <DIO_init+0x1ea>
     27a:	41 c2       	rjmp	.+1154   	; 0x6fe <DIO_init+0x66c>
     27c:	89 81       	ldd	r24, Y+1	; 0x01
     27e:	28 2f       	mov	r18, r24
     280:	30 e0       	ldi	r19, 0x00	; 0
     282:	c9 01       	movw	r24, r18
     284:	88 0f       	add	r24, r24
     286:	99 1f       	adc	r25, r25
     288:	88 0f       	add	r24, r24
     28a:	99 1f       	adc	r25, r25
     28c:	82 0f       	add	r24, r18
     28e:	93 1f       	adc	r25, r19
     290:	fc 01       	movw	r30, r24
     292:	e8 58       	subi	r30, 0x88	; 136
     294:	ff 4f       	sbci	r31, 0xFF	; 255
     296:	80 81       	ld	r24, Z
     298:	28 2f       	mov	r18, r24
     29a:	30 e0       	ldi	r19, 0x00	; 0
     29c:	38 87       	std	Y+8, r19	; 0x08
     29e:	2f 83       	std	Y+7, r18	; 0x07
     2a0:	8f 81       	ldd	r24, Y+7	; 0x07
     2a2:	98 85       	ldd	r25, Y+8	; 0x08
     2a4:	81 30       	cpi	r24, 0x01	; 1
     2a6:	91 05       	cpc	r25, r1
     2a8:	09 f4       	brne	.+2      	; 0x2ac <DIO_init+0x21a>
     2aa:	9b c0       	rjmp	.+310    	; 0x3e2 <DIO_init+0x350>
     2ac:	2f 81       	ldd	r18, Y+7	; 0x07
     2ae:	38 85       	ldd	r19, Y+8	; 0x08
     2b0:	22 30       	cpi	r18, 0x02	; 2
     2b2:	31 05       	cpc	r19, r1
     2b4:	2c f4       	brge	.+10     	; 0x2c0 <DIO_init+0x22e>
     2b6:	8f 81       	ldd	r24, Y+7	; 0x07
     2b8:	98 85       	ldd	r25, Y+8	; 0x08
     2ba:	00 97       	sbiw	r24, 0x00	; 0
     2bc:	71 f0       	breq	.+28     	; 0x2da <DIO_init+0x248>
     2be:	1d c2       	rjmp	.+1082   	; 0x6fa <DIO_init+0x668>
     2c0:	2f 81       	ldd	r18, Y+7	; 0x07
     2c2:	38 85       	ldd	r19, Y+8	; 0x08
     2c4:	22 30       	cpi	r18, 0x02	; 2
     2c6:	31 05       	cpc	r19, r1
     2c8:	09 f4       	brne	.+2      	; 0x2cc <DIO_init+0x23a>
     2ca:	0f c1       	rjmp	.+542    	; 0x4ea <DIO_init+0x458>
     2cc:	8f 81       	ldd	r24, Y+7	; 0x07
     2ce:	98 85       	ldd	r25, Y+8	; 0x08
     2d0:	83 30       	cpi	r24, 0x03	; 3
     2d2:	91 05       	cpc	r25, r1
     2d4:	09 f4       	brne	.+2      	; 0x2d8 <DIO_init+0x246>
     2d6:	8d c1       	rjmp	.+794    	; 0x5f2 <DIO_init+0x560>
     2d8:	10 c2       	rjmp	.+1056   	; 0x6fa <DIO_init+0x668>
     2da:	aa e3       	ldi	r26, 0x3A	; 58
     2dc:	b0 e0       	ldi	r27, 0x00	; 0
     2de:	ea e3       	ldi	r30, 0x3A	; 58
     2e0:	f0 e0       	ldi	r31, 0x00	; 0
     2e2:	40 81       	ld	r20, Z
     2e4:	89 81       	ldd	r24, Y+1	; 0x01
     2e6:	28 2f       	mov	r18, r24
     2e8:	30 e0       	ldi	r19, 0x00	; 0
     2ea:	c9 01       	movw	r24, r18
     2ec:	88 0f       	add	r24, r24
     2ee:	99 1f       	adc	r25, r25
     2f0:	88 0f       	add	r24, r24
     2f2:	99 1f       	adc	r25, r25
     2f4:	82 0f       	add	r24, r18
     2f6:	93 1f       	adc	r25, r19
     2f8:	fc 01       	movw	r30, r24
     2fa:	e7 58       	subi	r30, 0x87	; 135
     2fc:	ff 4f       	sbci	r31, 0xFF	; 255
     2fe:	80 81       	ld	r24, Z
     300:	28 2f       	mov	r18, r24
     302:	30 e0       	ldi	r19, 0x00	; 0
     304:	81 e0       	ldi	r24, 0x01	; 1
     306:	90 e0       	ldi	r25, 0x00	; 0
     308:	02 c0       	rjmp	.+4      	; 0x30e <DIO_init+0x27c>
     30a:	88 0f       	add	r24, r24
     30c:	99 1f       	adc	r25, r25
     30e:	2a 95       	dec	r18
     310:	e2 f7       	brpl	.-8      	; 0x30a <DIO_init+0x278>
     312:	80 95       	com	r24
     314:	84 23       	and	r24, r20
     316:	8c 93       	st	X, r24
     318:	89 81       	ldd	r24, Y+1	; 0x01
     31a:	28 2f       	mov	r18, r24
     31c:	30 e0       	ldi	r19, 0x00	; 0
     31e:	c9 01       	movw	r24, r18
     320:	88 0f       	add	r24, r24
     322:	99 1f       	adc	r25, r25
     324:	88 0f       	add	r24, r24
     326:	99 1f       	adc	r25, r25
     328:	82 0f       	add	r24, r18
     32a:	93 1f       	adc	r25, r19
     32c:	fc 01       	movw	r30, r24
     32e:	e4 58       	subi	r30, 0x84	; 132
     330:	ff 4f       	sbci	r31, 0xFF	; 255
     332:	80 81       	ld	r24, Z
     334:	81 30       	cpi	r24, 0x01	; 1
     336:	01 f5       	brne	.+64     	; 0x378 <DIO_init+0x2e6>
     338:	ab e3       	ldi	r26, 0x3B	; 59
     33a:	b0 e0       	ldi	r27, 0x00	; 0
     33c:	eb e3       	ldi	r30, 0x3B	; 59
     33e:	f0 e0       	ldi	r31, 0x00	; 0
     340:	40 81       	ld	r20, Z
     342:	89 81       	ldd	r24, Y+1	; 0x01
     344:	28 2f       	mov	r18, r24
     346:	30 e0       	ldi	r19, 0x00	; 0
     348:	c9 01       	movw	r24, r18
     34a:	88 0f       	add	r24, r24
     34c:	99 1f       	adc	r25, r25
     34e:	88 0f       	add	r24, r24
     350:	99 1f       	adc	r25, r25
     352:	82 0f       	add	r24, r18
     354:	93 1f       	adc	r25, r19
     356:	fc 01       	movw	r30, r24
     358:	e7 58       	subi	r30, 0x87	; 135
     35a:	ff 4f       	sbci	r31, 0xFF	; 255
     35c:	80 81       	ld	r24, Z
     35e:	28 2f       	mov	r18, r24
     360:	30 e0       	ldi	r19, 0x00	; 0
     362:	81 e0       	ldi	r24, 0x01	; 1
     364:	90 e0       	ldi	r25, 0x00	; 0
     366:	02 2e       	mov	r0, r18
     368:	02 c0       	rjmp	.+4      	; 0x36e <DIO_init+0x2dc>
     36a:	88 0f       	add	r24, r24
     36c:	99 1f       	adc	r25, r25
     36e:	0a 94       	dec	r0
     370:	e2 f7       	brpl	.-8      	; 0x36a <DIO_init+0x2d8>
     372:	84 2b       	or	r24, r20
     374:	8c 93       	st	X, r24
     376:	c4 c1       	rjmp	.+904    	; 0x700 <DIO_init+0x66e>
     378:	89 81       	ldd	r24, Y+1	; 0x01
     37a:	28 2f       	mov	r18, r24
     37c:	30 e0       	ldi	r19, 0x00	; 0
     37e:	c9 01       	movw	r24, r18
     380:	88 0f       	add	r24, r24
     382:	99 1f       	adc	r25, r25
     384:	88 0f       	add	r24, r24
     386:	99 1f       	adc	r25, r25
     388:	82 0f       	add	r24, r18
     38a:	93 1f       	adc	r25, r19
     38c:	fc 01       	movw	r30, r24
     38e:	e4 58       	subi	r30, 0x84	; 132
     390:	ff 4f       	sbci	r31, 0xFF	; 255
     392:	80 81       	ld	r24, Z
     394:	88 23       	and	r24, r24
     396:	09 f5       	brne	.+66     	; 0x3da <DIO_init+0x348>
     398:	ab e3       	ldi	r26, 0x3B	; 59
     39a:	b0 e0       	ldi	r27, 0x00	; 0
     39c:	eb e3       	ldi	r30, 0x3B	; 59
     39e:	f0 e0       	ldi	r31, 0x00	; 0
     3a0:	40 81       	ld	r20, Z
     3a2:	89 81       	ldd	r24, Y+1	; 0x01
     3a4:	28 2f       	mov	r18, r24
     3a6:	30 e0       	ldi	r19, 0x00	; 0
     3a8:	c9 01       	movw	r24, r18
     3aa:	88 0f       	add	r24, r24
     3ac:	99 1f       	adc	r25, r25
     3ae:	88 0f       	add	r24, r24
     3b0:	99 1f       	adc	r25, r25
     3b2:	82 0f       	add	r24, r18
     3b4:	93 1f       	adc	r25, r19
     3b6:	fc 01       	movw	r30, r24
     3b8:	e7 58       	subi	r30, 0x87	; 135
     3ba:	ff 4f       	sbci	r31, 0xFF	; 255
     3bc:	80 81       	ld	r24, Z
     3be:	28 2f       	mov	r18, r24
     3c0:	30 e0       	ldi	r19, 0x00	; 0
     3c2:	81 e0       	ldi	r24, 0x01	; 1
     3c4:	90 e0       	ldi	r25, 0x00	; 0
     3c6:	02 2e       	mov	r0, r18
     3c8:	02 c0       	rjmp	.+4      	; 0x3ce <DIO_init+0x33c>
     3ca:	88 0f       	add	r24, r24
     3cc:	99 1f       	adc	r25, r25
     3ce:	0a 94       	dec	r0
     3d0:	e2 f7       	brpl	.-8      	; 0x3ca <DIO_init+0x338>
     3d2:	80 95       	com	r24
     3d4:	84 23       	and	r24, r20
     3d6:	8c 93       	st	X, r24
     3d8:	93 c1       	rjmp	.+806    	; 0x700 <DIO_init+0x66e>
     3da:	1a 82       	std	Y+2, r1	; 0x02
     3dc:	9a 81       	ldd	r25, Y+2	; 0x02
     3de:	9b 87       	std	Y+11, r25	; 0x0b
     3e0:	1f c3       	rjmp	.+1598   	; 0xa20 <__stack+0x1c1>
     3e2:	a7 e3       	ldi	r26, 0x37	; 55
     3e4:	b0 e0       	ldi	r27, 0x00	; 0
     3e6:	e7 e3       	ldi	r30, 0x37	; 55
     3e8:	f0 e0       	ldi	r31, 0x00	; 0
     3ea:	40 81       	ld	r20, Z
     3ec:	89 81       	ldd	r24, Y+1	; 0x01
     3ee:	28 2f       	mov	r18, r24
     3f0:	30 e0       	ldi	r19, 0x00	; 0
     3f2:	c9 01       	movw	r24, r18
     3f4:	88 0f       	add	r24, r24
     3f6:	99 1f       	adc	r25, r25
     3f8:	88 0f       	add	r24, r24
     3fa:	99 1f       	adc	r25, r25
     3fc:	82 0f       	add	r24, r18
     3fe:	93 1f       	adc	r25, r19
     400:	fc 01       	movw	r30, r24
     402:	e7 58       	subi	r30, 0x87	; 135
     404:	ff 4f       	sbci	r31, 0xFF	; 255
     406:	80 81       	ld	r24, Z
     408:	28 2f       	mov	r18, r24
     40a:	30 e0       	ldi	r19, 0x00	; 0
     40c:	81 e0       	ldi	r24, 0x01	; 1
     40e:	90 e0       	ldi	r25, 0x00	; 0
     410:	02 c0       	rjmp	.+4      	; 0x416 <DIO_init+0x384>
     412:	88 0f       	add	r24, r24
     414:	99 1f       	adc	r25, r25
     416:	2a 95       	dec	r18
     418:	e2 f7       	brpl	.-8      	; 0x412 <DIO_init+0x380>
     41a:	80 95       	com	r24
     41c:	84 23       	and	r24, r20
     41e:	8c 93       	st	X, r24
     420:	89 81       	ldd	r24, Y+1	; 0x01
     422:	28 2f       	mov	r18, r24
     424:	30 e0       	ldi	r19, 0x00	; 0
     426:	c9 01       	movw	r24, r18
     428:	88 0f       	add	r24, r24
     42a:	99 1f       	adc	r25, r25
     42c:	88 0f       	add	r24, r24
     42e:	99 1f       	adc	r25, r25
     430:	82 0f       	add	r24, r18
     432:	93 1f       	adc	r25, r19
     434:	fc 01       	movw	r30, r24
     436:	e4 58       	subi	r30, 0x84	; 132
     438:	ff 4f       	sbci	r31, 0xFF	; 255
     43a:	80 81       	ld	r24, Z
     43c:	81 30       	cpi	r24, 0x01	; 1
     43e:	01 f5       	brne	.+64     	; 0x480 <DIO_init+0x3ee>
     440:	a8 e3       	ldi	r26, 0x38	; 56
     442:	b0 e0       	ldi	r27, 0x00	; 0
     444:	e8 e3       	ldi	r30, 0x38	; 56
     446:	f0 e0       	ldi	r31, 0x00	; 0
     448:	40 81       	ld	r20, Z
     44a:	89 81       	ldd	r24, Y+1	; 0x01
     44c:	28 2f       	mov	r18, r24
     44e:	30 e0       	ldi	r19, 0x00	; 0
     450:	c9 01       	movw	r24, r18
     452:	88 0f       	add	r24, r24
     454:	99 1f       	adc	r25, r25
     456:	88 0f       	add	r24, r24
     458:	99 1f       	adc	r25, r25
     45a:	82 0f       	add	r24, r18
     45c:	93 1f       	adc	r25, r19
     45e:	fc 01       	movw	r30, r24
     460:	e7 58       	subi	r30, 0x87	; 135
     462:	ff 4f       	sbci	r31, 0xFF	; 255
     464:	80 81       	ld	r24, Z
     466:	28 2f       	mov	r18, r24
     468:	30 e0       	ldi	r19, 0x00	; 0
     46a:	81 e0       	ldi	r24, 0x01	; 1
     46c:	90 e0       	ldi	r25, 0x00	; 0
     46e:	02 2e       	mov	r0, r18
     470:	02 c0       	rjmp	.+4      	; 0x476 <DIO_init+0x3e4>
     472:	88 0f       	add	r24, r24
     474:	99 1f       	adc	r25, r25
     476:	0a 94       	dec	r0
     478:	e2 f7       	brpl	.-8      	; 0x472 <DIO_init+0x3e0>
     47a:	84 2b       	or	r24, r20
     47c:	8c 93       	st	X, r24
     47e:	40 c1       	rjmp	.+640    	; 0x700 <DIO_init+0x66e>
     480:	89 81       	ldd	r24, Y+1	; 0x01
     482:	28 2f       	mov	r18, r24
     484:	30 e0       	ldi	r19, 0x00	; 0
     486:	c9 01       	movw	r24, r18
     488:	88 0f       	add	r24, r24
     48a:	99 1f       	adc	r25, r25
     48c:	88 0f       	add	r24, r24
     48e:	99 1f       	adc	r25, r25
     490:	82 0f       	add	r24, r18
     492:	93 1f       	adc	r25, r19
     494:	fc 01       	movw	r30, r24
     496:	e4 58       	subi	r30, 0x84	; 132
     498:	ff 4f       	sbci	r31, 0xFF	; 255
     49a:	80 81       	ld	r24, Z
     49c:	88 23       	and	r24, r24
     49e:	09 f5       	brne	.+66     	; 0x4e2 <DIO_init+0x450>
     4a0:	a8 e3       	ldi	r26, 0x38	; 56
     4a2:	b0 e0       	ldi	r27, 0x00	; 0
     4a4:	e8 e3       	ldi	r30, 0x38	; 56
     4a6:	f0 e0       	ldi	r31, 0x00	; 0
     4a8:	40 81       	ld	r20, Z
     4aa:	89 81       	ldd	r24, Y+1	; 0x01
     4ac:	28 2f       	mov	r18, r24
     4ae:	30 e0       	ldi	r19, 0x00	; 0
     4b0:	c9 01       	movw	r24, r18
     4b2:	88 0f       	add	r24, r24
     4b4:	99 1f       	adc	r25, r25
     4b6:	88 0f       	add	r24, r24
     4b8:	99 1f       	adc	r25, r25
     4ba:	82 0f       	add	r24, r18
     4bc:	93 1f       	adc	r25, r19
     4be:	fc 01       	movw	r30, r24
     4c0:	e7 58       	subi	r30, 0x87	; 135
     4c2:	ff 4f       	sbci	r31, 0xFF	; 255
     4c4:	80 81       	ld	r24, Z
     4c6:	28 2f       	mov	r18, r24
     4c8:	30 e0       	ldi	r19, 0x00	; 0
     4ca:	81 e0       	ldi	r24, 0x01	; 1
     4cc:	90 e0       	ldi	r25, 0x00	; 0
     4ce:	02 2e       	mov	r0, r18
     4d0:	02 c0       	rjmp	.+4      	; 0x4d6 <DIO_init+0x444>
     4d2:	88 0f       	add	r24, r24
     4d4:	99 1f       	adc	r25, r25
     4d6:	0a 94       	dec	r0
     4d8:	e2 f7       	brpl	.-8      	; 0x4d2 <DIO_init+0x440>
     4da:	80 95       	com	r24
     4dc:	84 23       	and	r24, r20
     4de:	8c 93       	st	X, r24
     4e0:	0f c1       	rjmp	.+542    	; 0x700 <DIO_init+0x66e>
     4e2:	1a 82       	std	Y+2, r1	; 0x02
     4e4:	2a 81       	ldd	r18, Y+2	; 0x02
     4e6:	2b 87       	std	Y+11, r18	; 0x0b
     4e8:	9b c2       	rjmp	.+1334   	; 0xa20 <__stack+0x1c1>
     4ea:	a4 e3       	ldi	r26, 0x34	; 52
     4ec:	b0 e0       	ldi	r27, 0x00	; 0
     4ee:	e4 e3       	ldi	r30, 0x34	; 52
     4f0:	f0 e0       	ldi	r31, 0x00	; 0
     4f2:	40 81       	ld	r20, Z
     4f4:	89 81       	ldd	r24, Y+1	; 0x01
     4f6:	28 2f       	mov	r18, r24
     4f8:	30 e0       	ldi	r19, 0x00	; 0
     4fa:	c9 01       	movw	r24, r18
     4fc:	88 0f       	add	r24, r24
     4fe:	99 1f       	adc	r25, r25
     500:	88 0f       	add	r24, r24
     502:	99 1f       	adc	r25, r25
     504:	82 0f       	add	r24, r18
     506:	93 1f       	adc	r25, r19
     508:	fc 01       	movw	r30, r24
     50a:	e7 58       	subi	r30, 0x87	; 135
     50c:	ff 4f       	sbci	r31, 0xFF	; 255
     50e:	80 81       	ld	r24, Z
     510:	28 2f       	mov	r18, r24
     512:	30 e0       	ldi	r19, 0x00	; 0
     514:	81 e0       	ldi	r24, 0x01	; 1
     516:	90 e0       	ldi	r25, 0x00	; 0
     518:	02 c0       	rjmp	.+4      	; 0x51e <DIO_init+0x48c>
     51a:	88 0f       	add	r24, r24
     51c:	99 1f       	adc	r25, r25
     51e:	2a 95       	dec	r18
     520:	e2 f7       	brpl	.-8      	; 0x51a <DIO_init+0x488>
     522:	80 95       	com	r24
     524:	84 23       	and	r24, r20
     526:	8c 93       	st	X, r24
     528:	89 81       	ldd	r24, Y+1	; 0x01
     52a:	28 2f       	mov	r18, r24
     52c:	30 e0       	ldi	r19, 0x00	; 0
     52e:	c9 01       	movw	r24, r18
     530:	88 0f       	add	r24, r24
     532:	99 1f       	adc	r25, r25
     534:	88 0f       	add	r24, r24
     536:	99 1f       	adc	r25, r25
     538:	82 0f       	add	r24, r18
     53a:	93 1f       	adc	r25, r19
     53c:	fc 01       	movw	r30, r24
     53e:	e4 58       	subi	r30, 0x84	; 132
     540:	ff 4f       	sbci	r31, 0xFF	; 255
     542:	80 81       	ld	r24, Z
     544:	81 30       	cpi	r24, 0x01	; 1
     546:	01 f5       	brne	.+64     	; 0x588 <DIO_init+0x4f6>
     548:	a5 e3       	ldi	r26, 0x35	; 53
     54a:	b0 e0       	ldi	r27, 0x00	; 0
     54c:	e5 e3       	ldi	r30, 0x35	; 53
     54e:	f0 e0       	ldi	r31, 0x00	; 0
     550:	40 81       	ld	r20, Z
     552:	89 81       	ldd	r24, Y+1	; 0x01
     554:	28 2f       	mov	r18, r24
     556:	30 e0       	ldi	r19, 0x00	; 0
     558:	c9 01       	movw	r24, r18
     55a:	88 0f       	add	r24, r24
     55c:	99 1f       	adc	r25, r25
     55e:	88 0f       	add	r24, r24
     560:	99 1f       	adc	r25, r25
     562:	82 0f       	add	r24, r18
     564:	93 1f       	adc	r25, r19
     566:	fc 01       	movw	r30, r24
     568:	e7 58       	subi	r30, 0x87	; 135
     56a:	ff 4f       	sbci	r31, 0xFF	; 255
     56c:	80 81       	ld	r24, Z
     56e:	28 2f       	mov	r18, r24
     570:	30 e0       	ldi	r19, 0x00	; 0
     572:	81 e0       	ldi	r24, 0x01	; 1
     574:	90 e0       	ldi	r25, 0x00	; 0
     576:	02 2e       	mov	r0, r18
     578:	02 c0       	rjmp	.+4      	; 0x57e <DIO_init+0x4ec>
     57a:	88 0f       	add	r24, r24
     57c:	99 1f       	adc	r25, r25
     57e:	0a 94       	dec	r0
     580:	e2 f7       	brpl	.-8      	; 0x57a <DIO_init+0x4e8>
     582:	84 2b       	or	r24, r20
     584:	8c 93       	st	X, r24
     586:	bc c0       	rjmp	.+376    	; 0x700 <DIO_init+0x66e>
     588:	89 81       	ldd	r24, Y+1	; 0x01
     58a:	28 2f       	mov	r18, r24
     58c:	30 e0       	ldi	r19, 0x00	; 0
     58e:	c9 01       	movw	r24, r18
     590:	88 0f       	add	r24, r24
     592:	99 1f       	adc	r25, r25
     594:	88 0f       	add	r24, r24
     596:	99 1f       	adc	r25, r25
     598:	82 0f       	add	r24, r18
     59a:	93 1f       	adc	r25, r19
     59c:	fc 01       	movw	r30, r24
     59e:	e4 58       	subi	r30, 0x84	; 132
     5a0:	ff 4f       	sbci	r31, 0xFF	; 255
     5a2:	80 81       	ld	r24, Z
     5a4:	88 23       	and	r24, r24
     5a6:	09 f5       	brne	.+66     	; 0x5ea <DIO_init+0x558>
     5a8:	a5 e3       	ldi	r26, 0x35	; 53
     5aa:	b0 e0       	ldi	r27, 0x00	; 0
     5ac:	e5 e3       	ldi	r30, 0x35	; 53
     5ae:	f0 e0       	ldi	r31, 0x00	; 0
     5b0:	40 81       	ld	r20, Z
     5b2:	89 81       	ldd	r24, Y+1	; 0x01
     5b4:	28 2f       	mov	r18, r24
     5b6:	30 e0       	ldi	r19, 0x00	; 0
     5b8:	c9 01       	movw	r24, r18
     5ba:	88 0f       	add	r24, r24
     5bc:	99 1f       	adc	r25, r25
     5be:	88 0f       	add	r24, r24
     5c0:	99 1f       	adc	r25, r25
     5c2:	82 0f       	add	r24, r18
     5c4:	93 1f       	adc	r25, r19
     5c6:	fc 01       	movw	r30, r24
     5c8:	e7 58       	subi	r30, 0x87	; 135
     5ca:	ff 4f       	sbci	r31, 0xFF	; 255
     5cc:	80 81       	ld	r24, Z
     5ce:	28 2f       	mov	r18, r24
     5d0:	30 e0       	ldi	r19, 0x00	; 0
     5d2:	81 e0       	ldi	r24, 0x01	; 1
     5d4:	90 e0       	ldi	r25, 0x00	; 0
     5d6:	02 2e       	mov	r0, r18
     5d8:	02 c0       	rjmp	.+4      	; 0x5de <DIO_init+0x54c>
     5da:	88 0f       	add	r24, r24
     5dc:	99 1f       	adc	r25, r25
     5de:	0a 94       	dec	r0
     5e0:	e2 f7       	brpl	.-8      	; 0x5da <DIO_init+0x548>
     5e2:	80 95       	com	r24
     5e4:	84 23       	and	r24, r20
     5e6:	8c 93       	st	X, r24
     5e8:	8b c0       	rjmp	.+278    	; 0x700 <DIO_init+0x66e>
     5ea:	1a 82       	std	Y+2, r1	; 0x02
     5ec:	3a 81       	ldd	r19, Y+2	; 0x02
     5ee:	3b 87       	std	Y+11, r19	; 0x0b
     5f0:	17 c2       	rjmp	.+1070   	; 0xa20 <__stack+0x1c1>
     5f2:	a1 e3       	ldi	r26, 0x31	; 49
     5f4:	b0 e0       	ldi	r27, 0x00	; 0
     5f6:	e1 e3       	ldi	r30, 0x31	; 49
     5f8:	f0 e0       	ldi	r31, 0x00	; 0
     5fa:	40 81       	ld	r20, Z
     5fc:	89 81       	ldd	r24, Y+1	; 0x01
     5fe:	28 2f       	mov	r18, r24
     600:	30 e0       	ldi	r19, 0x00	; 0
     602:	c9 01       	movw	r24, r18
     604:	88 0f       	add	r24, r24
     606:	99 1f       	adc	r25, r25
     608:	88 0f       	add	r24, r24
     60a:	99 1f       	adc	r25, r25
     60c:	82 0f       	add	r24, r18
     60e:	93 1f       	adc	r25, r19
     610:	fc 01       	movw	r30, r24
     612:	e7 58       	subi	r30, 0x87	; 135
     614:	ff 4f       	sbci	r31, 0xFF	; 255
     616:	80 81       	ld	r24, Z
     618:	28 2f       	mov	r18, r24
     61a:	30 e0       	ldi	r19, 0x00	; 0
     61c:	81 e0       	ldi	r24, 0x01	; 1
     61e:	90 e0       	ldi	r25, 0x00	; 0
     620:	02 c0       	rjmp	.+4      	; 0x626 <DIO_init+0x594>
     622:	88 0f       	add	r24, r24
     624:	99 1f       	adc	r25, r25
     626:	2a 95       	dec	r18
     628:	e2 f7       	brpl	.-8      	; 0x622 <DIO_init+0x590>
     62a:	80 95       	com	r24
     62c:	84 23       	and	r24, r20
     62e:	8c 93       	st	X, r24
     630:	89 81       	ldd	r24, Y+1	; 0x01
     632:	28 2f       	mov	r18, r24
     634:	30 e0       	ldi	r19, 0x00	; 0
     636:	c9 01       	movw	r24, r18
     638:	88 0f       	add	r24, r24
     63a:	99 1f       	adc	r25, r25
     63c:	88 0f       	add	r24, r24
     63e:	99 1f       	adc	r25, r25
     640:	82 0f       	add	r24, r18
     642:	93 1f       	adc	r25, r19
     644:	fc 01       	movw	r30, r24
     646:	e4 58       	subi	r30, 0x84	; 132
     648:	ff 4f       	sbci	r31, 0xFF	; 255
     64a:	80 81       	ld	r24, Z
     64c:	81 30       	cpi	r24, 0x01	; 1
     64e:	01 f5       	brne	.+64     	; 0x690 <DIO_init+0x5fe>
     650:	a2 e3       	ldi	r26, 0x32	; 50
     652:	b0 e0       	ldi	r27, 0x00	; 0
     654:	e2 e3       	ldi	r30, 0x32	; 50
     656:	f0 e0       	ldi	r31, 0x00	; 0
     658:	40 81       	ld	r20, Z
     65a:	89 81       	ldd	r24, Y+1	; 0x01
     65c:	28 2f       	mov	r18, r24
     65e:	30 e0       	ldi	r19, 0x00	; 0
     660:	c9 01       	movw	r24, r18
     662:	88 0f       	add	r24, r24
     664:	99 1f       	adc	r25, r25
     666:	88 0f       	add	r24, r24
     668:	99 1f       	adc	r25, r25
     66a:	82 0f       	add	r24, r18
     66c:	93 1f       	adc	r25, r19
     66e:	fc 01       	movw	r30, r24
     670:	e7 58       	subi	r30, 0x87	; 135
     672:	ff 4f       	sbci	r31, 0xFF	; 255
     674:	80 81       	ld	r24, Z
     676:	28 2f       	mov	r18, r24
     678:	30 e0       	ldi	r19, 0x00	; 0
     67a:	81 e0       	ldi	r24, 0x01	; 1
     67c:	90 e0       	ldi	r25, 0x00	; 0
     67e:	02 2e       	mov	r0, r18
     680:	02 c0       	rjmp	.+4      	; 0x686 <DIO_init+0x5f4>
     682:	88 0f       	add	r24, r24
     684:	99 1f       	adc	r25, r25
     686:	0a 94       	dec	r0
     688:	e2 f7       	brpl	.-8      	; 0x682 <DIO_init+0x5f0>
     68a:	84 2b       	or	r24, r20
     68c:	8c 93       	st	X, r24
     68e:	38 c0       	rjmp	.+112    	; 0x700 <DIO_init+0x66e>
     690:	89 81       	ldd	r24, Y+1	; 0x01
     692:	28 2f       	mov	r18, r24
     694:	30 e0       	ldi	r19, 0x00	; 0
     696:	c9 01       	movw	r24, r18
     698:	88 0f       	add	r24, r24
     69a:	99 1f       	adc	r25, r25
     69c:	88 0f       	add	r24, r24
     69e:	99 1f       	adc	r25, r25
     6a0:	82 0f       	add	r24, r18
     6a2:	93 1f       	adc	r25, r19
     6a4:	fc 01       	movw	r30, r24
     6a6:	e4 58       	subi	r30, 0x84	; 132
     6a8:	ff 4f       	sbci	r31, 0xFF	; 255
     6aa:	80 81       	ld	r24, Z
     6ac:	88 23       	and	r24, r24
     6ae:	09 f5       	brne	.+66     	; 0x6f2 <DIO_init+0x660>
     6b0:	a2 e3       	ldi	r26, 0x32	; 50
     6b2:	b0 e0       	ldi	r27, 0x00	; 0
     6b4:	e2 e3       	ldi	r30, 0x32	; 50
     6b6:	f0 e0       	ldi	r31, 0x00	; 0
     6b8:	40 81       	ld	r20, Z
     6ba:	89 81       	ldd	r24, Y+1	; 0x01
     6bc:	28 2f       	mov	r18, r24
     6be:	30 e0       	ldi	r19, 0x00	; 0
     6c0:	c9 01       	movw	r24, r18
     6c2:	88 0f       	add	r24, r24
     6c4:	99 1f       	adc	r25, r25
     6c6:	88 0f       	add	r24, r24
     6c8:	99 1f       	adc	r25, r25
     6ca:	82 0f       	add	r24, r18
     6cc:	93 1f       	adc	r25, r19
     6ce:	fc 01       	movw	r30, r24
     6d0:	e7 58       	subi	r30, 0x87	; 135
     6d2:	ff 4f       	sbci	r31, 0xFF	; 255
     6d4:	80 81       	ld	r24, Z
     6d6:	28 2f       	mov	r18, r24
     6d8:	30 e0       	ldi	r19, 0x00	; 0
     6da:	81 e0       	ldi	r24, 0x01	; 1
     6dc:	90 e0       	ldi	r25, 0x00	; 0
     6de:	02 2e       	mov	r0, r18
     6e0:	02 c0       	rjmp	.+4      	; 0x6e6 <DIO_init+0x654>
     6e2:	88 0f       	add	r24, r24
     6e4:	99 1f       	adc	r25, r25
     6e6:	0a 94       	dec	r0
     6e8:	e2 f7       	brpl	.-8      	; 0x6e2 <DIO_init+0x650>
     6ea:	80 95       	com	r24
     6ec:	84 23       	and	r24, r20
     6ee:	8c 93       	st	X, r24
     6f0:	07 c0       	rjmp	.+14     	; 0x700 <DIO_init+0x66e>
     6f2:	1a 82       	std	Y+2, r1	; 0x02
     6f4:	8a 81       	ldd	r24, Y+2	; 0x02
     6f6:	8b 87       	std	Y+11, r24	; 0x0b
     6f8:	93 c1       	rjmp	.+806    	; 0xa20 <__stack+0x1c1>
     6fa:	1a 82       	std	Y+2, r1	; 0x02
     6fc:	01 c0       	rjmp	.+2      	; 0x700 <DIO_init+0x66e>
     6fe:	1a 82       	std	Y+2, r1	; 0x02
     700:	89 81       	ldd	r24, Y+1	; 0x01
     702:	28 2f       	mov	r18, r24
     704:	30 e0       	ldi	r19, 0x00	; 0
     706:	c9 01       	movw	r24, r18
     708:	88 0f       	add	r24, r24
     70a:	99 1f       	adc	r25, r25
     70c:	88 0f       	add	r24, r24
     70e:	99 1f       	adc	r25, r25
     710:	82 0f       	add	r24, r18
     712:	93 1f       	adc	r25, r19
     714:	fc 01       	movw	r30, r24
     716:	e5 58       	subi	r30, 0x85	; 133
     718:	ff 4f       	sbci	r31, 0xFF	; 255
     71a:	80 81       	ld	r24, Z
     71c:	81 30       	cpi	r24, 0x01	; 1
     71e:	09 f0       	breq	.+2      	; 0x722 <DIO_init+0x690>
     720:	b0 c0       	rjmp	.+352    	; 0x882 <__stack+0x23>
     722:	89 81       	ldd	r24, Y+1	; 0x01
     724:	28 2f       	mov	r18, r24
     726:	30 e0       	ldi	r19, 0x00	; 0
     728:	c9 01       	movw	r24, r18
     72a:	88 0f       	add	r24, r24
     72c:	99 1f       	adc	r25, r25
     72e:	88 0f       	add	r24, r24
     730:	99 1f       	adc	r25, r25
     732:	82 0f       	add	r24, r18
     734:	93 1f       	adc	r25, r19
     736:	fc 01       	movw	r30, r24
     738:	e8 58       	subi	r30, 0x88	; 136
     73a:	ff 4f       	sbci	r31, 0xFF	; 255
     73c:	80 81       	ld	r24, Z
     73e:	28 2f       	mov	r18, r24
     740:	30 e0       	ldi	r19, 0x00	; 0
     742:	3e 83       	std	Y+6, r19	; 0x06
     744:	2d 83       	std	Y+5, r18	; 0x05
     746:	8d 81       	ldd	r24, Y+5	; 0x05
     748:	9e 81       	ldd	r25, Y+6	; 0x06
     74a:	81 30       	cpi	r24, 0x01	; 1
     74c:	91 05       	cpc	r25, r1
     74e:	b9 f1       	breq	.+110    	; 0x7be <DIO_init+0x72c>
     750:	2d 81       	ldd	r18, Y+5	; 0x05
     752:	3e 81       	ldd	r19, Y+6	; 0x06
     754:	22 30       	cpi	r18, 0x02	; 2
     756:	31 05       	cpc	r19, r1
     758:	2c f4       	brge	.+10     	; 0x764 <DIO_init+0x6d2>
     75a:	8d 81       	ldd	r24, Y+5	; 0x05
     75c:	9e 81       	ldd	r25, Y+6	; 0x06
     75e:	00 97       	sbiw	r24, 0x00	; 0
     760:	71 f0       	breq	.+28     	; 0x77e <DIO_init+0x6ec>
     762:	8d c0       	rjmp	.+282    	; 0x87e <__stack+0x1f>
     764:	2d 81       	ldd	r18, Y+5	; 0x05
     766:	3e 81       	ldd	r19, Y+6	; 0x06
     768:	22 30       	cpi	r18, 0x02	; 2
     76a:	31 05       	cpc	r19, r1
     76c:	09 f4       	brne	.+2      	; 0x770 <DIO_init+0x6de>
     76e:	47 c0       	rjmp	.+142    	; 0x7fe <DIO_init+0x76c>
     770:	8d 81       	ldd	r24, Y+5	; 0x05
     772:	9e 81       	ldd	r25, Y+6	; 0x06
     774:	83 30       	cpi	r24, 0x03	; 3
     776:	91 05       	cpc	r25, r1
     778:	09 f4       	brne	.+2      	; 0x77c <DIO_init+0x6ea>
     77a:	61 c0       	rjmp	.+194    	; 0x83e <DIO_init+0x7ac>
     77c:	80 c0       	rjmp	.+256    	; 0x87e <__stack+0x1f>
     77e:	ab e3       	ldi	r26, 0x3B	; 59
     780:	b0 e0       	ldi	r27, 0x00	; 0
     782:	eb e3       	ldi	r30, 0x3B	; 59
     784:	f0 e0       	ldi	r31, 0x00	; 0
     786:	40 81       	ld	r20, Z
     788:	89 81       	ldd	r24, Y+1	; 0x01
     78a:	28 2f       	mov	r18, r24
     78c:	30 e0       	ldi	r19, 0x00	; 0
     78e:	c9 01       	movw	r24, r18
     790:	88 0f       	add	r24, r24
     792:	99 1f       	adc	r25, r25
     794:	88 0f       	add	r24, r24
     796:	99 1f       	adc	r25, r25
     798:	82 0f       	add	r24, r18
     79a:	93 1f       	adc	r25, r19
     79c:	fc 01       	movw	r30, r24
     79e:	e7 58       	subi	r30, 0x87	; 135
     7a0:	ff 4f       	sbci	r31, 0xFF	; 255
     7a2:	80 81       	ld	r24, Z
     7a4:	28 2f       	mov	r18, r24
     7a6:	30 e0       	ldi	r19, 0x00	; 0
     7a8:	81 e0       	ldi	r24, 0x01	; 1
     7aa:	90 e0       	ldi	r25, 0x00	; 0
     7ac:	02 2e       	mov	r0, r18
     7ae:	02 c0       	rjmp	.+4      	; 0x7b4 <DIO_init+0x722>
     7b0:	88 0f       	add	r24, r24
     7b2:	99 1f       	adc	r25, r25
     7b4:	0a 94       	dec	r0
     7b6:	e2 f7       	brpl	.-8      	; 0x7b0 <DIO_init+0x71e>
     7b8:	84 2b       	or	r24, r20
     7ba:	8c 93       	st	X, r24
     7bc:	28 c1       	rjmp	.+592    	; 0xa0e <__stack+0x1af>
     7be:	a8 e3       	ldi	r26, 0x38	; 56
     7c0:	b0 e0       	ldi	r27, 0x00	; 0
     7c2:	e8 e3       	ldi	r30, 0x38	; 56
     7c4:	f0 e0       	ldi	r31, 0x00	; 0
     7c6:	40 81       	ld	r20, Z
     7c8:	89 81       	ldd	r24, Y+1	; 0x01
     7ca:	28 2f       	mov	r18, r24
     7cc:	30 e0       	ldi	r19, 0x00	; 0
     7ce:	c9 01       	movw	r24, r18
     7d0:	88 0f       	add	r24, r24
     7d2:	99 1f       	adc	r25, r25
     7d4:	88 0f       	add	r24, r24
     7d6:	99 1f       	adc	r25, r25
     7d8:	82 0f       	add	r24, r18
     7da:	93 1f       	adc	r25, r19
     7dc:	fc 01       	movw	r30, r24
     7de:	e7 58       	subi	r30, 0x87	; 135
     7e0:	ff 4f       	sbci	r31, 0xFF	; 255
     7e2:	80 81       	ld	r24, Z
     7e4:	28 2f       	mov	r18, r24
     7e6:	30 e0       	ldi	r19, 0x00	; 0
     7e8:	81 e0       	ldi	r24, 0x01	; 1
     7ea:	90 e0       	ldi	r25, 0x00	; 0
     7ec:	02 2e       	mov	r0, r18
     7ee:	02 c0       	rjmp	.+4      	; 0x7f4 <DIO_init+0x762>
     7f0:	88 0f       	add	r24, r24
     7f2:	99 1f       	adc	r25, r25
     7f4:	0a 94       	dec	r0
     7f6:	e2 f7       	brpl	.-8      	; 0x7f0 <DIO_init+0x75e>
     7f8:	84 2b       	or	r24, r20
     7fa:	8c 93       	st	X, r24
     7fc:	08 c1       	rjmp	.+528    	; 0xa0e <__stack+0x1af>
     7fe:	a5 e3       	ldi	r26, 0x35	; 53
     800:	b0 e0       	ldi	r27, 0x00	; 0
     802:	e5 e3       	ldi	r30, 0x35	; 53
     804:	f0 e0       	ldi	r31, 0x00	; 0
     806:	40 81       	ld	r20, Z
     808:	89 81       	ldd	r24, Y+1	; 0x01
     80a:	28 2f       	mov	r18, r24
     80c:	30 e0       	ldi	r19, 0x00	; 0
     80e:	c9 01       	movw	r24, r18
     810:	88 0f       	add	r24, r24
     812:	99 1f       	adc	r25, r25
     814:	88 0f       	add	r24, r24
     816:	99 1f       	adc	r25, r25
     818:	82 0f       	add	r24, r18
     81a:	93 1f       	adc	r25, r19
     81c:	fc 01       	movw	r30, r24
     81e:	e7 58       	subi	r30, 0x87	; 135
     820:	ff 4f       	sbci	r31, 0xFF	; 255
     822:	80 81       	ld	r24, Z
     824:	28 2f       	mov	r18, r24
     826:	30 e0       	ldi	r19, 0x00	; 0
     828:	81 e0       	ldi	r24, 0x01	; 1
     82a:	90 e0       	ldi	r25, 0x00	; 0
     82c:	02 2e       	mov	r0, r18
     82e:	02 c0       	rjmp	.+4      	; 0x834 <DIO_init+0x7a2>
     830:	88 0f       	add	r24, r24
     832:	99 1f       	adc	r25, r25
     834:	0a 94       	dec	r0
     836:	e2 f7       	brpl	.-8      	; 0x830 <DIO_init+0x79e>
     838:	84 2b       	or	r24, r20
     83a:	8c 93       	st	X, r24
     83c:	e8 c0       	rjmp	.+464    	; 0xa0e <__stack+0x1af>
     83e:	a2 e3       	ldi	r26, 0x32	; 50
     840:	b0 e0       	ldi	r27, 0x00	; 0
     842:	e2 e3       	ldi	r30, 0x32	; 50
     844:	f0 e0       	ldi	r31, 0x00	; 0
     846:	40 81       	ld	r20, Z
     848:	89 81       	ldd	r24, Y+1	; 0x01
     84a:	28 2f       	mov	r18, r24
     84c:	30 e0       	ldi	r19, 0x00	; 0
     84e:	c9 01       	movw	r24, r18
     850:	88 0f       	add	r24, r24
     852:	99 1f       	adc	r25, r25
     854:	88 0f       	add	r24, r24
     856:	99 1f       	adc	r25, r25
     858:	82 0f       	add	r24, r18
     85a:	93 1f       	adc	r25, r19
     85c:	fc 01       	movw	r30, r24
     85e:	e7 58       	subi	r30, 0x87	; 135
     860:	ff 4f       	sbci	r31, 0xFF	; 255
     862:	80 81       	ld	r24, Z
     864:	28 2f       	mov	r18, r24
     866:	30 e0       	ldi	r19, 0x00	; 0
     868:	81 e0       	ldi	r24, 0x01	; 1
     86a:	90 e0       	ldi	r25, 0x00	; 0
     86c:	02 2e       	mov	r0, r18
     86e:	02 c0       	rjmp	.+4      	; 0x874 <__stack+0x15>
     870:	88 0f       	add	r24, r24
     872:	99 1f       	adc	r25, r25
     874:	0a 94       	dec	r0
     876:	e2 f7       	brpl	.-8      	; 0x870 <__stack+0x11>
     878:	84 2b       	or	r24, r20
     87a:	8c 93       	st	X, r24
     87c:	c8 c0       	rjmp	.+400    	; 0xa0e <__stack+0x1af>
     87e:	1a 82       	std	Y+2, r1	; 0x02
     880:	c6 c0       	rjmp	.+396    	; 0xa0e <__stack+0x1af>
     882:	89 81       	ldd	r24, Y+1	; 0x01
     884:	28 2f       	mov	r18, r24
     886:	30 e0       	ldi	r19, 0x00	; 0
     888:	c9 01       	movw	r24, r18
     88a:	88 0f       	add	r24, r24
     88c:	99 1f       	adc	r25, r25
     88e:	88 0f       	add	r24, r24
     890:	99 1f       	adc	r25, r25
     892:	82 0f       	add	r24, r18
     894:	93 1f       	adc	r25, r19
     896:	fc 01       	movw	r30, r24
     898:	e5 58       	subi	r30, 0x85	; 133
     89a:	ff 4f       	sbci	r31, 0xFF	; 255
     89c:	80 81       	ld	r24, Z
     89e:	88 23       	and	r24, r24
     8a0:	09 f0       	breq	.+2      	; 0x8a4 <__stack+0x45>
     8a2:	b4 c0       	rjmp	.+360    	; 0xa0c <__stack+0x1ad>
     8a4:	89 81       	ldd	r24, Y+1	; 0x01
     8a6:	28 2f       	mov	r18, r24
     8a8:	30 e0       	ldi	r19, 0x00	; 0
     8aa:	c9 01       	movw	r24, r18
     8ac:	88 0f       	add	r24, r24
     8ae:	99 1f       	adc	r25, r25
     8b0:	88 0f       	add	r24, r24
     8b2:	99 1f       	adc	r25, r25
     8b4:	82 0f       	add	r24, r18
     8b6:	93 1f       	adc	r25, r19
     8b8:	fc 01       	movw	r30, r24
     8ba:	e8 58       	subi	r30, 0x88	; 136
     8bc:	ff 4f       	sbci	r31, 0xFF	; 255
     8be:	80 81       	ld	r24, Z
     8c0:	28 2f       	mov	r18, r24
     8c2:	30 e0       	ldi	r19, 0x00	; 0
     8c4:	3c 83       	std	Y+4, r19	; 0x04
     8c6:	2b 83       	std	Y+3, r18	; 0x03
     8c8:	8b 81       	ldd	r24, Y+3	; 0x03
     8ca:	9c 81       	ldd	r25, Y+4	; 0x04
     8cc:	81 30       	cpi	r24, 0x01	; 1
     8ce:	91 05       	cpc	r25, r1
     8d0:	c1 f1       	breq	.+112    	; 0x942 <__stack+0xe3>
     8d2:	2b 81       	ldd	r18, Y+3	; 0x03
     8d4:	3c 81       	ldd	r19, Y+4	; 0x04
     8d6:	22 30       	cpi	r18, 0x02	; 2
     8d8:	31 05       	cpc	r19, r1
     8da:	2c f4       	brge	.+10     	; 0x8e6 <__stack+0x87>
     8dc:	8b 81       	ldd	r24, Y+3	; 0x03
     8de:	9c 81       	ldd	r25, Y+4	; 0x04
     8e0:	00 97       	sbiw	r24, 0x00	; 0
     8e2:	71 f0       	breq	.+28     	; 0x900 <__stack+0xa1>
     8e4:	91 c0       	rjmp	.+290    	; 0xa08 <__stack+0x1a9>
     8e6:	2b 81       	ldd	r18, Y+3	; 0x03
     8e8:	3c 81       	ldd	r19, Y+4	; 0x04
     8ea:	22 30       	cpi	r18, 0x02	; 2
     8ec:	31 05       	cpc	r19, r1
     8ee:	09 f4       	brne	.+2      	; 0x8f2 <__stack+0x93>
     8f0:	49 c0       	rjmp	.+146    	; 0x984 <__stack+0x125>
     8f2:	8b 81       	ldd	r24, Y+3	; 0x03
     8f4:	9c 81       	ldd	r25, Y+4	; 0x04
     8f6:	83 30       	cpi	r24, 0x03	; 3
     8f8:	91 05       	cpc	r25, r1
     8fa:	09 f4       	brne	.+2      	; 0x8fe <__stack+0x9f>
     8fc:	64 c0       	rjmp	.+200    	; 0x9c6 <__stack+0x167>
     8fe:	84 c0       	rjmp	.+264    	; 0xa08 <__stack+0x1a9>
     900:	ab e3       	ldi	r26, 0x3B	; 59
     902:	b0 e0       	ldi	r27, 0x00	; 0
     904:	eb e3       	ldi	r30, 0x3B	; 59
     906:	f0 e0       	ldi	r31, 0x00	; 0
     908:	40 81       	ld	r20, Z
     90a:	89 81       	ldd	r24, Y+1	; 0x01
     90c:	28 2f       	mov	r18, r24
     90e:	30 e0       	ldi	r19, 0x00	; 0
     910:	c9 01       	movw	r24, r18
     912:	88 0f       	add	r24, r24
     914:	99 1f       	adc	r25, r25
     916:	88 0f       	add	r24, r24
     918:	99 1f       	adc	r25, r25
     91a:	82 0f       	add	r24, r18
     91c:	93 1f       	adc	r25, r19
     91e:	fc 01       	movw	r30, r24
     920:	e7 58       	subi	r30, 0x87	; 135
     922:	ff 4f       	sbci	r31, 0xFF	; 255
     924:	80 81       	ld	r24, Z
     926:	28 2f       	mov	r18, r24
     928:	30 e0       	ldi	r19, 0x00	; 0
     92a:	81 e0       	ldi	r24, 0x01	; 1
     92c:	90 e0       	ldi	r25, 0x00	; 0
     92e:	02 2e       	mov	r0, r18
     930:	02 c0       	rjmp	.+4      	; 0x936 <__stack+0xd7>
     932:	88 0f       	add	r24, r24
     934:	99 1f       	adc	r25, r25
     936:	0a 94       	dec	r0
     938:	e2 f7       	brpl	.-8      	; 0x932 <__stack+0xd3>
     93a:	80 95       	com	r24
     93c:	84 23       	and	r24, r20
     93e:	8c 93       	st	X, r24
     940:	66 c0       	rjmp	.+204    	; 0xa0e <__stack+0x1af>
     942:	a8 e3       	ldi	r26, 0x38	; 56
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	e8 e3       	ldi	r30, 0x38	; 56
     948:	f0 e0       	ldi	r31, 0x00	; 0
     94a:	40 81       	ld	r20, Z
     94c:	89 81       	ldd	r24, Y+1	; 0x01
     94e:	28 2f       	mov	r18, r24
     950:	30 e0       	ldi	r19, 0x00	; 0
     952:	c9 01       	movw	r24, r18
     954:	88 0f       	add	r24, r24
     956:	99 1f       	adc	r25, r25
     958:	88 0f       	add	r24, r24
     95a:	99 1f       	adc	r25, r25
     95c:	82 0f       	add	r24, r18
     95e:	93 1f       	adc	r25, r19
     960:	fc 01       	movw	r30, r24
     962:	e7 58       	subi	r30, 0x87	; 135
     964:	ff 4f       	sbci	r31, 0xFF	; 255
     966:	80 81       	ld	r24, Z
     968:	28 2f       	mov	r18, r24
     96a:	30 e0       	ldi	r19, 0x00	; 0
     96c:	81 e0       	ldi	r24, 0x01	; 1
     96e:	90 e0       	ldi	r25, 0x00	; 0
     970:	02 2e       	mov	r0, r18
     972:	02 c0       	rjmp	.+4      	; 0x978 <__stack+0x119>
     974:	88 0f       	add	r24, r24
     976:	99 1f       	adc	r25, r25
     978:	0a 94       	dec	r0
     97a:	e2 f7       	brpl	.-8      	; 0x974 <__stack+0x115>
     97c:	80 95       	com	r24
     97e:	84 23       	and	r24, r20
     980:	8c 93       	st	X, r24
     982:	45 c0       	rjmp	.+138    	; 0xa0e <__stack+0x1af>
     984:	a5 e3       	ldi	r26, 0x35	; 53
     986:	b0 e0       	ldi	r27, 0x00	; 0
     988:	e5 e3       	ldi	r30, 0x35	; 53
     98a:	f0 e0       	ldi	r31, 0x00	; 0
     98c:	40 81       	ld	r20, Z
     98e:	89 81       	ldd	r24, Y+1	; 0x01
     990:	28 2f       	mov	r18, r24
     992:	30 e0       	ldi	r19, 0x00	; 0
     994:	c9 01       	movw	r24, r18
     996:	88 0f       	add	r24, r24
     998:	99 1f       	adc	r25, r25
     99a:	88 0f       	add	r24, r24
     99c:	99 1f       	adc	r25, r25
     99e:	82 0f       	add	r24, r18
     9a0:	93 1f       	adc	r25, r19
     9a2:	fc 01       	movw	r30, r24
     9a4:	e7 58       	subi	r30, 0x87	; 135
     9a6:	ff 4f       	sbci	r31, 0xFF	; 255
     9a8:	80 81       	ld	r24, Z
     9aa:	28 2f       	mov	r18, r24
     9ac:	30 e0       	ldi	r19, 0x00	; 0
     9ae:	81 e0       	ldi	r24, 0x01	; 1
     9b0:	90 e0       	ldi	r25, 0x00	; 0
     9b2:	02 2e       	mov	r0, r18
     9b4:	02 c0       	rjmp	.+4      	; 0x9ba <__stack+0x15b>
     9b6:	88 0f       	add	r24, r24
     9b8:	99 1f       	adc	r25, r25
     9ba:	0a 94       	dec	r0
     9bc:	e2 f7       	brpl	.-8      	; 0x9b6 <__stack+0x157>
     9be:	80 95       	com	r24
     9c0:	84 23       	and	r24, r20
     9c2:	8c 93       	st	X, r24
     9c4:	24 c0       	rjmp	.+72     	; 0xa0e <__stack+0x1af>
     9c6:	a2 e3       	ldi	r26, 0x32	; 50
     9c8:	b0 e0       	ldi	r27, 0x00	; 0
     9ca:	e2 e3       	ldi	r30, 0x32	; 50
     9cc:	f0 e0       	ldi	r31, 0x00	; 0
     9ce:	40 81       	ld	r20, Z
     9d0:	89 81       	ldd	r24, Y+1	; 0x01
     9d2:	28 2f       	mov	r18, r24
     9d4:	30 e0       	ldi	r19, 0x00	; 0
     9d6:	c9 01       	movw	r24, r18
     9d8:	88 0f       	add	r24, r24
     9da:	99 1f       	adc	r25, r25
     9dc:	88 0f       	add	r24, r24
     9de:	99 1f       	adc	r25, r25
     9e0:	82 0f       	add	r24, r18
     9e2:	93 1f       	adc	r25, r19
     9e4:	fc 01       	movw	r30, r24
     9e6:	e7 58       	subi	r30, 0x87	; 135
     9e8:	ff 4f       	sbci	r31, 0xFF	; 255
     9ea:	80 81       	ld	r24, Z
     9ec:	28 2f       	mov	r18, r24
     9ee:	30 e0       	ldi	r19, 0x00	; 0
     9f0:	81 e0       	ldi	r24, 0x01	; 1
     9f2:	90 e0       	ldi	r25, 0x00	; 0
     9f4:	02 2e       	mov	r0, r18
     9f6:	02 c0       	rjmp	.+4      	; 0x9fc <__stack+0x19d>
     9f8:	88 0f       	add	r24, r24
     9fa:	99 1f       	adc	r25, r25
     9fc:	0a 94       	dec	r0
     9fe:	e2 f7       	brpl	.-8      	; 0x9f8 <__stack+0x199>
     a00:	80 95       	com	r24
     a02:	84 23       	and	r24, r20
     a04:	8c 93       	st	X, r24
     a06:	03 c0       	rjmp	.+6      	; 0xa0e <__stack+0x1af>
     a08:	1a 82       	std	Y+2, r1	; 0x02
     a0a:	01 c0       	rjmp	.+2      	; 0xa0e <__stack+0x1af>
     a0c:	1a 82       	std	Y+2, r1	; 0x02
     a0e:	89 81       	ldd	r24, Y+1	; 0x01
     a10:	8f 5f       	subi	r24, 0xFF	; 255
     a12:	89 83       	std	Y+1, r24	; 0x01
     a14:	89 81       	ldd	r24, Y+1	; 0x01
     a16:	8b 30       	cpi	r24, 0x0B	; 11
     a18:	08 f4       	brcc	.+2      	; 0xa1c <__stack+0x1bd>
     a1a:	4a cb       	rjmp	.-2412   	; 0xb0 <DIO_init+0x1e>
     a1c:	9a 81       	ldd	r25, Y+2	; 0x02
     a1e:	9b 87       	std	Y+11, r25	; 0x0b
     a20:	8b 85       	ldd	r24, Y+11	; 0x0b
     a22:	2b 96       	adiw	r28, 0x0b	; 11
     a24:	0f b6       	in	r0, 0x3f	; 63
     a26:	f8 94       	cli
     a28:	de bf       	out	0x3e, r29	; 62
     a2a:	0f be       	out	0x3f, r0	; 63
     a2c:	cd bf       	out	0x3d, r28	; 61
     a2e:	cf 91       	pop	r28
     a30:	df 91       	pop	r29
     a32:	08 95       	ret

00000a34 <DIO_set_pin_direction>:
  * Return:status(OK,NOK)
 ************************************
  */

uint8 DIO_set_pin_direction(uint8 port_id,uint8 pin_number,uint8 direction)
{
     a34:	df 93       	push	r29
     a36:	cf 93       	push	r28
     a38:	cd b7       	in	r28, 0x3d	; 61
     a3a:	de b7       	in	r29, 0x3e	; 62
     a3c:	29 97       	sbiw	r28, 0x09	; 9
     a3e:	0f b6       	in	r0, 0x3f	; 63
     a40:	f8 94       	cli
     a42:	de bf       	out	0x3e, r29	; 62
     a44:	0f be       	out	0x3f, r0	; 63
     a46:	cd bf       	out	0x3d, r28	; 61
     a48:	8a 83       	std	Y+2, r24	; 0x02
     a4a:	6b 83       	std	Y+3, r22	; 0x03
     a4c:	4c 83       	std	Y+4, r20	; 0x04

	uint8 retval = OK;
     a4e:	81 e0       	ldi	r24, 0x01	; 1
     a50:	89 83       	std	Y+1, r24	; 0x01

	if( !(pin_number>=PIN0 && pin_number<=PIN7) )
     a52:	8b 81       	ldd	r24, Y+3	; 0x03
     a54:	88 30       	cpi	r24, 0x08	; 8
     a56:	20 f0       	brcs	.+8      	; 0xa60 <DIO_set_pin_direction+0x2c>

		return retval=NOK;
     a58:	19 82       	std	Y+1, r1	; 0x01
     a5a:	29 81       	ldd	r18, Y+1	; 0x01
     a5c:	29 87       	std	Y+9, r18	; 0x09
     a5e:	e9 c0       	rjmp	.+466    	; 0xc32 <DIO_set_pin_direction+0x1fe>

	if(direction==OUTPUT)
     a60:	8c 81       	ldd	r24, Y+4	; 0x04
     a62:	81 30       	cpi	r24, 0x01	; 1
     a64:	09 f0       	breq	.+2      	; 0xa68 <DIO_set_pin_direction+0x34>
     a66:	6d c0       	rjmp	.+218    	; 0xb42 <DIO_set_pin_direction+0x10e>
	{

		switch (port_id)
     a68:	8a 81       	ldd	r24, Y+2	; 0x02
     a6a:	28 2f       	mov	r18, r24
     a6c:	30 e0       	ldi	r19, 0x00	; 0
     a6e:	38 87       	std	Y+8, r19	; 0x08
     a70:	2f 83       	std	Y+7, r18	; 0x07
     a72:	8f 81       	ldd	r24, Y+7	; 0x07
     a74:	98 85       	ldd	r25, Y+8	; 0x08
     a76:	81 30       	cpi	r24, 0x01	; 1
     a78:	91 05       	cpc	r25, r1
     a7a:	41 f1       	breq	.+80     	; 0xacc <DIO_set_pin_direction+0x98>
     a7c:	2f 81       	ldd	r18, Y+7	; 0x07
     a7e:	38 85       	ldd	r19, Y+8	; 0x08
     a80:	22 30       	cpi	r18, 0x02	; 2
     a82:	31 05       	cpc	r19, r1
     a84:	2c f4       	brge	.+10     	; 0xa90 <DIO_set_pin_direction+0x5c>
     a86:	8f 81       	ldd	r24, Y+7	; 0x07
     a88:	98 85       	ldd	r25, Y+8	; 0x08
     a8a:	00 97       	sbiw	r24, 0x00	; 0
     a8c:	61 f0       	breq	.+24     	; 0xaa6 <DIO_set_pin_direction+0x72>
     a8e:	57 c0       	rjmp	.+174    	; 0xb3e <DIO_set_pin_direction+0x10a>
     a90:	2f 81       	ldd	r18, Y+7	; 0x07
     a92:	38 85       	ldd	r19, Y+8	; 0x08
     a94:	22 30       	cpi	r18, 0x02	; 2
     a96:	31 05       	cpc	r19, r1
     a98:	61 f1       	breq	.+88     	; 0xaf2 <DIO_set_pin_direction+0xbe>
     a9a:	8f 81       	ldd	r24, Y+7	; 0x07
     a9c:	98 85       	ldd	r25, Y+8	; 0x08
     a9e:	83 30       	cpi	r24, 0x03	; 3
     aa0:	91 05       	cpc	r25, r1
     aa2:	d1 f1       	breq	.+116    	; 0xb18 <DIO_set_pin_direction+0xe4>
     aa4:	4c c0       	rjmp	.+152    	; 0xb3e <DIO_set_pin_direction+0x10a>
		{
		case PORT_A:
			set_bit(REG_DDRA,pin_number);
     aa6:	aa e3       	ldi	r26, 0x3A	; 58
     aa8:	b0 e0       	ldi	r27, 0x00	; 0
     aaa:	ea e3       	ldi	r30, 0x3A	; 58
     aac:	f0 e0       	ldi	r31, 0x00	; 0
     aae:	40 81       	ld	r20, Z
     ab0:	8b 81       	ldd	r24, Y+3	; 0x03
     ab2:	28 2f       	mov	r18, r24
     ab4:	30 e0       	ldi	r19, 0x00	; 0
     ab6:	81 e0       	ldi	r24, 0x01	; 1
     ab8:	90 e0       	ldi	r25, 0x00	; 0
     aba:	02 2e       	mov	r0, r18
     abc:	02 c0       	rjmp	.+4      	; 0xac2 <DIO_set_pin_direction+0x8e>
     abe:	88 0f       	add	r24, r24
     ac0:	99 1f       	adc	r25, r25
     ac2:	0a 94       	dec	r0
     ac4:	e2 f7       	brpl	.-8      	; 0xabe <DIO_set_pin_direction+0x8a>
     ac6:	84 2b       	or	r24, r20
     ac8:	8c 93       	st	X, r24
     aca:	b1 c0       	rjmp	.+354    	; 0xc2e <DIO_set_pin_direction+0x1fa>
			break;

		case PORT_B:
			set_bit(REG_DDRB,pin_number);
     acc:	a7 e3       	ldi	r26, 0x37	; 55
     ace:	b0 e0       	ldi	r27, 0x00	; 0
     ad0:	e7 e3       	ldi	r30, 0x37	; 55
     ad2:	f0 e0       	ldi	r31, 0x00	; 0
     ad4:	40 81       	ld	r20, Z
     ad6:	8b 81       	ldd	r24, Y+3	; 0x03
     ad8:	28 2f       	mov	r18, r24
     ada:	30 e0       	ldi	r19, 0x00	; 0
     adc:	81 e0       	ldi	r24, 0x01	; 1
     ade:	90 e0       	ldi	r25, 0x00	; 0
     ae0:	02 2e       	mov	r0, r18
     ae2:	02 c0       	rjmp	.+4      	; 0xae8 <DIO_set_pin_direction+0xb4>
     ae4:	88 0f       	add	r24, r24
     ae6:	99 1f       	adc	r25, r25
     ae8:	0a 94       	dec	r0
     aea:	e2 f7       	brpl	.-8      	; 0xae4 <DIO_set_pin_direction+0xb0>
     aec:	84 2b       	or	r24, r20
     aee:	8c 93       	st	X, r24
     af0:	9e c0       	rjmp	.+316    	; 0xc2e <DIO_set_pin_direction+0x1fa>
			break;

		case PORT_C:
			set_bit(REG_DDRC,pin_number);
     af2:	a4 e3       	ldi	r26, 0x34	; 52
     af4:	b0 e0       	ldi	r27, 0x00	; 0
     af6:	e4 e3       	ldi	r30, 0x34	; 52
     af8:	f0 e0       	ldi	r31, 0x00	; 0
     afa:	40 81       	ld	r20, Z
     afc:	8b 81       	ldd	r24, Y+3	; 0x03
     afe:	28 2f       	mov	r18, r24
     b00:	30 e0       	ldi	r19, 0x00	; 0
     b02:	81 e0       	ldi	r24, 0x01	; 1
     b04:	90 e0       	ldi	r25, 0x00	; 0
     b06:	02 2e       	mov	r0, r18
     b08:	02 c0       	rjmp	.+4      	; 0xb0e <DIO_set_pin_direction+0xda>
     b0a:	88 0f       	add	r24, r24
     b0c:	99 1f       	adc	r25, r25
     b0e:	0a 94       	dec	r0
     b10:	e2 f7       	brpl	.-8      	; 0xb0a <DIO_set_pin_direction+0xd6>
     b12:	84 2b       	or	r24, r20
     b14:	8c 93       	st	X, r24
     b16:	8b c0       	rjmp	.+278    	; 0xc2e <DIO_set_pin_direction+0x1fa>
			break;

		case PORT_D:
			set_bit(REG_DDRD,pin_number);
     b18:	a1 e3       	ldi	r26, 0x31	; 49
     b1a:	b0 e0       	ldi	r27, 0x00	; 0
     b1c:	e1 e3       	ldi	r30, 0x31	; 49
     b1e:	f0 e0       	ldi	r31, 0x00	; 0
     b20:	40 81       	ld	r20, Z
     b22:	8b 81       	ldd	r24, Y+3	; 0x03
     b24:	28 2f       	mov	r18, r24
     b26:	30 e0       	ldi	r19, 0x00	; 0
     b28:	81 e0       	ldi	r24, 0x01	; 1
     b2a:	90 e0       	ldi	r25, 0x00	; 0
     b2c:	02 2e       	mov	r0, r18
     b2e:	02 c0       	rjmp	.+4      	; 0xb34 <DIO_set_pin_direction+0x100>
     b30:	88 0f       	add	r24, r24
     b32:	99 1f       	adc	r25, r25
     b34:	0a 94       	dec	r0
     b36:	e2 f7       	brpl	.-8      	; 0xb30 <DIO_set_pin_direction+0xfc>
     b38:	84 2b       	or	r24, r20
     b3a:	8c 93       	st	X, r24
     b3c:	78 c0       	rjmp	.+240    	; 0xc2e <DIO_set_pin_direction+0x1fa>
			break;
		default :
			retval =NOK;
     b3e:	19 82       	std	Y+1, r1	; 0x01
     b40:	76 c0       	rjmp	.+236    	; 0xc2e <DIO_set_pin_direction+0x1fa>

		}

	}
	else if (direction ==INPUT)
     b42:	8c 81       	ldd	r24, Y+4	; 0x04
     b44:	88 23       	and	r24, r24
     b46:	09 f0       	breq	.+2      	; 0xb4a <DIO_set_pin_direction+0x116>
     b48:	71 c0       	rjmp	.+226    	; 0xc2c <DIO_set_pin_direction+0x1f8>
	{
		switch (port_id)
     b4a:	8a 81       	ldd	r24, Y+2	; 0x02
     b4c:	28 2f       	mov	r18, r24
     b4e:	30 e0       	ldi	r19, 0x00	; 0
     b50:	3e 83       	std	Y+6, r19	; 0x06
     b52:	2d 83       	std	Y+5, r18	; 0x05
     b54:	8d 81       	ldd	r24, Y+5	; 0x05
     b56:	9e 81       	ldd	r25, Y+6	; 0x06
     b58:	81 30       	cpi	r24, 0x01	; 1
     b5a:	91 05       	cpc	r25, r1
     b5c:	49 f1       	breq	.+82     	; 0xbb0 <DIO_set_pin_direction+0x17c>
     b5e:	2d 81       	ldd	r18, Y+5	; 0x05
     b60:	3e 81       	ldd	r19, Y+6	; 0x06
     b62:	22 30       	cpi	r18, 0x02	; 2
     b64:	31 05       	cpc	r19, r1
     b66:	2c f4       	brge	.+10     	; 0xb72 <DIO_set_pin_direction+0x13e>
     b68:	8d 81       	ldd	r24, Y+5	; 0x05
     b6a:	9e 81       	ldd	r25, Y+6	; 0x06
     b6c:	00 97       	sbiw	r24, 0x00	; 0
     b6e:	61 f0       	breq	.+24     	; 0xb88 <DIO_set_pin_direction+0x154>
     b70:	5b c0       	rjmp	.+182    	; 0xc28 <DIO_set_pin_direction+0x1f4>
     b72:	2d 81       	ldd	r18, Y+5	; 0x05
     b74:	3e 81       	ldd	r19, Y+6	; 0x06
     b76:	22 30       	cpi	r18, 0x02	; 2
     b78:	31 05       	cpc	r19, r1
     b7a:	71 f1       	breq	.+92     	; 0xbd8 <DIO_set_pin_direction+0x1a4>
     b7c:	8d 81       	ldd	r24, Y+5	; 0x05
     b7e:	9e 81       	ldd	r25, Y+6	; 0x06
     b80:	83 30       	cpi	r24, 0x03	; 3
     b82:	91 05       	cpc	r25, r1
     b84:	e9 f1       	breq	.+122    	; 0xc00 <DIO_set_pin_direction+0x1cc>
     b86:	50 c0       	rjmp	.+160    	; 0xc28 <DIO_set_pin_direction+0x1f4>
		{
		case PORT_A:
			clr_bit(REG_DDRA,pin_number);
     b88:	aa e3       	ldi	r26, 0x3A	; 58
     b8a:	b0 e0       	ldi	r27, 0x00	; 0
     b8c:	ea e3       	ldi	r30, 0x3A	; 58
     b8e:	f0 e0       	ldi	r31, 0x00	; 0
     b90:	40 81       	ld	r20, Z
     b92:	8b 81       	ldd	r24, Y+3	; 0x03
     b94:	28 2f       	mov	r18, r24
     b96:	30 e0       	ldi	r19, 0x00	; 0
     b98:	81 e0       	ldi	r24, 0x01	; 1
     b9a:	90 e0       	ldi	r25, 0x00	; 0
     b9c:	02 2e       	mov	r0, r18
     b9e:	02 c0       	rjmp	.+4      	; 0xba4 <DIO_set_pin_direction+0x170>
     ba0:	88 0f       	add	r24, r24
     ba2:	99 1f       	adc	r25, r25
     ba4:	0a 94       	dec	r0
     ba6:	e2 f7       	brpl	.-8      	; 0xba0 <DIO_set_pin_direction+0x16c>
     ba8:	80 95       	com	r24
     baa:	84 23       	and	r24, r20
     bac:	8c 93       	st	X, r24
     bae:	3f c0       	rjmp	.+126    	; 0xc2e <DIO_set_pin_direction+0x1fa>
			break;

		case PORT_B:
			clr_bit(REG_DDRB,pin_number);
     bb0:	a7 e3       	ldi	r26, 0x37	; 55
     bb2:	b0 e0       	ldi	r27, 0x00	; 0
     bb4:	e7 e3       	ldi	r30, 0x37	; 55
     bb6:	f0 e0       	ldi	r31, 0x00	; 0
     bb8:	40 81       	ld	r20, Z
     bba:	8b 81       	ldd	r24, Y+3	; 0x03
     bbc:	28 2f       	mov	r18, r24
     bbe:	30 e0       	ldi	r19, 0x00	; 0
     bc0:	81 e0       	ldi	r24, 0x01	; 1
     bc2:	90 e0       	ldi	r25, 0x00	; 0
     bc4:	02 2e       	mov	r0, r18
     bc6:	02 c0       	rjmp	.+4      	; 0xbcc <DIO_set_pin_direction+0x198>
     bc8:	88 0f       	add	r24, r24
     bca:	99 1f       	adc	r25, r25
     bcc:	0a 94       	dec	r0
     bce:	e2 f7       	brpl	.-8      	; 0xbc8 <DIO_set_pin_direction+0x194>
     bd0:	80 95       	com	r24
     bd2:	84 23       	and	r24, r20
     bd4:	8c 93       	st	X, r24
     bd6:	2b c0       	rjmp	.+86     	; 0xc2e <DIO_set_pin_direction+0x1fa>
			break;

		case PORT_C:
			clr_bit(REG_DDRC,pin_number);
     bd8:	a4 e3       	ldi	r26, 0x34	; 52
     bda:	b0 e0       	ldi	r27, 0x00	; 0
     bdc:	e4 e3       	ldi	r30, 0x34	; 52
     bde:	f0 e0       	ldi	r31, 0x00	; 0
     be0:	40 81       	ld	r20, Z
     be2:	8b 81       	ldd	r24, Y+3	; 0x03
     be4:	28 2f       	mov	r18, r24
     be6:	30 e0       	ldi	r19, 0x00	; 0
     be8:	81 e0       	ldi	r24, 0x01	; 1
     bea:	90 e0       	ldi	r25, 0x00	; 0
     bec:	02 2e       	mov	r0, r18
     bee:	02 c0       	rjmp	.+4      	; 0xbf4 <DIO_set_pin_direction+0x1c0>
     bf0:	88 0f       	add	r24, r24
     bf2:	99 1f       	adc	r25, r25
     bf4:	0a 94       	dec	r0
     bf6:	e2 f7       	brpl	.-8      	; 0xbf0 <DIO_set_pin_direction+0x1bc>
     bf8:	80 95       	com	r24
     bfa:	84 23       	and	r24, r20
     bfc:	8c 93       	st	X, r24
     bfe:	17 c0       	rjmp	.+46     	; 0xc2e <DIO_set_pin_direction+0x1fa>
			break;

		case PORT_D:
			clr_bit(REG_DDRD,pin_number);
     c00:	a1 e3       	ldi	r26, 0x31	; 49
     c02:	b0 e0       	ldi	r27, 0x00	; 0
     c04:	e1 e3       	ldi	r30, 0x31	; 49
     c06:	f0 e0       	ldi	r31, 0x00	; 0
     c08:	40 81       	ld	r20, Z
     c0a:	8b 81       	ldd	r24, Y+3	; 0x03
     c0c:	28 2f       	mov	r18, r24
     c0e:	30 e0       	ldi	r19, 0x00	; 0
     c10:	81 e0       	ldi	r24, 0x01	; 1
     c12:	90 e0       	ldi	r25, 0x00	; 0
     c14:	02 2e       	mov	r0, r18
     c16:	02 c0       	rjmp	.+4      	; 0xc1c <DIO_set_pin_direction+0x1e8>
     c18:	88 0f       	add	r24, r24
     c1a:	99 1f       	adc	r25, r25
     c1c:	0a 94       	dec	r0
     c1e:	e2 f7       	brpl	.-8      	; 0xc18 <DIO_set_pin_direction+0x1e4>
     c20:	80 95       	com	r24
     c22:	84 23       	and	r24, r20
     c24:	8c 93       	st	X, r24
     c26:	03 c0       	rjmp	.+6      	; 0xc2e <DIO_set_pin_direction+0x1fa>
			break;
		default :
			retval =NOK;
     c28:	19 82       	std	Y+1, r1	; 0x01
     c2a:	01 c0       	rjmp	.+2      	; 0xc2e <DIO_set_pin_direction+0x1fa>
		}

	}
	else
	{
		retval =NOK;
     c2c:	19 82       	std	Y+1, r1	; 0x01
	}
	return retval;
     c2e:	99 81       	ldd	r25, Y+1	; 0x01
     c30:	99 87       	std	Y+9, r25	; 0x09
     c32:	89 85       	ldd	r24, Y+9	; 0x09

}
     c34:	29 96       	adiw	r28, 0x09	; 9
     c36:	0f b6       	in	r0, 0x3f	; 63
     c38:	f8 94       	cli
     c3a:	de bf       	out	0x3e, r29	; 62
     c3c:	0f be       	out	0x3f, r0	; 63
     c3e:	cd bf       	out	0x3d, r28	; 61
     c40:	cf 91       	pop	r28
     c42:	df 91       	pop	r29
     c44:	08 95       	ret

00000c46 <DIO_write_pin_value>:
  * Return:status(OK,NOK)
 ************************************
  */

uint8 DIO_write_pin_value(uint8 port_id,uint8 pin_number,uint8 value)
{
     c46:	df 93       	push	r29
     c48:	cf 93       	push	r28
     c4a:	cd b7       	in	r28, 0x3d	; 61
     c4c:	de b7       	in	r29, 0x3e	; 62
     c4e:	29 97       	sbiw	r28, 0x09	; 9
     c50:	0f b6       	in	r0, 0x3f	; 63
     c52:	f8 94       	cli
     c54:	de bf       	out	0x3e, r29	; 62
     c56:	0f be       	out	0x3f, r0	; 63
     c58:	cd bf       	out	0x3d, r28	; 61
     c5a:	8a 83       	std	Y+2, r24	; 0x02
     c5c:	6b 83       	std	Y+3, r22	; 0x03
     c5e:	4c 83       	std	Y+4, r20	; 0x04

	uint8 retval = OK;
     c60:	81 e0       	ldi	r24, 0x01	; 1
     c62:	89 83       	std	Y+1, r24	; 0x01

	if( !(pin_number>=PIN0 && pin_number<=PIN7) )
     c64:	8b 81       	ldd	r24, Y+3	; 0x03
     c66:	88 30       	cpi	r24, 0x08	; 8
     c68:	20 f0       	brcs	.+8      	; 0xc72 <DIO_write_pin_value+0x2c>

		return retval=NOK;
     c6a:	19 82       	std	Y+1, r1	; 0x01
     c6c:	29 81       	ldd	r18, Y+1	; 0x01
     c6e:	29 87       	std	Y+9, r18	; 0x09
     c70:	e9 c0       	rjmp	.+466    	; 0xe44 <DIO_write_pin_value+0x1fe>


	if( value==HIGH )
     c72:	8c 81       	ldd	r24, Y+4	; 0x04
     c74:	81 30       	cpi	r24, 0x01	; 1
     c76:	09 f0       	breq	.+2      	; 0xc7a <DIO_write_pin_value+0x34>
     c78:	6d c0       	rjmp	.+218    	; 0xd54 <DIO_write_pin_value+0x10e>
	{

		switch (port_id)
     c7a:	8a 81       	ldd	r24, Y+2	; 0x02
     c7c:	28 2f       	mov	r18, r24
     c7e:	30 e0       	ldi	r19, 0x00	; 0
     c80:	38 87       	std	Y+8, r19	; 0x08
     c82:	2f 83       	std	Y+7, r18	; 0x07
     c84:	8f 81       	ldd	r24, Y+7	; 0x07
     c86:	98 85       	ldd	r25, Y+8	; 0x08
     c88:	81 30       	cpi	r24, 0x01	; 1
     c8a:	91 05       	cpc	r25, r1
     c8c:	41 f1       	breq	.+80     	; 0xcde <DIO_write_pin_value+0x98>
     c8e:	2f 81       	ldd	r18, Y+7	; 0x07
     c90:	38 85       	ldd	r19, Y+8	; 0x08
     c92:	22 30       	cpi	r18, 0x02	; 2
     c94:	31 05       	cpc	r19, r1
     c96:	2c f4       	brge	.+10     	; 0xca2 <DIO_write_pin_value+0x5c>
     c98:	8f 81       	ldd	r24, Y+7	; 0x07
     c9a:	98 85       	ldd	r25, Y+8	; 0x08
     c9c:	00 97       	sbiw	r24, 0x00	; 0
     c9e:	61 f0       	breq	.+24     	; 0xcb8 <DIO_write_pin_value+0x72>
     ca0:	57 c0       	rjmp	.+174    	; 0xd50 <DIO_write_pin_value+0x10a>
     ca2:	2f 81       	ldd	r18, Y+7	; 0x07
     ca4:	38 85       	ldd	r19, Y+8	; 0x08
     ca6:	22 30       	cpi	r18, 0x02	; 2
     ca8:	31 05       	cpc	r19, r1
     caa:	61 f1       	breq	.+88     	; 0xd04 <DIO_write_pin_value+0xbe>
     cac:	8f 81       	ldd	r24, Y+7	; 0x07
     cae:	98 85       	ldd	r25, Y+8	; 0x08
     cb0:	83 30       	cpi	r24, 0x03	; 3
     cb2:	91 05       	cpc	r25, r1
     cb4:	d1 f1       	breq	.+116    	; 0xd2a <DIO_write_pin_value+0xe4>
     cb6:	4c c0       	rjmp	.+152    	; 0xd50 <DIO_write_pin_value+0x10a>
		{
		case PORT_A:

			set_bit(REG_PORTA,pin_number);
     cb8:	ab e3       	ldi	r26, 0x3B	; 59
     cba:	b0 e0       	ldi	r27, 0x00	; 0
     cbc:	eb e3       	ldi	r30, 0x3B	; 59
     cbe:	f0 e0       	ldi	r31, 0x00	; 0
     cc0:	40 81       	ld	r20, Z
     cc2:	8b 81       	ldd	r24, Y+3	; 0x03
     cc4:	28 2f       	mov	r18, r24
     cc6:	30 e0       	ldi	r19, 0x00	; 0
     cc8:	81 e0       	ldi	r24, 0x01	; 1
     cca:	90 e0       	ldi	r25, 0x00	; 0
     ccc:	02 2e       	mov	r0, r18
     cce:	02 c0       	rjmp	.+4      	; 0xcd4 <DIO_write_pin_value+0x8e>
     cd0:	88 0f       	add	r24, r24
     cd2:	99 1f       	adc	r25, r25
     cd4:	0a 94       	dec	r0
     cd6:	e2 f7       	brpl	.-8      	; 0xcd0 <DIO_write_pin_value+0x8a>
     cd8:	84 2b       	or	r24, r20
     cda:	8c 93       	st	X, r24
     cdc:	b1 c0       	rjmp	.+354    	; 0xe40 <DIO_write_pin_value+0x1fa>


			break;

		case PORT_B:
			set_bit(REG_PORTB,pin_number);
     cde:	a8 e3       	ldi	r26, 0x38	; 56
     ce0:	b0 e0       	ldi	r27, 0x00	; 0
     ce2:	e8 e3       	ldi	r30, 0x38	; 56
     ce4:	f0 e0       	ldi	r31, 0x00	; 0
     ce6:	40 81       	ld	r20, Z
     ce8:	8b 81       	ldd	r24, Y+3	; 0x03
     cea:	28 2f       	mov	r18, r24
     cec:	30 e0       	ldi	r19, 0x00	; 0
     cee:	81 e0       	ldi	r24, 0x01	; 1
     cf0:	90 e0       	ldi	r25, 0x00	; 0
     cf2:	02 2e       	mov	r0, r18
     cf4:	02 c0       	rjmp	.+4      	; 0xcfa <DIO_write_pin_value+0xb4>
     cf6:	88 0f       	add	r24, r24
     cf8:	99 1f       	adc	r25, r25
     cfa:	0a 94       	dec	r0
     cfc:	e2 f7       	brpl	.-8      	; 0xcf6 <DIO_write_pin_value+0xb0>
     cfe:	84 2b       	or	r24, r20
     d00:	8c 93       	st	X, r24
     d02:	9e c0       	rjmp	.+316    	; 0xe40 <DIO_write_pin_value+0x1fa>
			break;

		case PORT_C:
			set_bit(REG_PORTC,pin_number);
     d04:	a5 e3       	ldi	r26, 0x35	; 53
     d06:	b0 e0       	ldi	r27, 0x00	; 0
     d08:	e5 e3       	ldi	r30, 0x35	; 53
     d0a:	f0 e0       	ldi	r31, 0x00	; 0
     d0c:	40 81       	ld	r20, Z
     d0e:	8b 81       	ldd	r24, Y+3	; 0x03
     d10:	28 2f       	mov	r18, r24
     d12:	30 e0       	ldi	r19, 0x00	; 0
     d14:	81 e0       	ldi	r24, 0x01	; 1
     d16:	90 e0       	ldi	r25, 0x00	; 0
     d18:	02 2e       	mov	r0, r18
     d1a:	02 c0       	rjmp	.+4      	; 0xd20 <DIO_write_pin_value+0xda>
     d1c:	88 0f       	add	r24, r24
     d1e:	99 1f       	adc	r25, r25
     d20:	0a 94       	dec	r0
     d22:	e2 f7       	brpl	.-8      	; 0xd1c <DIO_write_pin_value+0xd6>
     d24:	84 2b       	or	r24, r20
     d26:	8c 93       	st	X, r24
     d28:	8b c0       	rjmp	.+278    	; 0xe40 <DIO_write_pin_value+0x1fa>
			break;

		case PORT_D:
			set_bit(REG_PORTD,pin_number);
     d2a:	a2 e3       	ldi	r26, 0x32	; 50
     d2c:	b0 e0       	ldi	r27, 0x00	; 0
     d2e:	e2 e3       	ldi	r30, 0x32	; 50
     d30:	f0 e0       	ldi	r31, 0x00	; 0
     d32:	40 81       	ld	r20, Z
     d34:	8b 81       	ldd	r24, Y+3	; 0x03
     d36:	28 2f       	mov	r18, r24
     d38:	30 e0       	ldi	r19, 0x00	; 0
     d3a:	81 e0       	ldi	r24, 0x01	; 1
     d3c:	90 e0       	ldi	r25, 0x00	; 0
     d3e:	02 2e       	mov	r0, r18
     d40:	02 c0       	rjmp	.+4      	; 0xd46 <DIO_write_pin_value+0x100>
     d42:	88 0f       	add	r24, r24
     d44:	99 1f       	adc	r25, r25
     d46:	0a 94       	dec	r0
     d48:	e2 f7       	brpl	.-8      	; 0xd42 <DIO_write_pin_value+0xfc>
     d4a:	84 2b       	or	r24, r20
     d4c:	8c 93       	st	X, r24
     d4e:	78 c0       	rjmp	.+240    	; 0xe40 <DIO_write_pin_value+0x1fa>
			break;
		default :
			retval =NOK;
     d50:	19 82       	std	Y+1, r1	; 0x01
     d52:	76 c0       	rjmp	.+236    	; 0xe40 <DIO_write_pin_value+0x1fa>

		}
	}


	else if (value==LOW)
     d54:	8c 81       	ldd	r24, Y+4	; 0x04
     d56:	88 23       	and	r24, r24
     d58:	09 f0       	breq	.+2      	; 0xd5c <DIO_write_pin_value+0x116>
     d5a:	71 c0       	rjmp	.+226    	; 0xe3e <DIO_write_pin_value+0x1f8>
	{

		switch (port_id)
     d5c:	8a 81       	ldd	r24, Y+2	; 0x02
     d5e:	28 2f       	mov	r18, r24
     d60:	30 e0       	ldi	r19, 0x00	; 0
     d62:	3e 83       	std	Y+6, r19	; 0x06
     d64:	2d 83       	std	Y+5, r18	; 0x05
     d66:	8d 81       	ldd	r24, Y+5	; 0x05
     d68:	9e 81       	ldd	r25, Y+6	; 0x06
     d6a:	81 30       	cpi	r24, 0x01	; 1
     d6c:	91 05       	cpc	r25, r1
     d6e:	49 f1       	breq	.+82     	; 0xdc2 <DIO_write_pin_value+0x17c>
     d70:	2d 81       	ldd	r18, Y+5	; 0x05
     d72:	3e 81       	ldd	r19, Y+6	; 0x06
     d74:	22 30       	cpi	r18, 0x02	; 2
     d76:	31 05       	cpc	r19, r1
     d78:	2c f4       	brge	.+10     	; 0xd84 <DIO_write_pin_value+0x13e>
     d7a:	8d 81       	ldd	r24, Y+5	; 0x05
     d7c:	9e 81       	ldd	r25, Y+6	; 0x06
     d7e:	00 97       	sbiw	r24, 0x00	; 0
     d80:	61 f0       	breq	.+24     	; 0xd9a <DIO_write_pin_value+0x154>
     d82:	5b c0       	rjmp	.+182    	; 0xe3a <DIO_write_pin_value+0x1f4>
     d84:	2d 81       	ldd	r18, Y+5	; 0x05
     d86:	3e 81       	ldd	r19, Y+6	; 0x06
     d88:	22 30       	cpi	r18, 0x02	; 2
     d8a:	31 05       	cpc	r19, r1
     d8c:	71 f1       	breq	.+92     	; 0xdea <DIO_write_pin_value+0x1a4>
     d8e:	8d 81       	ldd	r24, Y+5	; 0x05
     d90:	9e 81       	ldd	r25, Y+6	; 0x06
     d92:	83 30       	cpi	r24, 0x03	; 3
     d94:	91 05       	cpc	r25, r1
     d96:	e9 f1       	breq	.+122    	; 0xe12 <DIO_write_pin_value+0x1cc>
     d98:	50 c0       	rjmp	.+160    	; 0xe3a <DIO_write_pin_value+0x1f4>
		{
		case PORT_A:
			clr_bit(REG_PORTA,pin_number);
     d9a:	ab e3       	ldi	r26, 0x3B	; 59
     d9c:	b0 e0       	ldi	r27, 0x00	; 0
     d9e:	eb e3       	ldi	r30, 0x3B	; 59
     da0:	f0 e0       	ldi	r31, 0x00	; 0
     da2:	40 81       	ld	r20, Z
     da4:	8b 81       	ldd	r24, Y+3	; 0x03
     da6:	28 2f       	mov	r18, r24
     da8:	30 e0       	ldi	r19, 0x00	; 0
     daa:	81 e0       	ldi	r24, 0x01	; 1
     dac:	90 e0       	ldi	r25, 0x00	; 0
     dae:	02 2e       	mov	r0, r18
     db0:	02 c0       	rjmp	.+4      	; 0xdb6 <DIO_write_pin_value+0x170>
     db2:	88 0f       	add	r24, r24
     db4:	99 1f       	adc	r25, r25
     db6:	0a 94       	dec	r0
     db8:	e2 f7       	brpl	.-8      	; 0xdb2 <DIO_write_pin_value+0x16c>
     dba:	80 95       	com	r24
     dbc:	84 23       	and	r24, r20
     dbe:	8c 93       	st	X, r24
     dc0:	3f c0       	rjmp	.+126    	; 0xe40 <DIO_write_pin_value+0x1fa>
			break;

		case PORT_B:
			clr_bit(REG_PORTB,pin_number);
     dc2:	a8 e3       	ldi	r26, 0x38	; 56
     dc4:	b0 e0       	ldi	r27, 0x00	; 0
     dc6:	e8 e3       	ldi	r30, 0x38	; 56
     dc8:	f0 e0       	ldi	r31, 0x00	; 0
     dca:	40 81       	ld	r20, Z
     dcc:	8b 81       	ldd	r24, Y+3	; 0x03
     dce:	28 2f       	mov	r18, r24
     dd0:	30 e0       	ldi	r19, 0x00	; 0
     dd2:	81 e0       	ldi	r24, 0x01	; 1
     dd4:	90 e0       	ldi	r25, 0x00	; 0
     dd6:	02 2e       	mov	r0, r18
     dd8:	02 c0       	rjmp	.+4      	; 0xdde <DIO_write_pin_value+0x198>
     dda:	88 0f       	add	r24, r24
     ddc:	99 1f       	adc	r25, r25
     dde:	0a 94       	dec	r0
     de0:	e2 f7       	brpl	.-8      	; 0xdda <DIO_write_pin_value+0x194>
     de2:	80 95       	com	r24
     de4:	84 23       	and	r24, r20
     de6:	8c 93       	st	X, r24
     de8:	2b c0       	rjmp	.+86     	; 0xe40 <DIO_write_pin_value+0x1fa>
			break;

		case PORT_C:
			clr_bit(REG_PORTC,pin_number);
     dea:	a5 e3       	ldi	r26, 0x35	; 53
     dec:	b0 e0       	ldi	r27, 0x00	; 0
     dee:	e5 e3       	ldi	r30, 0x35	; 53
     df0:	f0 e0       	ldi	r31, 0x00	; 0
     df2:	40 81       	ld	r20, Z
     df4:	8b 81       	ldd	r24, Y+3	; 0x03
     df6:	28 2f       	mov	r18, r24
     df8:	30 e0       	ldi	r19, 0x00	; 0
     dfa:	81 e0       	ldi	r24, 0x01	; 1
     dfc:	90 e0       	ldi	r25, 0x00	; 0
     dfe:	02 2e       	mov	r0, r18
     e00:	02 c0       	rjmp	.+4      	; 0xe06 <DIO_write_pin_value+0x1c0>
     e02:	88 0f       	add	r24, r24
     e04:	99 1f       	adc	r25, r25
     e06:	0a 94       	dec	r0
     e08:	e2 f7       	brpl	.-8      	; 0xe02 <DIO_write_pin_value+0x1bc>
     e0a:	80 95       	com	r24
     e0c:	84 23       	and	r24, r20
     e0e:	8c 93       	st	X, r24
     e10:	17 c0       	rjmp	.+46     	; 0xe40 <DIO_write_pin_value+0x1fa>
			break;

		case PORT_D:
			clr_bit(REG_PORTD,pin_number);
     e12:	a2 e3       	ldi	r26, 0x32	; 50
     e14:	b0 e0       	ldi	r27, 0x00	; 0
     e16:	e2 e3       	ldi	r30, 0x32	; 50
     e18:	f0 e0       	ldi	r31, 0x00	; 0
     e1a:	40 81       	ld	r20, Z
     e1c:	8b 81       	ldd	r24, Y+3	; 0x03
     e1e:	28 2f       	mov	r18, r24
     e20:	30 e0       	ldi	r19, 0x00	; 0
     e22:	81 e0       	ldi	r24, 0x01	; 1
     e24:	90 e0       	ldi	r25, 0x00	; 0
     e26:	02 2e       	mov	r0, r18
     e28:	02 c0       	rjmp	.+4      	; 0xe2e <DIO_write_pin_value+0x1e8>
     e2a:	88 0f       	add	r24, r24
     e2c:	99 1f       	adc	r25, r25
     e2e:	0a 94       	dec	r0
     e30:	e2 f7       	brpl	.-8      	; 0xe2a <DIO_write_pin_value+0x1e4>
     e32:	80 95       	com	r24
     e34:	84 23       	and	r24, r20
     e36:	8c 93       	st	X, r24
     e38:	03 c0       	rjmp	.+6      	; 0xe40 <DIO_write_pin_value+0x1fa>
			break;
		default :
			retval =NOK;
     e3a:	19 82       	std	Y+1, r1	; 0x01
     e3c:	01 c0       	rjmp	.+2      	; 0xe40 <DIO_write_pin_value+0x1fa>
		}

	}
	else
	{
		retval =NOK;
     e3e:	19 82       	std	Y+1, r1	; 0x01

	}
	return retval;
     e40:	99 81       	ldd	r25, Y+1	; 0x01
     e42:	99 87       	std	Y+9, r25	; 0x09
     e44:	89 85       	ldd	r24, Y+9	; 0x09
}
     e46:	29 96       	adiw	r28, 0x09	; 9
     e48:	0f b6       	in	r0, 0x3f	; 63
     e4a:	f8 94       	cli
     e4c:	de bf       	out	0x3e, r29	; 62
     e4e:	0f be       	out	0x3f, r0	; 63
     e50:	cd bf       	out	0x3d, r28	; 61
     e52:	cf 91       	pop	r28
     e54:	df 91       	pop	r29
     e56:	08 95       	ret

00000e58 <DIO_read_pin_value>:
  * Input:port_id,pin_number,pointer to put got value in.
  * Return:status(OK,NOK)
 ************************************
  */
uint8  DIO_read_pin_value(uint8 port_id,uint8 pin_number,uint8* got)
{
     e58:	df 93       	push	r29
     e5a:	cf 93       	push	r28
     e5c:	cd b7       	in	r28, 0x3d	; 61
     e5e:	de b7       	in	r29, 0x3e	; 62
     e60:	28 97       	sbiw	r28, 0x08	; 8
     e62:	0f b6       	in	r0, 0x3f	; 63
     e64:	f8 94       	cli
     e66:	de bf       	out	0x3e, r29	; 62
     e68:	0f be       	out	0x3f, r0	; 63
     e6a:	cd bf       	out	0x3d, r28	; 61
     e6c:	8a 83       	std	Y+2, r24	; 0x02
     e6e:	6b 83       	std	Y+3, r22	; 0x03
     e70:	5d 83       	std	Y+5, r21	; 0x05
     e72:	4c 83       	std	Y+4, r20	; 0x04
	uint8 retval = OK;
     e74:	81 e0       	ldi	r24, 0x01	; 1
     e76:	89 83       	std	Y+1, r24	; 0x01

	if(! (pin_number>=PIN0 && pin_number<=PIN7) )
     e78:	8b 81       	ldd	r24, Y+3	; 0x03
     e7a:	88 30       	cpi	r24, 0x08	; 8
     e7c:	20 f0       	brcs	.+8      	; 0xe86 <DIO_read_pin_value+0x2e>

		return retval=NOK;
     e7e:	19 82       	std	Y+1, r1	; 0x01
     e80:	29 81       	ldd	r18, Y+1	; 0x01
     e82:	28 87       	std	Y+8, r18	; 0x08
     e84:	a5 c0       	rjmp	.+330    	; 0xfd0 <DIO_read_pin_value+0x178>



	switch (port_id)
     e86:	8a 81       	ldd	r24, Y+2	; 0x02
     e88:	48 2f       	mov	r20, r24
     e8a:	50 e0       	ldi	r21, 0x00	; 0
     e8c:	5f 83       	std	Y+7, r21	; 0x07
     e8e:	4e 83       	std	Y+6, r20	; 0x06
     e90:	8e 81       	ldd	r24, Y+6	; 0x06
     e92:	9f 81       	ldd	r25, Y+7	; 0x07
     e94:	81 30       	cpi	r24, 0x01	; 1
     e96:	91 05       	cpc	r25, r1
     e98:	c1 f1       	breq	.+112    	; 0xf0a <DIO_read_pin_value+0xb2>
     e9a:	2e 81       	ldd	r18, Y+6	; 0x06
     e9c:	3f 81       	ldd	r19, Y+7	; 0x07
     e9e:	22 30       	cpi	r18, 0x02	; 2
     ea0:	31 05       	cpc	r19, r1
     ea2:	34 f4       	brge	.+12     	; 0xeb0 <DIO_read_pin_value+0x58>
     ea4:	4e 81       	ldd	r20, Y+6	; 0x06
     ea6:	5f 81       	ldd	r21, Y+7	; 0x07
     ea8:	41 15       	cp	r20, r1
     eaa:	51 05       	cpc	r21, r1
     eac:	71 f0       	breq	.+28     	; 0xeca <DIO_read_pin_value+0x72>
     eae:	8d c0       	rjmp	.+282    	; 0xfca <DIO_read_pin_value+0x172>
     eb0:	8e 81       	ldd	r24, Y+6	; 0x06
     eb2:	9f 81       	ldd	r25, Y+7	; 0x07
     eb4:	82 30       	cpi	r24, 0x02	; 2
     eb6:	91 05       	cpc	r25, r1
     eb8:	09 f4       	brne	.+2      	; 0xebc <DIO_read_pin_value+0x64>
     eba:	47 c0       	rjmp	.+142    	; 0xf4a <DIO_read_pin_value+0xf2>
     ebc:	2e 81       	ldd	r18, Y+6	; 0x06
     ebe:	3f 81       	ldd	r19, Y+7	; 0x07
     ec0:	23 30       	cpi	r18, 0x03	; 3
     ec2:	31 05       	cpc	r19, r1
     ec4:	09 f4       	brne	.+2      	; 0xec8 <DIO_read_pin_value+0x70>
     ec6:	61 c0       	rjmp	.+194    	; 0xf8a <DIO_read_pin_value+0x132>
     ec8:	80 c0       	rjmp	.+256    	; 0xfca <DIO_read_pin_value+0x172>
	{
	case PORT_A:
		*got=get_bit(REG_PINA,pin_number);
     eca:	e9 e3       	ldi	r30, 0x39	; 57
     ecc:	f0 e0       	ldi	r31, 0x00	; 0
     ece:	80 81       	ld	r24, Z
     ed0:	48 2f       	mov	r20, r24
     ed2:	50 e0       	ldi	r21, 0x00	; 0
     ed4:	8b 81       	ldd	r24, Y+3	; 0x03
     ed6:	28 2f       	mov	r18, r24
     ed8:	30 e0       	ldi	r19, 0x00	; 0
     eda:	81 e0       	ldi	r24, 0x01	; 1
     edc:	90 e0       	ldi	r25, 0x00	; 0
     ede:	02 c0       	rjmp	.+4      	; 0xee4 <DIO_read_pin_value+0x8c>
     ee0:	88 0f       	add	r24, r24
     ee2:	99 1f       	adc	r25, r25
     ee4:	2a 95       	dec	r18
     ee6:	e2 f7       	brpl	.-8      	; 0xee0 <DIO_read_pin_value+0x88>
     ee8:	9a 01       	movw	r18, r20
     eea:	28 23       	and	r18, r24
     eec:	39 23       	and	r19, r25
     eee:	8b 81       	ldd	r24, Y+3	; 0x03
     ef0:	88 2f       	mov	r24, r24
     ef2:	90 e0       	ldi	r25, 0x00	; 0
     ef4:	a9 01       	movw	r20, r18
     ef6:	02 c0       	rjmp	.+4      	; 0xefc <DIO_read_pin_value+0xa4>
     ef8:	56 95       	lsr	r21
     efa:	47 95       	ror	r20
     efc:	8a 95       	dec	r24
     efe:	e2 f7       	brpl	.-8      	; 0xef8 <DIO_read_pin_value+0xa0>
     f00:	ca 01       	movw	r24, r20
     f02:	ec 81       	ldd	r30, Y+4	; 0x04
     f04:	fd 81       	ldd	r31, Y+5	; 0x05
     f06:	80 83       	st	Z, r24
     f08:	61 c0       	rjmp	.+194    	; 0xfcc <DIO_read_pin_value+0x174>
		break;

	case PORT_B:
		*got=get_bit(REG_PINB,pin_number);
     f0a:	e6 e3       	ldi	r30, 0x36	; 54
     f0c:	f0 e0       	ldi	r31, 0x00	; 0
     f0e:	80 81       	ld	r24, Z
     f10:	48 2f       	mov	r20, r24
     f12:	50 e0       	ldi	r21, 0x00	; 0
     f14:	8b 81       	ldd	r24, Y+3	; 0x03
     f16:	28 2f       	mov	r18, r24
     f18:	30 e0       	ldi	r19, 0x00	; 0
     f1a:	81 e0       	ldi	r24, 0x01	; 1
     f1c:	90 e0       	ldi	r25, 0x00	; 0
     f1e:	02 c0       	rjmp	.+4      	; 0xf24 <DIO_read_pin_value+0xcc>
     f20:	88 0f       	add	r24, r24
     f22:	99 1f       	adc	r25, r25
     f24:	2a 95       	dec	r18
     f26:	e2 f7       	brpl	.-8      	; 0xf20 <DIO_read_pin_value+0xc8>
     f28:	9a 01       	movw	r18, r20
     f2a:	28 23       	and	r18, r24
     f2c:	39 23       	and	r19, r25
     f2e:	8b 81       	ldd	r24, Y+3	; 0x03
     f30:	88 2f       	mov	r24, r24
     f32:	90 e0       	ldi	r25, 0x00	; 0
     f34:	a9 01       	movw	r20, r18
     f36:	02 c0       	rjmp	.+4      	; 0xf3c <DIO_read_pin_value+0xe4>
     f38:	56 95       	lsr	r21
     f3a:	47 95       	ror	r20
     f3c:	8a 95       	dec	r24
     f3e:	e2 f7       	brpl	.-8      	; 0xf38 <DIO_read_pin_value+0xe0>
     f40:	ca 01       	movw	r24, r20
     f42:	ec 81       	ldd	r30, Y+4	; 0x04
     f44:	fd 81       	ldd	r31, Y+5	; 0x05
     f46:	80 83       	st	Z, r24
     f48:	41 c0       	rjmp	.+130    	; 0xfcc <DIO_read_pin_value+0x174>
		break;

	case PORT_C:
		*got=get_bit(REG_PINC,pin_number);
     f4a:	e3 e3       	ldi	r30, 0x33	; 51
     f4c:	f0 e0       	ldi	r31, 0x00	; 0
     f4e:	80 81       	ld	r24, Z
     f50:	48 2f       	mov	r20, r24
     f52:	50 e0       	ldi	r21, 0x00	; 0
     f54:	8b 81       	ldd	r24, Y+3	; 0x03
     f56:	28 2f       	mov	r18, r24
     f58:	30 e0       	ldi	r19, 0x00	; 0
     f5a:	81 e0       	ldi	r24, 0x01	; 1
     f5c:	90 e0       	ldi	r25, 0x00	; 0
     f5e:	02 c0       	rjmp	.+4      	; 0xf64 <DIO_read_pin_value+0x10c>
     f60:	88 0f       	add	r24, r24
     f62:	99 1f       	adc	r25, r25
     f64:	2a 95       	dec	r18
     f66:	e2 f7       	brpl	.-8      	; 0xf60 <DIO_read_pin_value+0x108>
     f68:	9a 01       	movw	r18, r20
     f6a:	28 23       	and	r18, r24
     f6c:	39 23       	and	r19, r25
     f6e:	8b 81       	ldd	r24, Y+3	; 0x03
     f70:	88 2f       	mov	r24, r24
     f72:	90 e0       	ldi	r25, 0x00	; 0
     f74:	a9 01       	movw	r20, r18
     f76:	02 c0       	rjmp	.+4      	; 0xf7c <DIO_read_pin_value+0x124>
     f78:	56 95       	lsr	r21
     f7a:	47 95       	ror	r20
     f7c:	8a 95       	dec	r24
     f7e:	e2 f7       	brpl	.-8      	; 0xf78 <DIO_read_pin_value+0x120>
     f80:	ca 01       	movw	r24, r20
     f82:	ec 81       	ldd	r30, Y+4	; 0x04
     f84:	fd 81       	ldd	r31, Y+5	; 0x05
     f86:	80 83       	st	Z, r24
     f88:	21 c0       	rjmp	.+66     	; 0xfcc <DIO_read_pin_value+0x174>
		break;

	case PORT_D:
		*got=get_bit(REG_PIND,pin_number);
     f8a:	e0 e3       	ldi	r30, 0x30	; 48
     f8c:	f0 e0       	ldi	r31, 0x00	; 0
     f8e:	80 81       	ld	r24, Z
     f90:	48 2f       	mov	r20, r24
     f92:	50 e0       	ldi	r21, 0x00	; 0
     f94:	8b 81       	ldd	r24, Y+3	; 0x03
     f96:	28 2f       	mov	r18, r24
     f98:	30 e0       	ldi	r19, 0x00	; 0
     f9a:	81 e0       	ldi	r24, 0x01	; 1
     f9c:	90 e0       	ldi	r25, 0x00	; 0
     f9e:	02 c0       	rjmp	.+4      	; 0xfa4 <DIO_read_pin_value+0x14c>
     fa0:	88 0f       	add	r24, r24
     fa2:	99 1f       	adc	r25, r25
     fa4:	2a 95       	dec	r18
     fa6:	e2 f7       	brpl	.-8      	; 0xfa0 <DIO_read_pin_value+0x148>
     fa8:	9a 01       	movw	r18, r20
     faa:	28 23       	and	r18, r24
     fac:	39 23       	and	r19, r25
     fae:	8b 81       	ldd	r24, Y+3	; 0x03
     fb0:	88 2f       	mov	r24, r24
     fb2:	90 e0       	ldi	r25, 0x00	; 0
     fb4:	a9 01       	movw	r20, r18
     fb6:	02 c0       	rjmp	.+4      	; 0xfbc <DIO_read_pin_value+0x164>
     fb8:	56 95       	lsr	r21
     fba:	47 95       	ror	r20
     fbc:	8a 95       	dec	r24
     fbe:	e2 f7       	brpl	.-8      	; 0xfb8 <DIO_read_pin_value+0x160>
     fc0:	ca 01       	movw	r24, r20
     fc2:	ec 81       	ldd	r30, Y+4	; 0x04
     fc4:	fd 81       	ldd	r31, Y+5	; 0x05
     fc6:	80 83       	st	Z, r24
     fc8:	01 c0       	rjmp	.+2      	; 0xfcc <DIO_read_pin_value+0x174>
		break;
	default :
		retval=NOK;
     fca:	19 82       	std	Y+1, r1	; 0x01
	}
	return retval;
     fcc:	59 81       	ldd	r21, Y+1	; 0x01
     fce:	58 87       	std	Y+8, r21	; 0x08
     fd0:	88 85       	ldd	r24, Y+8	; 0x08

}
     fd2:	28 96       	adiw	r28, 0x08	; 8
     fd4:	0f b6       	in	r0, 0x3f	; 63
     fd6:	f8 94       	cli
     fd8:	de bf       	out	0x3e, r29	; 62
     fda:	0f be       	out	0x3f, r0	; 63
     fdc:	cd bf       	out	0x3d, r28	; 61
     fde:	cf 91       	pop	r28
     fe0:	df 91       	pop	r29
     fe2:	08 95       	ret

00000fe4 <DIO_set_port_direction>:
  * Input:port_id,value that express direction (i.e 0x0f)
  * Return:status(OK,NOK)
 ************************************
  */
uint8 DIO_set_port_direction(uint8 port_id,uint8 value)
{
     fe4:	df 93       	push	r29
     fe6:	cf 93       	push	r28
     fe8:	00 d0       	rcall	.+0      	; 0xfea <DIO_set_port_direction+0x6>
     fea:	00 d0       	rcall	.+0      	; 0xfec <DIO_set_port_direction+0x8>
     fec:	0f 92       	push	r0
     fee:	cd b7       	in	r28, 0x3d	; 61
     ff0:	de b7       	in	r29, 0x3e	; 62
     ff2:	8a 83       	std	Y+2, r24	; 0x02
     ff4:	6b 83       	std	Y+3, r22	; 0x03
	uint8 retval = OK;
     ff6:	81 e0       	ldi	r24, 0x01	; 1
     ff8:	89 83       	std	Y+1, r24	; 0x01

	if(! (value>=0 && value<=255) )

		return retval=NOK;

	switch (port_id)
     ffa:	8a 81       	ldd	r24, Y+2	; 0x02
     ffc:	28 2f       	mov	r18, r24
     ffe:	30 e0       	ldi	r19, 0x00	; 0
    1000:	3d 83       	std	Y+5, r19	; 0x05
    1002:	2c 83       	std	Y+4, r18	; 0x04
    1004:	8c 81       	ldd	r24, Y+4	; 0x04
    1006:	9d 81       	ldd	r25, Y+5	; 0x05
    1008:	81 30       	cpi	r24, 0x01	; 1
    100a:	91 05       	cpc	r25, r1
    100c:	d1 f0       	breq	.+52     	; 0x1042 <DIO_set_port_direction+0x5e>
    100e:	2c 81       	ldd	r18, Y+4	; 0x04
    1010:	3d 81       	ldd	r19, Y+5	; 0x05
    1012:	22 30       	cpi	r18, 0x02	; 2
    1014:	31 05       	cpc	r19, r1
    1016:	2c f4       	brge	.+10     	; 0x1022 <DIO_set_port_direction+0x3e>
    1018:	8c 81       	ldd	r24, Y+4	; 0x04
    101a:	9d 81       	ldd	r25, Y+5	; 0x05
    101c:	00 97       	sbiw	r24, 0x00	; 0
    101e:	61 f0       	breq	.+24     	; 0x1038 <DIO_set_port_direction+0x54>
    1020:	1f c0       	rjmp	.+62     	; 0x1060 <DIO_set_port_direction+0x7c>
    1022:	2c 81       	ldd	r18, Y+4	; 0x04
    1024:	3d 81       	ldd	r19, Y+5	; 0x05
    1026:	22 30       	cpi	r18, 0x02	; 2
    1028:	31 05       	cpc	r19, r1
    102a:	81 f0       	breq	.+32     	; 0x104c <DIO_set_port_direction+0x68>
    102c:	8c 81       	ldd	r24, Y+4	; 0x04
    102e:	9d 81       	ldd	r25, Y+5	; 0x05
    1030:	83 30       	cpi	r24, 0x03	; 3
    1032:	91 05       	cpc	r25, r1
    1034:	81 f0       	breq	.+32     	; 0x1056 <DIO_set_port_direction+0x72>
    1036:	14 c0       	rjmp	.+40     	; 0x1060 <DIO_set_port_direction+0x7c>
	{
	case PORT_A:
		REG_DDRA=value;
    1038:	ea e3       	ldi	r30, 0x3A	; 58
    103a:	f0 e0       	ldi	r31, 0x00	; 0
    103c:	8b 81       	ldd	r24, Y+3	; 0x03
    103e:	80 83       	st	Z, r24
    1040:	10 c0       	rjmp	.+32     	; 0x1062 <DIO_set_port_direction+0x7e>
		break;

	case PORT_B:
		REG_DDRB=value;
    1042:	e7 e3       	ldi	r30, 0x37	; 55
    1044:	f0 e0       	ldi	r31, 0x00	; 0
    1046:	8b 81       	ldd	r24, Y+3	; 0x03
    1048:	80 83       	st	Z, r24
    104a:	0b c0       	rjmp	.+22     	; 0x1062 <DIO_set_port_direction+0x7e>
		break;

	case PORT_C:
		REG_DDRC=value;
    104c:	e4 e3       	ldi	r30, 0x34	; 52
    104e:	f0 e0       	ldi	r31, 0x00	; 0
    1050:	8b 81       	ldd	r24, Y+3	; 0x03
    1052:	80 83       	st	Z, r24
    1054:	06 c0       	rjmp	.+12     	; 0x1062 <DIO_set_port_direction+0x7e>
		break;

	case PORT_D:
		REG_DDRD=value;
    1056:	e1 e3       	ldi	r30, 0x31	; 49
    1058:	f0 e0       	ldi	r31, 0x00	; 0
    105a:	8b 81       	ldd	r24, Y+3	; 0x03
    105c:	80 83       	st	Z, r24
    105e:	01 c0       	rjmp	.+2      	; 0x1062 <DIO_set_port_direction+0x7e>
		break;
	default:
		retval=NOK;
    1060:	19 82       	std	Y+1, r1	; 0x01
	}
	return retval;
    1062:	89 81       	ldd	r24, Y+1	; 0x01

}
    1064:	0f 90       	pop	r0
    1066:	0f 90       	pop	r0
    1068:	0f 90       	pop	r0
    106a:	0f 90       	pop	r0
    106c:	0f 90       	pop	r0
    106e:	cf 91       	pop	r28
    1070:	df 91       	pop	r29
    1072:	08 95       	ret

00001074 <DIO_write_port_value>:
  * Input:port_id,pin_number,value
  * Return:status(OK,NOK)
 ************************************
  */
uint8 DIO_write_port_value(uint8 port_id,uint8 value)
{
    1074:	df 93       	push	r29
    1076:	cf 93       	push	r28
    1078:	00 d0       	rcall	.+0      	; 0x107a <DIO_write_port_value+0x6>
    107a:	00 d0       	rcall	.+0      	; 0x107c <DIO_write_port_value+0x8>
    107c:	0f 92       	push	r0
    107e:	cd b7       	in	r28, 0x3d	; 61
    1080:	de b7       	in	r29, 0x3e	; 62
    1082:	8a 83       	std	Y+2, r24	; 0x02
    1084:	6b 83       	std	Y+3, r22	; 0x03
	uint8 retval = OK;
    1086:	81 e0       	ldi	r24, 0x01	; 1
    1088:	89 83       	std	Y+1, r24	; 0x01

	if(! (value>=0 && value<=255) )

		return retval=NOK;

	switch (port_id)
    108a:	8a 81       	ldd	r24, Y+2	; 0x02
    108c:	28 2f       	mov	r18, r24
    108e:	30 e0       	ldi	r19, 0x00	; 0
    1090:	3d 83       	std	Y+5, r19	; 0x05
    1092:	2c 83       	std	Y+4, r18	; 0x04
    1094:	8c 81       	ldd	r24, Y+4	; 0x04
    1096:	9d 81       	ldd	r25, Y+5	; 0x05
    1098:	81 30       	cpi	r24, 0x01	; 1
    109a:	91 05       	cpc	r25, r1
    109c:	d1 f0       	breq	.+52     	; 0x10d2 <DIO_write_port_value+0x5e>
    109e:	2c 81       	ldd	r18, Y+4	; 0x04
    10a0:	3d 81       	ldd	r19, Y+5	; 0x05
    10a2:	22 30       	cpi	r18, 0x02	; 2
    10a4:	31 05       	cpc	r19, r1
    10a6:	2c f4       	brge	.+10     	; 0x10b2 <DIO_write_port_value+0x3e>
    10a8:	8c 81       	ldd	r24, Y+4	; 0x04
    10aa:	9d 81       	ldd	r25, Y+5	; 0x05
    10ac:	00 97       	sbiw	r24, 0x00	; 0
    10ae:	61 f0       	breq	.+24     	; 0x10c8 <DIO_write_port_value+0x54>
    10b0:	1f c0       	rjmp	.+62     	; 0x10f0 <DIO_write_port_value+0x7c>
    10b2:	2c 81       	ldd	r18, Y+4	; 0x04
    10b4:	3d 81       	ldd	r19, Y+5	; 0x05
    10b6:	22 30       	cpi	r18, 0x02	; 2
    10b8:	31 05       	cpc	r19, r1
    10ba:	81 f0       	breq	.+32     	; 0x10dc <DIO_write_port_value+0x68>
    10bc:	8c 81       	ldd	r24, Y+4	; 0x04
    10be:	9d 81       	ldd	r25, Y+5	; 0x05
    10c0:	83 30       	cpi	r24, 0x03	; 3
    10c2:	91 05       	cpc	r25, r1
    10c4:	81 f0       	breq	.+32     	; 0x10e6 <DIO_write_port_value+0x72>
    10c6:	14 c0       	rjmp	.+40     	; 0x10f0 <DIO_write_port_value+0x7c>
	{
	case PORT_A:
		REG_PORTA=value;
    10c8:	eb e3       	ldi	r30, 0x3B	; 59
    10ca:	f0 e0       	ldi	r31, 0x00	; 0
    10cc:	8b 81       	ldd	r24, Y+3	; 0x03
    10ce:	80 83       	st	Z, r24
    10d0:	10 c0       	rjmp	.+32     	; 0x10f2 <DIO_write_port_value+0x7e>
		break;

	case PORT_B:
		REG_PORTB=value;
    10d2:	e8 e3       	ldi	r30, 0x38	; 56
    10d4:	f0 e0       	ldi	r31, 0x00	; 0
    10d6:	8b 81       	ldd	r24, Y+3	; 0x03
    10d8:	80 83       	st	Z, r24
    10da:	0b c0       	rjmp	.+22     	; 0x10f2 <DIO_write_port_value+0x7e>
		break;

	case PORT_C:
		REG_PORTC=value;
    10dc:	e5 e3       	ldi	r30, 0x35	; 53
    10de:	f0 e0       	ldi	r31, 0x00	; 0
    10e0:	8b 81       	ldd	r24, Y+3	; 0x03
    10e2:	80 83       	st	Z, r24
    10e4:	06 c0       	rjmp	.+12     	; 0x10f2 <DIO_write_port_value+0x7e>
		break;

	case PORT_D:
		REG_PORTD=value;
    10e6:	e2 e3       	ldi	r30, 0x32	; 50
    10e8:	f0 e0       	ldi	r31, 0x00	; 0
    10ea:	8b 81       	ldd	r24, Y+3	; 0x03
    10ec:	80 83       	st	Z, r24
    10ee:	01 c0       	rjmp	.+2      	; 0x10f2 <DIO_write_port_value+0x7e>
		break;
	default:
		retval=NOK;
    10f0:	19 82       	std	Y+1, r1	; 0x01
	}
	return retval;
    10f2:	89 81       	ldd	r24, Y+1	; 0x01
}
    10f4:	0f 90       	pop	r0
    10f6:	0f 90       	pop	r0
    10f8:	0f 90       	pop	r0
    10fa:	0f 90       	pop	r0
    10fc:	0f 90       	pop	r0
    10fe:	cf 91       	pop	r28
    1100:	df 91       	pop	r29
    1102:	08 95       	ret

00001104 <DIO_read_port_value>:
  * Return:status(OK,NOK)
 ************************************
  */
uint8 DIO_read_port_value(uint8 port_id,uint8* got)

{
    1104:	df 93       	push	r29
    1106:	cf 93       	push	r28
    1108:	00 d0       	rcall	.+0      	; 0x110a <DIO_read_port_value+0x6>
    110a:	00 d0       	rcall	.+0      	; 0x110c <DIO_read_port_value+0x8>
    110c:	00 d0       	rcall	.+0      	; 0x110e <DIO_read_port_value+0xa>
    110e:	cd b7       	in	r28, 0x3d	; 61
    1110:	de b7       	in	r29, 0x3e	; 62
    1112:	8a 83       	std	Y+2, r24	; 0x02
    1114:	7c 83       	std	Y+4, r23	; 0x04
    1116:	6b 83       	std	Y+3, r22	; 0x03
	uint8 retval = OK;
    1118:	81 e0       	ldi	r24, 0x01	; 1
    111a:	89 83       	std	Y+1, r24	; 0x01

	switch (port_id)
    111c:	8a 81       	ldd	r24, Y+2	; 0x02
    111e:	28 2f       	mov	r18, r24
    1120:	30 e0       	ldi	r19, 0x00	; 0
    1122:	3e 83       	std	Y+6, r19	; 0x06
    1124:	2d 83       	std	Y+5, r18	; 0x05
    1126:	8d 81       	ldd	r24, Y+5	; 0x05
    1128:	9e 81       	ldd	r25, Y+6	; 0x06
    112a:	81 30       	cpi	r24, 0x01	; 1
    112c:	91 05       	cpc	r25, r1
    112e:	e1 f0       	breq	.+56     	; 0x1168 <DIO_read_port_value+0x64>
    1130:	2d 81       	ldd	r18, Y+5	; 0x05
    1132:	3e 81       	ldd	r19, Y+6	; 0x06
    1134:	22 30       	cpi	r18, 0x02	; 2
    1136:	31 05       	cpc	r19, r1
    1138:	2c f4       	brge	.+10     	; 0x1144 <DIO_read_port_value+0x40>
    113a:	8d 81       	ldd	r24, Y+5	; 0x05
    113c:	9e 81       	ldd	r25, Y+6	; 0x06
    113e:	00 97       	sbiw	r24, 0x00	; 0
    1140:	61 f0       	breq	.+24     	; 0x115a <DIO_read_port_value+0x56>
    1142:	27 c0       	rjmp	.+78     	; 0x1192 <DIO_read_port_value+0x8e>
    1144:	2d 81       	ldd	r18, Y+5	; 0x05
    1146:	3e 81       	ldd	r19, Y+6	; 0x06
    1148:	22 30       	cpi	r18, 0x02	; 2
    114a:	31 05       	cpc	r19, r1
    114c:	a1 f0       	breq	.+40     	; 0x1176 <DIO_read_port_value+0x72>
    114e:	8d 81       	ldd	r24, Y+5	; 0x05
    1150:	9e 81       	ldd	r25, Y+6	; 0x06
    1152:	83 30       	cpi	r24, 0x03	; 3
    1154:	91 05       	cpc	r25, r1
    1156:	b1 f0       	breq	.+44     	; 0x1184 <DIO_read_port_value+0x80>
    1158:	1c c0       	rjmp	.+56     	; 0x1192 <DIO_read_port_value+0x8e>
	{
	case PORT_A:
		*got=REG_PINA;
    115a:	e9 e3       	ldi	r30, 0x39	; 57
    115c:	f0 e0       	ldi	r31, 0x00	; 0
    115e:	80 81       	ld	r24, Z
    1160:	eb 81       	ldd	r30, Y+3	; 0x03
    1162:	fc 81       	ldd	r31, Y+4	; 0x04
    1164:	80 83       	st	Z, r24
    1166:	16 c0       	rjmp	.+44     	; 0x1194 <DIO_read_port_value+0x90>
		break;

	case PORT_B:
		*got=REG_PINB;
    1168:	e6 e3       	ldi	r30, 0x36	; 54
    116a:	f0 e0       	ldi	r31, 0x00	; 0
    116c:	80 81       	ld	r24, Z
    116e:	eb 81       	ldd	r30, Y+3	; 0x03
    1170:	fc 81       	ldd	r31, Y+4	; 0x04
    1172:	80 83       	st	Z, r24
    1174:	0f c0       	rjmp	.+30     	; 0x1194 <DIO_read_port_value+0x90>
		break;

	case PORT_C:
		*got=REG_PINC;
    1176:	e3 e3       	ldi	r30, 0x33	; 51
    1178:	f0 e0       	ldi	r31, 0x00	; 0
    117a:	80 81       	ld	r24, Z
    117c:	eb 81       	ldd	r30, Y+3	; 0x03
    117e:	fc 81       	ldd	r31, Y+4	; 0x04
    1180:	80 83       	st	Z, r24
    1182:	08 c0       	rjmp	.+16     	; 0x1194 <DIO_read_port_value+0x90>
		break;

	case PORT_D:
		*got=REG_PIND;
    1184:	e0 e3       	ldi	r30, 0x30	; 48
    1186:	f0 e0       	ldi	r31, 0x00	; 0
    1188:	80 81       	ld	r24, Z
    118a:	eb 81       	ldd	r30, Y+3	; 0x03
    118c:	fc 81       	ldd	r31, Y+4	; 0x04
    118e:	80 83       	st	Z, r24
    1190:	01 c0       	rjmp	.+2      	; 0x1194 <DIO_read_port_value+0x90>
		break;
	default:
		retval=NOK;
    1192:	19 82       	std	Y+1, r1	; 0x01
	}

	return retval;
    1194:	89 81       	ldd	r24, Y+1	; 0x01


}
    1196:	26 96       	adiw	r28, 0x06	; 6
    1198:	0f b6       	in	r0, 0x3f	; 63
    119a:	f8 94       	cli
    119c:	de bf       	out	0x3e, r29	; 62
    119e:	0f be       	out	0x3f, r0	; 63
    11a0:	cd bf       	out	0x3d, r28	; 61
    11a2:	cf 91       	pop	r28
    11a4:	df 91       	pop	r29
    11a6:	08 95       	ret

000011a8 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
    11a8:	df 93       	push	r29
    11aa:	cf 93       	push	r28
    11ac:	00 d0       	rcall	.+0      	; 0x11ae <xEventGroupCreate+0x6>
    11ae:	cd b7       	in	r28, 0x3d	; 61
    11b0:	de b7       	in	r29, 0x3e	; 62
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
    11b2:	8b e0       	ldi	r24, 0x0B	; 11
    11b4:	90 e0       	ldi	r25, 0x00	; 0
    11b6:	0e 94 19 0c 	call	0x1832	; 0x1832 <pvPortMalloc>
    11ba:	9a 83       	std	Y+2, r25	; 0x02
    11bc:	89 83       	std	Y+1, r24	; 0x01

		if( pxEventBits != NULL )
    11be:	89 81       	ldd	r24, Y+1	; 0x01
    11c0:	9a 81       	ldd	r25, Y+2	; 0x02
    11c2:	00 97       	sbiw	r24, 0x00	; 0
    11c4:	49 f0       	breq	.+18     	; 0x11d8 <xEventGroupCreate+0x30>
		{
			pxEventBits->uxEventBits = 0;
    11c6:	e9 81       	ldd	r30, Y+1	; 0x01
    11c8:	fa 81       	ldd	r31, Y+2	; 0x02
    11ca:	11 82       	std	Z+1, r1	; 0x01
    11cc:	10 82       	st	Z, r1
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    11ce:	89 81       	ldd	r24, Y+1	; 0x01
    11d0:	9a 81       	ldd	r25, Y+2	; 0x02
    11d2:	02 96       	adiw	r24, 0x02	; 2
    11d4:	0e 94 95 0c 	call	0x192a	; 0x192a <vListInitialise>
		else
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
    11d8:	89 81       	ldd	r24, Y+1	; 0x01
    11da:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    11dc:	0f 90       	pop	r0
    11de:	0f 90       	pop	r0
    11e0:	cf 91       	pop	r28
    11e2:	df 91       	pop	r29
    11e4:	08 95       	ret

000011e6 <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
    11e6:	df 93       	push	r29
    11e8:	cf 93       	push	r28
    11ea:	cd b7       	in	r28, 0x3d	; 61
    11ec:	de b7       	in	r29, 0x3e	; 62
    11ee:	60 97       	sbiw	r28, 0x10	; 16
    11f0:	0f b6       	in	r0, 0x3f	; 63
    11f2:	f8 94       	cli
    11f4:	de bf       	out	0x3e, r29	; 62
    11f6:	0f be       	out	0x3f, r0	; 63
    11f8:	cd bf       	out	0x3d, r28	; 61
    11fa:	9a 87       	std	Y+10, r25	; 0x0a
    11fc:	89 87       	std	Y+9, r24	; 0x09
    11fe:	7c 87       	std	Y+12, r23	; 0x0c
    1200:	6b 87       	std	Y+11, r22	; 0x0b
    1202:	5e 87       	std	Y+14, r21	; 0x0e
    1204:	4d 87       	std	Y+13, r20	; 0x0d
    1206:	38 8b       	std	Y+16, r19	; 0x10
    1208:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = xEventGroup;
    120a:	89 85       	ldd	r24, Y+9	; 0x09
    120c:	9a 85       	ldd	r25, Y+10	; 0x0a
    120e:	9c 83       	std	Y+4, r25	; 0x04
    1210:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    1212:	19 82       	std	Y+1, r1	; 0x01
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    1214:	0e 94 43 23 	call	0x4686	; 0x4686 <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
    1218:	eb 81       	ldd	r30, Y+3	; 0x03
    121a:	fc 81       	ldd	r31, Y+4	; 0x04
    121c:	80 81       	ld	r24, Z
    121e:	91 81       	ldd	r25, Z+1	; 0x01
    1220:	98 87       	std	Y+8, r25	; 0x08
    1222:	8f 83       	std	Y+7, r24	; 0x07

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    1224:	89 85       	ldd	r24, Y+9	; 0x09
    1226:	9a 85       	ldd	r25, Y+10	; 0x0a
    1228:	2b 85       	ldd	r18, Y+11	; 0x0b
    122a:	3c 85       	ldd	r19, Y+12	; 0x0c
    122c:	b9 01       	movw	r22, r18
    122e:	0e 94 ca 0a 	call	0x1594	; 0x1594 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1232:	2f 81       	ldd	r18, Y+7	; 0x07
    1234:	38 85       	ldd	r19, Y+8	; 0x08
    1236:	8b 85       	ldd	r24, Y+11	; 0x0b
    1238:	9c 85       	ldd	r25, Y+12	; 0x0c
    123a:	28 2b       	or	r18, r24
    123c:	39 2b       	or	r19, r25
    123e:	8d 85       	ldd	r24, Y+13	; 0x0d
    1240:	9e 85       	ldd	r25, Y+14	; 0x0e
    1242:	28 23       	and	r18, r24
    1244:	39 23       	and	r19, r25
    1246:	8d 85       	ldd	r24, Y+13	; 0x0d
    1248:	9e 85       	ldd	r25, Y+14	; 0x0e
    124a:	28 17       	cp	r18, r24
    124c:	39 07       	cpc	r19, r25
    124e:	c9 f4       	brne	.+50     	; 0x1282 <xEventGroupSync+0x9c>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    1250:	2f 81       	ldd	r18, Y+7	; 0x07
    1252:	38 85       	ldd	r19, Y+8	; 0x08
    1254:	8b 85       	ldd	r24, Y+11	; 0x0b
    1256:	9c 85       	ldd	r25, Y+12	; 0x0c
    1258:	82 2b       	or	r24, r18
    125a:	93 2b       	or	r25, r19
    125c:	9e 83       	std	Y+6, r25	; 0x06
    125e:	8d 83       	std	Y+5, r24	; 0x05

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1260:	eb 81       	ldd	r30, Y+3	; 0x03
    1262:	fc 81       	ldd	r31, Y+4	; 0x04
    1264:	20 81       	ld	r18, Z
    1266:	31 81       	ldd	r19, Z+1	; 0x01
    1268:	8d 85       	ldd	r24, Y+13	; 0x0d
    126a:	9e 85       	ldd	r25, Y+14	; 0x0e
    126c:	80 95       	com	r24
    126e:	90 95       	com	r25
    1270:	82 23       	and	r24, r18
    1272:	93 23       	and	r25, r19
    1274:	eb 81       	ldd	r30, Y+3	; 0x03
    1276:	fc 81       	ldd	r31, Y+4	; 0x04
    1278:	91 83       	std	Z+1, r25	; 0x01
    127a:	80 83       	st	Z, r24

			xTicksToWait = 0;
    127c:	18 8a       	std	Y+16, r1	; 0x10
    127e:	1f 86       	std	Y+15, r1	; 0x0f
    1280:	1e c0       	rjmp	.+60     	; 0x12be <xEventGroupSync+0xd8>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
    1282:	8f 85       	ldd	r24, Y+15	; 0x0f
    1284:	98 89       	ldd	r25, Y+16	; 0x10
    1286:	00 97       	sbiw	r24, 0x00	; 0
    1288:	91 f0       	breq	.+36     	; 0x12ae <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    128a:	8b 81       	ldd	r24, Y+3	; 0x03
    128c:	9c 81       	ldd	r25, Y+4	; 0x04
    128e:	bc 01       	movw	r22, r24
    1290:	6e 5f       	subi	r22, 0xFE	; 254
    1292:	7f 4f       	sbci	r23, 0xFF	; 255
    1294:	8d 85       	ldd	r24, Y+13	; 0x0d
    1296:	9e 85       	ldd	r25, Y+14	; 0x0e
    1298:	9c 01       	movw	r18, r24
    129a:	35 60       	ori	r19, 0x05	; 5
    129c:	4f 85       	ldd	r20, Y+15	; 0x0f
    129e:	58 89       	ldd	r21, Y+16	; 0x10
    12a0:	cb 01       	movw	r24, r22
    12a2:	b9 01       	movw	r22, r18
    12a4:	0e 94 83 25 	call	0x4b06	; 0x4b06 <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
    12a8:	1e 82       	std	Y+6, r1	; 0x06
    12aa:	1d 82       	std	Y+5, r1	; 0x05
    12ac:	08 c0       	rjmp	.+16     	; 0x12be <xEventGroupSync+0xd8>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    12ae:	eb 81       	ldd	r30, Y+3	; 0x03
    12b0:	fc 81       	ldd	r31, Y+4	; 0x04
    12b2:	80 81       	ld	r24, Z
    12b4:	91 81       	ldd	r25, Z+1	; 0x01
    12b6:	9e 83       	std	Y+6, r25	; 0x06
    12b8:	8d 83       	std	Y+5, r24	; 0x05
				xTimeoutOccurred = pdTRUE;
    12ba:	81 e0       	ldi	r24, 0x01	; 1
    12bc:	89 83       	std	Y+1, r24	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    12be:	0e 94 4f 23 	call	0x469e	; 0x469e <xTaskResumeAll>
    12c2:	8a 83       	std	Y+2, r24	; 0x02

	if( xTicksToWait != ( TickType_t ) 0 )
    12c4:	8f 85       	ldd	r24, Y+15	; 0x0f
    12c6:	98 89       	ldd	r25, Y+16	; 0x10
    12c8:	00 97       	sbiw	r24, 0x00	; 0
    12ca:	09 f4       	brne	.+2      	; 0x12ce <xEventGroupSync+0xe8>
    12cc:	3a c0       	rjmp	.+116    	; 0x1342 <xEventGroupSync+0x15c>
	{
		if( xAlreadyYielded == pdFALSE )
    12ce:	8a 81       	ldd	r24, Y+2	; 0x02
    12d0:	88 23       	and	r24, r24
    12d2:	11 f4       	brne	.+4      	; 0x12d8 <xEventGroupSync+0xf2>
		{
			portYIELD_WITHIN_API();
    12d4:	0e 94 8a 0f 	call	0x1f14	; 0x1f14 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    12d8:	0e 94 f8 27 	call	0x4ff0	; 0x4ff0 <uxTaskResetEventItemValue>
    12dc:	9e 83       	std	Y+6, r25	; 0x06
    12de:	8d 83       	std	Y+5, r24	; 0x05

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    12e0:	8d 81       	ldd	r24, Y+5	; 0x05
    12e2:	9e 81       	ldd	r25, Y+6	; 0x06
    12e4:	80 70       	andi	r24, 0x00	; 0
    12e6:	92 70       	andi	r25, 0x02	; 2
    12e8:	00 97       	sbiw	r24, 0x00	; 0
    12ea:	31 f5       	brne	.+76     	; 0x1338 <xEventGroupSync+0x152>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
    12ec:	0f b6       	in	r0, 0x3f	; 63
    12ee:	f8 94       	cli
    12f0:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
    12f2:	eb 81       	ldd	r30, Y+3	; 0x03
    12f4:	fc 81       	ldd	r31, Y+4	; 0x04
    12f6:	80 81       	ld	r24, Z
    12f8:	91 81       	ldd	r25, Z+1	; 0x01
    12fa:	9e 83       	std	Y+6, r25	; 0x06
    12fc:	8d 83       	std	Y+5, r24	; 0x05

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    12fe:	2d 81       	ldd	r18, Y+5	; 0x05
    1300:	3e 81       	ldd	r19, Y+6	; 0x06
    1302:	8d 85       	ldd	r24, Y+13	; 0x0d
    1304:	9e 85       	ldd	r25, Y+14	; 0x0e
    1306:	28 23       	and	r18, r24
    1308:	39 23       	and	r19, r25
    130a:	8d 85       	ldd	r24, Y+13	; 0x0d
    130c:	9e 85       	ldd	r25, Y+14	; 0x0e
    130e:	28 17       	cp	r18, r24
    1310:	39 07       	cpc	r19, r25
    1312:	71 f4       	brne	.+28     	; 0x1330 <xEventGroupSync+0x14a>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1314:	eb 81       	ldd	r30, Y+3	; 0x03
    1316:	fc 81       	ldd	r31, Y+4	; 0x04
    1318:	20 81       	ld	r18, Z
    131a:	31 81       	ldd	r19, Z+1	; 0x01
    131c:	8d 85       	ldd	r24, Y+13	; 0x0d
    131e:	9e 85       	ldd	r25, Y+14	; 0x0e
    1320:	80 95       	com	r24
    1322:	90 95       	com	r25
    1324:	82 23       	and	r24, r18
    1326:	93 23       	and	r25, r19
    1328:	eb 81       	ldd	r30, Y+3	; 0x03
    132a:	fc 81       	ldd	r31, Y+4	; 0x04
    132c:	91 83       	std	Z+1, r25	; 0x01
    132e:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    1330:	0f 90       	pop	r0
    1332:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
    1334:	81 e0       	ldi	r24, 0x01	; 1
    1336:	89 83       	std	Y+1, r24	; 0x01
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    1338:	8d 81       	ldd	r24, Y+5	; 0x05
    133a:	9e 81       	ldd	r25, Y+6	; 0x06
    133c:	90 70       	andi	r25, 0x00	; 0
    133e:	9e 83       	std	Y+6, r25	; 0x06
    1340:	8d 83       	std	Y+5, r24	; 0x05
	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
    1342:	8d 81       	ldd	r24, Y+5	; 0x05
    1344:	9e 81       	ldd	r25, Y+6	; 0x06
}
    1346:	60 96       	adiw	r28, 0x10	; 16
    1348:	0f b6       	in	r0, 0x3f	; 63
    134a:	f8 94       	cli
    134c:	de bf       	out	0x3e, r29	; 62
    134e:	0f be       	out	0x3f, r0	; 63
    1350:	cd bf       	out	0x3d, r28	; 61
    1352:	cf 91       	pop	r28
    1354:	df 91       	pop	r29
    1356:	08 95       	ret

00001358 <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
    1358:	0f 93       	push	r16
    135a:	1f 93       	push	r17
    135c:	df 93       	push	r29
    135e:	cf 93       	push	r28
    1360:	cd b7       	in	r28, 0x3d	; 61
    1362:	de b7       	in	r29, 0x3e	; 62
    1364:	63 97       	sbiw	r28, 0x13	; 19
    1366:	0f b6       	in	r0, 0x3f	; 63
    1368:	f8 94       	cli
    136a:	de bf       	out	0x3e, r29	; 62
    136c:	0f be       	out	0x3f, r0	; 63
    136e:	cd bf       	out	0x3d, r28	; 61
    1370:	9d 87       	std	Y+13, r25	; 0x0d
    1372:	8c 87       	std	Y+12, r24	; 0x0c
    1374:	7f 87       	std	Y+15, r23	; 0x0f
    1376:	6e 87       	std	Y+14, r22	; 0x0e
    1378:	48 8b       	std	Y+16, r20	; 0x10
    137a:	29 8b       	std	Y+17, r18	; 0x11
    137c:	1b 8b       	std	Y+19, r17	; 0x13
    137e:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = xEventGroup;
    1380:	8c 85       	ldd	r24, Y+12	; 0x0c
    1382:	9d 85       	ldd	r25, Y+13	; 0x0d
    1384:	9b 87       	std	Y+11, r25	; 0x0b
    1386:	8a 87       	std	Y+10, r24	; 0x0a
EventBits_t uxReturn, uxControlBits = 0;
    1388:	1f 82       	std	Y+7, r1	; 0x07
    138a:	1e 82       	std	Y+6, r1	; 0x06
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    138c:	1b 82       	std	Y+3, r1	; 0x03
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    138e:	0e 94 43 23 	call	0x4686	; 0x4686 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    1392:	ea 85       	ldd	r30, Y+10	; 0x0a
    1394:	fb 85       	ldd	r31, Y+11	; 0x0b
    1396:	80 81       	ld	r24, Z
    1398:	91 81       	ldd	r25, Z+1	; 0x01
    139a:	9a 83       	std	Y+2, r25	; 0x02
    139c:	89 83       	std	Y+1, r24	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    139e:	89 81       	ldd	r24, Y+1	; 0x01
    13a0:	9a 81       	ldd	r25, Y+2	; 0x02
    13a2:	2e 85       	ldd	r18, Y+14	; 0x0e
    13a4:	3f 85       	ldd	r19, Y+15	; 0x0f
    13a6:	b9 01       	movw	r22, r18
    13a8:	49 89       	ldd	r20, Y+17	; 0x11
    13aa:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <prvTestWaitCondition>
    13ae:	8d 83       	std	Y+5, r24	; 0x05

		if( xWaitConditionMet != pdFALSE )
    13b0:	8d 81       	ldd	r24, Y+5	; 0x05
    13b2:	88 23       	and	r24, r24
    13b4:	c1 f0       	breq	.+48     	; 0x13e6 <xEventGroupWaitBits+0x8e>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
    13b6:	89 81       	ldd	r24, Y+1	; 0x01
    13b8:	9a 81       	ldd	r25, Y+2	; 0x02
    13ba:	99 87       	std	Y+9, r25	; 0x09
    13bc:	88 87       	std	Y+8, r24	; 0x08
			xTicksToWait = ( TickType_t ) 0;
    13be:	1b 8a       	std	Y+19, r1	; 0x13
    13c0:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
    13c2:	88 89       	ldd	r24, Y+16	; 0x10
    13c4:	88 23       	and	r24, r24
    13c6:	e9 f1       	breq	.+122    	; 0x1442 <xEventGroupWaitBits+0xea>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    13c8:	ea 85       	ldd	r30, Y+10	; 0x0a
    13ca:	fb 85       	ldd	r31, Y+11	; 0x0b
    13cc:	20 81       	ld	r18, Z
    13ce:	31 81       	ldd	r19, Z+1	; 0x01
    13d0:	8e 85       	ldd	r24, Y+14	; 0x0e
    13d2:	9f 85       	ldd	r25, Y+15	; 0x0f
    13d4:	80 95       	com	r24
    13d6:	90 95       	com	r25
    13d8:	82 23       	and	r24, r18
    13da:	93 23       	and	r25, r19
    13dc:	ea 85       	ldd	r30, Y+10	; 0x0a
    13de:	fb 85       	ldd	r31, Y+11	; 0x0b
    13e0:	91 83       	std	Z+1, r25	; 0x01
    13e2:	80 83       	st	Z, r24
    13e4:	2e c0       	rjmp	.+92     	; 0x1442 <xEventGroupWaitBits+0xea>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
    13e6:	8a 89       	ldd	r24, Y+18	; 0x12
    13e8:	9b 89       	ldd	r25, Y+19	; 0x13
    13ea:	00 97       	sbiw	r24, 0x00	; 0
    13ec:	39 f4       	brne	.+14     	; 0x13fc <xEventGroupWaitBits+0xa4>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
    13ee:	89 81       	ldd	r24, Y+1	; 0x01
    13f0:	9a 81       	ldd	r25, Y+2	; 0x02
    13f2:	99 87       	std	Y+9, r25	; 0x09
    13f4:	88 87       	std	Y+8, r24	; 0x08
			xTimeoutOccurred = pdTRUE;
    13f6:	81 e0       	ldi	r24, 0x01	; 1
    13f8:	8b 83       	std	Y+3, r24	; 0x03
    13fa:	23 c0       	rjmp	.+70     	; 0x1442 <xEventGroupWaitBits+0xea>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
    13fc:	88 89       	ldd	r24, Y+16	; 0x10
    13fe:	88 23       	and	r24, r24
    1400:	29 f0       	breq	.+10     	; 0x140c <xEventGroupWaitBits+0xb4>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    1402:	8e 81       	ldd	r24, Y+6	; 0x06
    1404:	9f 81       	ldd	r25, Y+7	; 0x07
    1406:	91 60       	ori	r25, 0x01	; 1
    1408:	9f 83       	std	Y+7, r25	; 0x07
    140a:	8e 83       	std	Y+6, r24	; 0x06
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
    140c:	89 89       	ldd	r24, Y+17	; 0x11
    140e:	88 23       	and	r24, r24
    1410:	29 f0       	breq	.+10     	; 0x141c <xEventGroupWaitBits+0xc4>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
    1412:	8e 81       	ldd	r24, Y+6	; 0x06
    1414:	9f 81       	ldd	r25, Y+7	; 0x07
    1416:	94 60       	ori	r25, 0x04	; 4
    1418:	9f 83       	std	Y+7, r25	; 0x07
    141a:	8e 83       	std	Y+6, r24	; 0x06
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    141c:	8a 85       	ldd	r24, Y+10	; 0x0a
    141e:	9b 85       	ldd	r25, Y+11	; 0x0b
    1420:	bc 01       	movw	r22, r24
    1422:	6e 5f       	subi	r22, 0xFE	; 254
    1424:	7f 4f       	sbci	r23, 0xFF	; 255
    1426:	2e 85       	ldd	r18, Y+14	; 0x0e
    1428:	3f 85       	ldd	r19, Y+15	; 0x0f
    142a:	8e 81       	ldd	r24, Y+6	; 0x06
    142c:	9f 81       	ldd	r25, Y+7	; 0x07
    142e:	28 2b       	or	r18, r24
    1430:	39 2b       	or	r19, r25
    1432:	4a 89       	ldd	r20, Y+18	; 0x12
    1434:	5b 89       	ldd	r21, Y+19	; 0x13
    1436:	cb 01       	movw	r24, r22
    1438:	b9 01       	movw	r22, r18
    143a:	0e 94 83 25 	call	0x4b06	; 0x4b06 <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
    143e:	19 86       	std	Y+9, r1	; 0x09
    1440:	18 86       	std	Y+8, r1	; 0x08

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    1442:	0e 94 4f 23 	call	0x469e	; 0x469e <xTaskResumeAll>
    1446:	8c 83       	std	Y+4, r24	; 0x04

	if( xTicksToWait != ( TickType_t ) 0 )
    1448:	8a 89       	ldd	r24, Y+18	; 0x12
    144a:	9b 89       	ldd	r25, Y+19	; 0x13
    144c:	00 97       	sbiw	r24, 0x00	; 0
    144e:	09 f4       	brne	.+2      	; 0x1452 <xEventGroupWaitBits+0xfa>
    1450:	3c c0       	rjmp	.+120    	; 0x14ca <xEventGroupWaitBits+0x172>
	{
		if( xAlreadyYielded == pdFALSE )
    1452:	8c 81       	ldd	r24, Y+4	; 0x04
    1454:	88 23       	and	r24, r24
    1456:	11 f4       	brne	.+4      	; 0x145c <xEventGroupWaitBits+0x104>
		{
			portYIELD_WITHIN_API();
    1458:	0e 94 8a 0f 	call	0x1f14	; 0x1f14 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    145c:	0e 94 f8 27 	call	0x4ff0	; 0x4ff0 <uxTaskResetEventItemValue>
    1460:	99 87       	std	Y+9, r25	; 0x09
    1462:	88 87       	std	Y+8, r24	; 0x08

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    1464:	88 85       	ldd	r24, Y+8	; 0x08
    1466:	99 85       	ldd	r25, Y+9	; 0x09
    1468:	80 70       	andi	r24, 0x00	; 0
    146a:	92 70       	andi	r25, 0x02	; 2
    146c:	00 97       	sbiw	r24, 0x00	; 0
    146e:	41 f5       	brne	.+80     	; 0x14c0 <xEventGroupWaitBits+0x168>
		{
			taskENTER_CRITICAL();
    1470:	0f b6       	in	r0, 0x3f	; 63
    1472:	f8 94       	cli
    1474:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    1476:	ea 85       	ldd	r30, Y+10	; 0x0a
    1478:	fb 85       	ldd	r31, Y+11	; 0x0b
    147a:	80 81       	ld	r24, Z
    147c:	91 81       	ldd	r25, Z+1	; 0x01
    147e:	99 87       	std	Y+9, r25	; 0x09
    1480:	88 87       	std	Y+8, r24	; 0x08

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    1482:	88 85       	ldd	r24, Y+8	; 0x08
    1484:	99 85       	ldd	r25, Y+9	; 0x09
    1486:	2e 85       	ldd	r18, Y+14	; 0x0e
    1488:	3f 85       	ldd	r19, Y+15	; 0x0f
    148a:	b9 01       	movw	r22, r18
    148c:	49 89       	ldd	r20, Y+17	; 0x11
    148e:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <prvTestWaitCondition>
    1492:	88 23       	and	r24, r24
    1494:	89 f0       	breq	.+34     	; 0x14b8 <xEventGroupWaitBits+0x160>
				{
					if( xClearOnExit != pdFALSE )
    1496:	88 89       	ldd	r24, Y+16	; 0x10
    1498:	88 23       	and	r24, r24
    149a:	71 f0       	breq	.+28     	; 0x14b8 <xEventGroupWaitBits+0x160>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    149c:	ea 85       	ldd	r30, Y+10	; 0x0a
    149e:	fb 85       	ldd	r31, Y+11	; 0x0b
    14a0:	20 81       	ld	r18, Z
    14a2:	31 81       	ldd	r19, Z+1	; 0x01
    14a4:	8e 85       	ldd	r24, Y+14	; 0x0e
    14a6:	9f 85       	ldd	r25, Y+15	; 0x0f
    14a8:	80 95       	com	r24
    14aa:	90 95       	com	r25
    14ac:	82 23       	and	r24, r18
    14ae:	93 23       	and	r25, r19
    14b0:	ea 85       	ldd	r30, Y+10	; 0x0a
    14b2:	fb 85       	ldd	r31, Y+11	; 0x0b
    14b4:	91 83       	std	Z+1, r25	; 0x01
    14b6:	80 83       	st	Z, r24
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
    14b8:	81 e0       	ldi	r24, 0x01	; 1
    14ba:	8b 83       	std	Y+3, r24	; 0x03
			}
			taskEXIT_CRITICAL();
    14bc:	0f 90       	pop	r0
    14be:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    14c0:	88 85       	ldd	r24, Y+8	; 0x08
    14c2:	99 85       	ldd	r25, Y+9	; 0x09
    14c4:	90 70       	andi	r25, 0x00	; 0
    14c6:	99 87       	std	Y+9, r25	; 0x09
    14c8:	88 87       	std	Y+8, r24	; 0x08
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
    14ca:	88 85       	ldd	r24, Y+8	; 0x08
    14cc:	99 85       	ldd	r25, Y+9	; 0x09
}
    14ce:	63 96       	adiw	r28, 0x13	; 19
    14d0:	0f b6       	in	r0, 0x3f	; 63
    14d2:	f8 94       	cli
    14d4:	de bf       	out	0x3e, r29	; 62
    14d6:	0f be       	out	0x3f, r0	; 63
    14d8:	cd bf       	out	0x3d, r28	; 61
    14da:	cf 91       	pop	r28
    14dc:	df 91       	pop	r29
    14de:	1f 91       	pop	r17
    14e0:	0f 91       	pop	r16
    14e2:	08 95       	ret

000014e4 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
    14e4:	df 93       	push	r29
    14e6:	cf 93       	push	r28
    14e8:	cd b7       	in	r28, 0x3d	; 61
    14ea:	de b7       	in	r29, 0x3e	; 62
    14ec:	28 97       	sbiw	r28, 0x08	; 8
    14ee:	0f b6       	in	r0, 0x3f	; 63
    14f0:	f8 94       	cli
    14f2:	de bf       	out	0x3e, r29	; 62
    14f4:	0f be       	out	0x3f, r0	; 63
    14f6:	cd bf       	out	0x3d, r28	; 61
    14f8:	9e 83       	std	Y+6, r25	; 0x06
    14fa:	8d 83       	std	Y+5, r24	; 0x05
    14fc:	78 87       	std	Y+8, r23	; 0x08
    14fe:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = xEventGroup;
    1500:	8d 81       	ldd	r24, Y+5	; 0x05
    1502:	9e 81       	ldd	r25, Y+6	; 0x06
    1504:	9c 83       	std	Y+4, r25	; 0x04
    1506:	8b 83       	std	Y+3, r24	; 0x03
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
    1508:	0f b6       	in	r0, 0x3f	; 63
    150a:	f8 94       	cli
    150c:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
    150e:	eb 81       	ldd	r30, Y+3	; 0x03
    1510:	fc 81       	ldd	r31, Y+4	; 0x04
    1512:	80 81       	ld	r24, Z
    1514:	91 81       	ldd	r25, Z+1	; 0x01
    1516:	9a 83       	std	Y+2, r25	; 0x02
    1518:	89 83       	std	Y+1, r24	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    151a:	eb 81       	ldd	r30, Y+3	; 0x03
    151c:	fc 81       	ldd	r31, Y+4	; 0x04
    151e:	20 81       	ld	r18, Z
    1520:	31 81       	ldd	r19, Z+1	; 0x01
    1522:	8f 81       	ldd	r24, Y+7	; 0x07
    1524:	98 85       	ldd	r25, Y+8	; 0x08
    1526:	80 95       	com	r24
    1528:	90 95       	com	r25
    152a:	82 23       	and	r24, r18
    152c:	93 23       	and	r25, r19
    152e:	eb 81       	ldd	r30, Y+3	; 0x03
    1530:	fc 81       	ldd	r31, Y+4	; 0x04
    1532:	91 83       	std	Z+1, r25	; 0x01
    1534:	80 83       	st	Z, r24
	}
	taskEXIT_CRITICAL();
    1536:	0f 90       	pop	r0
    1538:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    153a:	89 81       	ldd	r24, Y+1	; 0x01
    153c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    153e:	28 96       	adiw	r28, 0x08	; 8
    1540:	0f b6       	in	r0, 0x3f	; 63
    1542:	f8 94       	cli
    1544:	de bf       	out	0x3e, r29	; 62
    1546:	0f be       	out	0x3f, r0	; 63
    1548:	cd bf       	out	0x3d, r28	; 61
    154a:	cf 91       	pop	r28
    154c:	df 91       	pop	r29
    154e:	08 95       	ret

00001550 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    1550:	df 93       	push	r29
    1552:	cf 93       	push	r28
    1554:	cd b7       	in	r28, 0x3d	; 61
    1556:	de b7       	in	r29, 0x3e	; 62
    1558:	27 97       	sbiw	r28, 0x07	; 7
    155a:	0f b6       	in	r0, 0x3f	; 63
    155c:	f8 94       	cli
    155e:	de bf       	out	0x3e, r29	; 62
    1560:	0f be       	out	0x3f, r0	; 63
    1562:	cd bf       	out	0x3d, r28	; 61
    1564:	9f 83       	std	Y+7, r25	; 0x07
    1566:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t const * const pxEventBits = xEventGroup;
    1568:	8e 81       	ldd	r24, Y+6	; 0x06
    156a:	9f 81       	ldd	r25, Y+7	; 0x07
    156c:	9c 83       	std	Y+4, r25	; 0x04
    156e:	8b 83       	std	Y+3, r24	; 0x03
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1570:	1d 82       	std	Y+5, r1	; 0x05
	{
		uxReturn = pxEventBits->uxEventBits;
    1572:	eb 81       	ldd	r30, Y+3	; 0x03
    1574:	fc 81       	ldd	r31, Y+4	; 0x04
    1576:	80 81       	ld	r24, Z
    1578:	91 81       	ldd	r25, Z+1	; 0x01
    157a:	9a 83       	std	Y+2, r25	; 0x02
    157c:	89 83       	std	Y+1, r24	; 0x01
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
    157e:	89 81       	ldd	r24, Y+1	; 0x01
    1580:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    1582:	27 96       	adiw	r28, 0x07	; 7
    1584:	0f b6       	in	r0, 0x3f	; 63
    1586:	f8 94       	cli
    1588:	de bf       	out	0x3e, r29	; 62
    158a:	0f be       	out	0x3f, r0	; 63
    158c:	cd bf       	out	0x3d, r28	; 61
    158e:	cf 91       	pop	r28
    1590:	df 91       	pop	r29
    1592:	08 95       	ret

00001594 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
    1594:	df 93       	push	r29
    1596:	cf 93       	push	r28
    1598:	cd b7       	in	r28, 0x3d	; 61
    159a:	de b7       	in	r29, 0x3e	; 62
    159c:	65 97       	sbiw	r28, 0x15	; 21
    159e:	0f b6       	in	r0, 0x3f	; 63
    15a0:	f8 94       	cli
    15a2:	de bf       	out	0x3e, r29	; 62
    15a4:	0f be       	out	0x3f, r0	; 63
    15a6:	cd bf       	out	0x3d, r28	; 61
    15a8:	9b 8b       	std	Y+19, r25	; 0x13
    15aa:	8a 8b       	std	Y+18, r24	; 0x12
    15ac:	7d 8b       	std	Y+21, r23	; 0x15
    15ae:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    15b0:	19 86       	std	Y+9, r1	; 0x09
    15b2:	18 86       	std	Y+8, r1	; 0x08
EventGroup_t *pxEventBits = xEventGroup;
    15b4:	8a 89       	ldd	r24, Y+18	; 0x12
    15b6:	9b 89       	ldd	r25, Y+19	; 0x13
    15b8:	9b 83       	std	Y+3, r25	; 0x03
    15ba:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xMatchFound = pdFALSE;
    15bc:	19 82       	std	Y+1, r1	; 0x01
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
    15be:	8a 81       	ldd	r24, Y+2	; 0x02
    15c0:	9b 81       	ldd	r25, Y+3	; 0x03
    15c2:	02 96       	adiw	r24, 0x02	; 2
    15c4:	9b 87       	std	Y+11, r25	; 0x0b
    15c6:	8a 87       	std	Y+10, r24	; 0x0a
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    15c8:	8a 85       	ldd	r24, Y+10	; 0x0a
    15ca:	9b 85       	ldd	r25, Y+11	; 0x0b
    15cc:	03 96       	adiw	r24, 0x03	; 3
    15ce:	9d 87       	std	Y+13, r25	; 0x0d
    15d0:	8c 87       	std	Y+12, r24	; 0x0c
	vTaskSuspendAll();
    15d2:	0e 94 43 23 	call	0x4686	; 0x4686 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
    15d6:	ea 85       	ldd	r30, Y+10	; 0x0a
    15d8:	fb 85       	ldd	r31, Y+11	; 0x0b
    15da:	85 81       	ldd	r24, Z+5	; 0x05
    15dc:	96 81       	ldd	r25, Z+6	; 0x06
    15de:	99 8b       	std	Y+17, r25	; 0x11
    15e0:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
    15e2:	ea 81       	ldd	r30, Y+2	; 0x02
    15e4:	fb 81       	ldd	r31, Y+3	; 0x03
    15e6:	20 81       	ld	r18, Z
    15e8:	31 81       	ldd	r19, Z+1	; 0x01
    15ea:	8c 89       	ldd	r24, Y+20	; 0x14
    15ec:	9d 89       	ldd	r25, Y+21	; 0x15
    15ee:	82 2b       	or	r24, r18
    15f0:	93 2b       	or	r25, r19
    15f2:	ea 81       	ldd	r30, Y+2	; 0x02
    15f4:	fb 81       	ldd	r31, Y+3	; 0x03
    15f6:	91 83       	std	Z+1, r25	; 0x01
    15f8:	80 83       	st	Z, r24
    15fa:	59 c0       	rjmp	.+178    	; 0x16ae <xEventGroupSetBits+0x11a>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
    15fc:	e8 89       	ldd	r30, Y+16	; 0x10
    15fe:	f9 89       	ldd	r31, Y+17	; 0x11
    1600:	82 81       	ldd	r24, Z+2	; 0x02
    1602:	93 81       	ldd	r25, Z+3	; 0x03
    1604:	9f 87       	std	Y+15, r25	; 0x0f
    1606:	8e 87       	std	Y+14, r24	; 0x0e
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    1608:	e8 89       	ldd	r30, Y+16	; 0x10
    160a:	f9 89       	ldd	r31, Y+17	; 0x11
    160c:	80 81       	ld	r24, Z
    160e:	91 81       	ldd	r25, Z+1	; 0x01
    1610:	9f 83       	std	Y+7, r25	; 0x07
    1612:	8e 83       	std	Y+6, r24	; 0x06
			xMatchFound = pdFALSE;
    1614:	19 82       	std	Y+1, r1	; 0x01

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    1616:	8e 81       	ldd	r24, Y+6	; 0x06
    1618:	9f 81       	ldd	r25, Y+7	; 0x07
    161a:	80 70       	andi	r24, 0x00	; 0
    161c:	9d 83       	std	Y+5, r25	; 0x05
    161e:	8c 83       	std	Y+4, r24	; 0x04
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    1620:	8e 81       	ldd	r24, Y+6	; 0x06
    1622:	9f 81       	ldd	r25, Y+7	; 0x07
    1624:	90 70       	andi	r25, 0x00	; 0
    1626:	9f 83       	std	Y+7, r25	; 0x07
    1628:	8e 83       	std	Y+6, r24	; 0x06

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    162a:	8c 81       	ldd	r24, Y+4	; 0x04
    162c:	9d 81       	ldd	r25, Y+5	; 0x05
    162e:	80 70       	andi	r24, 0x00	; 0
    1630:	94 70       	andi	r25, 0x04	; 4
    1632:	00 97       	sbiw	r24, 0x00	; 0
    1634:	69 f4       	brne	.+26     	; 0x1650 <xEventGroupSetBits+0xbc>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    1636:	ea 81       	ldd	r30, Y+2	; 0x02
    1638:	fb 81       	ldd	r31, Y+3	; 0x03
    163a:	20 81       	ld	r18, Z
    163c:	31 81       	ldd	r19, Z+1	; 0x01
    163e:	8e 81       	ldd	r24, Y+6	; 0x06
    1640:	9f 81       	ldd	r25, Y+7	; 0x07
    1642:	82 23       	and	r24, r18
    1644:	93 23       	and	r25, r19
    1646:	00 97       	sbiw	r24, 0x00	; 0
    1648:	91 f0       	breq	.+36     	; 0x166e <xEventGroupSetBits+0xda>
				{
					xMatchFound = pdTRUE;
    164a:	81 e0       	ldi	r24, 0x01	; 1
    164c:	89 83       	std	Y+1, r24	; 0x01
    164e:	0f c0       	rjmp	.+30     	; 0x166e <xEventGroupSetBits+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    1650:	ea 81       	ldd	r30, Y+2	; 0x02
    1652:	fb 81       	ldd	r31, Y+3	; 0x03
    1654:	20 81       	ld	r18, Z
    1656:	31 81       	ldd	r19, Z+1	; 0x01
    1658:	8e 81       	ldd	r24, Y+6	; 0x06
    165a:	9f 81       	ldd	r25, Y+7	; 0x07
    165c:	28 23       	and	r18, r24
    165e:	39 23       	and	r19, r25
    1660:	8e 81       	ldd	r24, Y+6	; 0x06
    1662:	9f 81       	ldd	r25, Y+7	; 0x07
    1664:	28 17       	cp	r18, r24
    1666:	39 07       	cpc	r19, r25
    1668:	11 f4       	brne	.+4      	; 0x166e <xEventGroupSetBits+0xda>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
    166a:	81 e0       	ldi	r24, 0x01	; 1
    166c:	89 83       	std	Y+1, r24	; 0x01
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
    166e:	89 81       	ldd	r24, Y+1	; 0x01
    1670:	88 23       	and	r24, r24
    1672:	c9 f0       	breq	.+50     	; 0x16a6 <xEventGroupSetBits+0x112>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    1674:	8c 81       	ldd	r24, Y+4	; 0x04
    1676:	9d 81       	ldd	r25, Y+5	; 0x05
    1678:	80 70       	andi	r24, 0x00	; 0
    167a:	91 70       	andi	r25, 0x01	; 1
    167c:	00 97       	sbiw	r24, 0x00	; 0
    167e:	41 f0       	breq	.+16     	; 0x1690 <xEventGroupSetBits+0xfc>
				{
					uxBitsToClear |= uxBitsWaitedFor;
    1680:	88 85       	ldd	r24, Y+8	; 0x08
    1682:	99 85       	ldd	r25, Y+9	; 0x09
    1684:	2e 81       	ldd	r18, Y+6	; 0x06
    1686:	3f 81       	ldd	r19, Y+7	; 0x07
    1688:	82 2b       	or	r24, r18
    168a:	93 2b       	or	r25, r19
    168c:	99 87       	std	Y+9, r25	; 0x09
    168e:	88 87       	std	Y+8, r24	; 0x08
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    1690:	ea 81       	ldd	r30, Y+2	; 0x02
    1692:	fb 81       	ldd	r31, Y+3	; 0x03
    1694:	80 81       	ld	r24, Z
    1696:	91 81       	ldd	r25, Z+1	; 0x01
    1698:	9c 01       	movw	r18, r24
    169a:	32 60       	ori	r19, 0x02	; 2
    169c:	88 89       	ldd	r24, Y+16	; 0x10
    169e:	99 89       	ldd	r25, Y+17	; 0x11
    16a0:	b9 01       	movw	r22, r18
    16a2:	0e 94 1e 26 	call	0x4c3c	; 0x4c3c <vTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
    16a6:	8e 85       	ldd	r24, Y+14	; 0x0e
    16a8:	9f 85       	ldd	r25, Y+15	; 0x0f
    16aa:	99 8b       	std	Y+17, r25	; 0x11
    16ac:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    16ae:	28 89       	ldd	r18, Y+16	; 0x10
    16b0:	39 89       	ldd	r19, Y+17	; 0x11
    16b2:	8c 85       	ldd	r24, Y+12	; 0x0c
    16b4:	9d 85       	ldd	r25, Y+13	; 0x0d
    16b6:	28 17       	cp	r18, r24
    16b8:	39 07       	cpc	r19, r25
    16ba:	09 f0       	breq	.+2      	; 0x16be <xEventGroupSetBits+0x12a>
    16bc:	9f cf       	rjmp	.-194    	; 0x15fc <xEventGroupSetBits+0x68>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    16be:	ea 81       	ldd	r30, Y+2	; 0x02
    16c0:	fb 81       	ldd	r31, Y+3	; 0x03
    16c2:	20 81       	ld	r18, Z
    16c4:	31 81       	ldd	r19, Z+1	; 0x01
    16c6:	88 85       	ldd	r24, Y+8	; 0x08
    16c8:	99 85       	ldd	r25, Y+9	; 0x09
    16ca:	80 95       	com	r24
    16cc:	90 95       	com	r25
    16ce:	82 23       	and	r24, r18
    16d0:	93 23       	and	r25, r19
    16d2:	ea 81       	ldd	r30, Y+2	; 0x02
    16d4:	fb 81       	ldd	r31, Y+3	; 0x03
    16d6:	91 83       	std	Z+1, r25	; 0x01
    16d8:	80 83       	st	Z, r24
	}
	( void ) xTaskResumeAll();
    16da:	0e 94 4f 23 	call	0x469e	; 0x469e <xTaskResumeAll>

	return pxEventBits->uxEventBits;
    16de:	ea 81       	ldd	r30, Y+2	; 0x02
    16e0:	fb 81       	ldd	r31, Y+3	; 0x03
    16e2:	80 81       	ld	r24, Z
    16e4:	91 81       	ldd	r25, Z+1	; 0x01
}
    16e6:	65 96       	adiw	r28, 0x15	; 21
    16e8:	0f b6       	in	r0, 0x3f	; 63
    16ea:	f8 94       	cli
    16ec:	de bf       	out	0x3e, r29	; 62
    16ee:	0f be       	out	0x3f, r0	; 63
    16f0:	cd bf       	out	0x3d, r28	; 61
    16f2:	cf 91       	pop	r28
    16f4:	df 91       	pop	r29
    16f6:	08 95       	ret

000016f8 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    16f8:	df 93       	push	r29
    16fa:	cf 93       	push	r28
    16fc:	00 d0       	rcall	.+0      	; 0x16fe <vEventGroupDelete+0x6>
    16fe:	00 d0       	rcall	.+0      	; 0x1700 <vEventGroupDelete+0x8>
    1700:	00 d0       	rcall	.+0      	; 0x1702 <vEventGroupDelete+0xa>
    1702:	cd b7       	in	r28, 0x3d	; 61
    1704:	de b7       	in	r29, 0x3e	; 62
    1706:	9e 83       	std	Y+6, r25	; 0x06
    1708:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = xEventGroup;
    170a:	8d 81       	ldd	r24, Y+5	; 0x05
    170c:	9e 81       	ldd	r25, Y+6	; 0x06
    170e:	9c 83       	std	Y+4, r25	; 0x04
    1710:	8b 83       	std	Y+3, r24	; 0x03
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    1712:	8b 81       	ldd	r24, Y+3	; 0x03
    1714:	9c 81       	ldd	r25, Y+4	; 0x04
    1716:	02 96       	adiw	r24, 0x02	; 2
    1718:	9a 83       	std	Y+2, r25	; 0x02
    171a:	89 83       	std	Y+1, r24	; 0x01

	vTaskSuspendAll();
    171c:	0e 94 43 23 	call	0x4686	; 0x4686 <vTaskSuspendAll>
    1720:	08 c0       	rjmp	.+16     	; 0x1732 <vEventGroupDelete+0x3a>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    1722:	e9 81       	ldd	r30, Y+1	; 0x01
    1724:	fa 81       	ldd	r31, Y+2	; 0x02
    1726:	85 81       	ldd	r24, Z+5	; 0x05
    1728:	96 81       	ldd	r25, Z+6	; 0x06
    172a:	60 e0       	ldi	r22, 0x00	; 0
    172c:	72 e0       	ldi	r23, 0x02	; 2
    172e:	0e 94 1e 26 	call	0x4c3c	; 0x4c3c <vTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    1732:	e9 81       	ldd	r30, Y+1	; 0x01
    1734:	fa 81       	ldd	r31, Y+2	; 0x02
    1736:	80 81       	ld	r24, Z
    1738:	88 23       	and	r24, r24
    173a:	99 f7       	brne	.-26     	; 0x1722 <vEventGroupDelete+0x2a>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
    173c:	8b 81       	ldd	r24, Y+3	; 0x03
    173e:	9c 81       	ldd	r25, Y+4	; 0x04
    1740:	0e 94 6f 0c 	call	0x18de	; 0x18de <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
    1744:	0e 94 4f 23 	call	0x469e	; 0x469e <xTaskResumeAll>
}
    1748:	26 96       	adiw	r28, 0x06	; 6
    174a:	0f b6       	in	r0, 0x3f	; 63
    174c:	f8 94       	cli
    174e:	de bf       	out	0x3e, r29	; 62
    1750:	0f be       	out	0x3f, r0	; 63
    1752:	cd bf       	out	0x3d, r28	; 61
    1754:	cf 91       	pop	r28
    1756:	df 91       	pop	r29
    1758:	08 95       	ret

0000175a <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
    175a:	df 93       	push	r29
    175c:	cf 93       	push	r28
    175e:	00 d0       	rcall	.+0      	; 0x1760 <vEventGroupSetBitsCallback+0x6>
    1760:	00 d0       	rcall	.+0      	; 0x1762 <vEventGroupSetBitsCallback+0x8>
    1762:	00 d0       	rcall	.+0      	; 0x1764 <vEventGroupSetBitsCallback+0xa>
    1764:	cd b7       	in	r28, 0x3d	; 61
    1766:	de b7       	in	r29, 0x3e	; 62
    1768:	9a 83       	std	Y+2, r25	; 0x02
    176a:	89 83       	std	Y+1, r24	; 0x01
    176c:	4b 83       	std	Y+3, r20	; 0x03
    176e:	5c 83       	std	Y+4, r21	; 0x04
    1770:	6d 83       	std	Y+5, r22	; 0x05
    1772:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    1774:	89 81       	ldd	r24, Y+1	; 0x01
    1776:	9a 81       	ldd	r25, Y+2	; 0x02
    1778:	2b 81       	ldd	r18, Y+3	; 0x03
    177a:	3c 81       	ldd	r19, Y+4	; 0x04
    177c:	b9 01       	movw	r22, r18
    177e:	0e 94 ca 0a 	call	0x1594	; 0x1594 <xEventGroupSetBits>
}
    1782:	26 96       	adiw	r28, 0x06	; 6
    1784:	0f b6       	in	r0, 0x3f	; 63
    1786:	f8 94       	cli
    1788:	de bf       	out	0x3e, r29	; 62
    178a:	0f be       	out	0x3f, r0	; 63
    178c:	cd bf       	out	0x3d, r28	; 61
    178e:	cf 91       	pop	r28
    1790:	df 91       	pop	r29
    1792:	08 95       	ret

00001794 <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
    1794:	df 93       	push	r29
    1796:	cf 93       	push	r28
    1798:	00 d0       	rcall	.+0      	; 0x179a <vEventGroupClearBitsCallback+0x6>
    179a:	00 d0       	rcall	.+0      	; 0x179c <vEventGroupClearBitsCallback+0x8>
    179c:	00 d0       	rcall	.+0      	; 0x179e <vEventGroupClearBitsCallback+0xa>
    179e:	cd b7       	in	r28, 0x3d	; 61
    17a0:	de b7       	in	r29, 0x3e	; 62
    17a2:	9a 83       	std	Y+2, r25	; 0x02
    17a4:	89 83       	std	Y+1, r24	; 0x01
    17a6:	4b 83       	std	Y+3, r20	; 0x03
    17a8:	5c 83       	std	Y+4, r21	; 0x04
    17aa:	6d 83       	std	Y+5, r22	; 0x05
    17ac:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    17ae:	89 81       	ldd	r24, Y+1	; 0x01
    17b0:	9a 81       	ldd	r25, Y+2	; 0x02
    17b2:	2b 81       	ldd	r18, Y+3	; 0x03
    17b4:	3c 81       	ldd	r19, Y+4	; 0x04
    17b6:	b9 01       	movw	r22, r18
    17b8:	0e 94 72 0a 	call	0x14e4	; 0x14e4 <xEventGroupClearBits>
}
    17bc:	26 96       	adiw	r28, 0x06	; 6
    17be:	0f b6       	in	r0, 0x3f	; 63
    17c0:	f8 94       	cli
    17c2:	de bf       	out	0x3e, r29	; 62
    17c4:	0f be       	out	0x3f, r0	; 63
    17c6:	cd bf       	out	0x3d, r28	; 61
    17c8:	cf 91       	pop	r28
    17ca:	df 91       	pop	r29
    17cc:	08 95       	ret

000017ce <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
    17ce:	df 93       	push	r29
    17d0:	cf 93       	push	r28
    17d2:	00 d0       	rcall	.+0      	; 0x17d4 <prvTestWaitCondition+0x6>
    17d4:	00 d0       	rcall	.+0      	; 0x17d6 <prvTestWaitCondition+0x8>
    17d6:	00 d0       	rcall	.+0      	; 0x17d8 <prvTestWaitCondition+0xa>
    17d8:	cd b7       	in	r28, 0x3d	; 61
    17da:	de b7       	in	r29, 0x3e	; 62
    17dc:	9b 83       	std	Y+3, r25	; 0x03
    17de:	8a 83       	std	Y+2, r24	; 0x02
    17e0:	7d 83       	std	Y+5, r23	; 0x05
    17e2:	6c 83       	std	Y+4, r22	; 0x04
    17e4:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
    17e6:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
    17e8:	8e 81       	ldd	r24, Y+6	; 0x06
    17ea:	88 23       	and	r24, r24
    17ec:	59 f4       	brne	.+22     	; 0x1804 <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    17ee:	8a 81       	ldd	r24, Y+2	; 0x02
    17f0:	9b 81       	ldd	r25, Y+3	; 0x03
    17f2:	2c 81       	ldd	r18, Y+4	; 0x04
    17f4:	3d 81       	ldd	r19, Y+5	; 0x05
    17f6:	82 23       	and	r24, r18
    17f8:	93 23       	and	r25, r19
    17fa:	00 97       	sbiw	r24, 0x00	; 0
    17fc:	81 f0       	breq	.+32     	; 0x181e <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    17fe:	81 e0       	ldi	r24, 0x01	; 1
    1800:	89 83       	std	Y+1, r24	; 0x01
    1802:	0d c0       	rjmp	.+26     	; 0x181e <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1804:	2a 81       	ldd	r18, Y+2	; 0x02
    1806:	3b 81       	ldd	r19, Y+3	; 0x03
    1808:	8c 81       	ldd	r24, Y+4	; 0x04
    180a:	9d 81       	ldd	r25, Y+5	; 0x05
    180c:	28 23       	and	r18, r24
    180e:	39 23       	and	r19, r25
    1810:	8c 81       	ldd	r24, Y+4	; 0x04
    1812:	9d 81       	ldd	r25, Y+5	; 0x05
    1814:	28 17       	cp	r18, r24
    1816:	39 07       	cpc	r19, r25
    1818:	11 f4       	brne	.+4      	; 0x181e <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    181a:	81 e0       	ldi	r24, 0x01	; 1
    181c:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
    181e:	89 81       	ldd	r24, Y+1	; 0x01
}
    1820:	26 96       	adiw	r28, 0x06	; 6
    1822:	0f b6       	in	r0, 0x3f	; 63
    1824:	f8 94       	cli
    1826:	de bf       	out	0x3e, r29	; 62
    1828:	0f be       	out	0x3f, r0	; 63
    182a:	cd bf       	out	0x3d, r28	; 61
    182c:	cf 91       	pop	r28
    182e:	df 91       	pop	r29
    1830:	08 95       	ret

00001832 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1832:	df 93       	push	r29
    1834:	cf 93       	push	r28
    1836:	00 d0       	rcall	.+0      	; 0x1838 <pvPortMalloc+0x6>
    1838:	00 d0       	rcall	.+0      	; 0x183a <pvPortMalloc+0x8>
    183a:	cd b7       	in	r28, 0x3d	; 61
    183c:	de b7       	in	r29, 0x3e	; 62
    183e:	9c 83       	std	Y+4, r25	; 0x04
    1840:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    1842:	1a 82       	std	Y+2, r1	; 0x02
    1844:	19 82       	std	Y+1, r1	; 0x01
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    1846:	0e 94 43 23 	call	0x4686	; 0x4686 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    184a:	80 91 c2 00 	lds	r24, 0x00C2
    184e:	90 91 c3 00 	lds	r25, 0x00C3
    1852:	00 97       	sbiw	r24, 0x00	; 0
    1854:	31 f4       	brne	.+12     	; 0x1862 <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    1856:	85 ec       	ldi	r24, 0xC5	; 197
    1858:	90 e0       	ldi	r25, 0x00	; 0
    185a:	90 93 c3 00 	sts	0x00C3, r25
    185e:	80 93 c2 00 	sts	0x00C2, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    1862:	80 91 c0 00 	lds	r24, 0x00C0
    1866:	90 91 c1 00 	lds	r25, 0x00C1
    186a:	2b 81       	ldd	r18, Y+3	; 0x03
    186c:	3c 81       	ldd	r19, Y+4	; 0x04
    186e:	82 0f       	add	r24, r18
    1870:	93 1f       	adc	r25, r19
    1872:	25 e0       	ldi	r18, 0x05	; 5
    1874:	8b 3d       	cpi	r24, 0xDB	; 219
    1876:	92 07       	cpc	r25, r18
    1878:	38 f5       	brcc	.+78     	; 0x18c8 <pvPortMalloc+0x96>
    187a:	20 91 c0 00 	lds	r18, 0x00C0
    187e:	30 91 c1 00 	lds	r19, 0x00C1
    1882:	8b 81       	ldd	r24, Y+3	; 0x03
    1884:	9c 81       	ldd	r25, Y+4	; 0x04
    1886:	28 0f       	add	r18, r24
    1888:	39 1f       	adc	r19, r25
    188a:	80 91 c0 00 	lds	r24, 0x00C0
    188e:	90 91 c1 00 	lds	r25, 0x00C1
    1892:	82 17       	cp	r24, r18
    1894:	93 07       	cpc	r25, r19
    1896:	c0 f4       	brcc	.+48     	; 0x18c8 <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    1898:	20 91 c2 00 	lds	r18, 0x00C2
    189c:	30 91 c3 00 	lds	r19, 0x00C3
    18a0:	80 91 c0 00 	lds	r24, 0x00C0
    18a4:	90 91 c1 00 	lds	r25, 0x00C1
    18a8:	82 0f       	add	r24, r18
    18aa:	93 1f       	adc	r25, r19
    18ac:	9a 83       	std	Y+2, r25	; 0x02
    18ae:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    18b0:	20 91 c0 00 	lds	r18, 0x00C0
    18b4:	30 91 c1 00 	lds	r19, 0x00C1
    18b8:	8b 81       	ldd	r24, Y+3	; 0x03
    18ba:	9c 81       	ldd	r25, Y+4	; 0x04
    18bc:	82 0f       	add	r24, r18
    18be:	93 1f       	adc	r25, r19
    18c0:	90 93 c1 00 	sts	0x00C1, r25
    18c4:	80 93 c0 00 	sts	0x00C0, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    18c8:	0e 94 4f 23 	call	0x469e	; 0x469e <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    18cc:	89 81       	ldd	r24, Y+1	; 0x01
    18ce:	9a 81       	ldd	r25, Y+2	; 0x02
}
    18d0:	0f 90       	pop	r0
    18d2:	0f 90       	pop	r0
    18d4:	0f 90       	pop	r0
    18d6:	0f 90       	pop	r0
    18d8:	cf 91       	pop	r28
    18da:	df 91       	pop	r29
    18dc:	08 95       	ret

000018de <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    18de:	df 93       	push	r29
    18e0:	cf 93       	push	r28
    18e2:	00 d0       	rcall	.+0      	; 0x18e4 <vPortFree+0x6>
    18e4:	cd b7       	in	r28, 0x3d	; 61
    18e6:	de b7       	in	r29, 0x3e	; 62
    18e8:	9a 83       	std	Y+2, r25	; 0x02
    18ea:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    18ec:	0f 90       	pop	r0
    18ee:	0f 90       	pop	r0
    18f0:	cf 91       	pop	r28
    18f2:	df 91       	pop	r29
    18f4:	08 95       	ret

000018f6 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    18f6:	df 93       	push	r29
    18f8:	cf 93       	push	r28
    18fa:	cd b7       	in	r28, 0x3d	; 61
    18fc:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    18fe:	10 92 c1 00 	sts	0x00C1, r1
    1902:	10 92 c0 00 	sts	0x00C0, r1
}
    1906:	cf 91       	pop	r28
    1908:	df 91       	pop	r29
    190a:	08 95       	ret

0000190c <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    190c:	df 93       	push	r29
    190e:	cf 93       	push	r28
    1910:	cd b7       	in	r28, 0x3d	; 61
    1912:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    1914:	20 91 c0 00 	lds	r18, 0x00C0
    1918:	30 91 c1 00 	lds	r19, 0x00C1
    191c:	8b ed       	ldi	r24, 0xDB	; 219
    191e:	95 e0       	ldi	r25, 0x05	; 5
    1920:	82 1b       	sub	r24, r18
    1922:	93 0b       	sbc	r25, r19
}
    1924:	cf 91       	pop	r28
    1926:	df 91       	pop	r29
    1928:	08 95       	ret

0000192a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    192a:	df 93       	push	r29
    192c:	cf 93       	push	r28
    192e:	00 d0       	rcall	.+0      	; 0x1930 <vListInitialise+0x6>
    1930:	cd b7       	in	r28, 0x3d	; 61
    1932:	de b7       	in	r29, 0x3e	; 62
    1934:	9a 83       	std	Y+2, r25	; 0x02
    1936:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1938:	89 81       	ldd	r24, Y+1	; 0x01
    193a:	9a 81       	ldd	r25, Y+2	; 0x02
    193c:	03 96       	adiw	r24, 0x03	; 3
    193e:	e9 81       	ldd	r30, Y+1	; 0x01
    1940:	fa 81       	ldd	r31, Y+2	; 0x02
    1942:	92 83       	std	Z+2, r25	; 0x02
    1944:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1946:	e9 81       	ldd	r30, Y+1	; 0x01
    1948:	fa 81       	ldd	r31, Y+2	; 0x02
    194a:	8f ef       	ldi	r24, 0xFF	; 255
    194c:	9f ef       	ldi	r25, 0xFF	; 255
    194e:	94 83       	std	Z+4, r25	; 0x04
    1950:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1952:	89 81       	ldd	r24, Y+1	; 0x01
    1954:	9a 81       	ldd	r25, Y+2	; 0x02
    1956:	03 96       	adiw	r24, 0x03	; 3
    1958:	e9 81       	ldd	r30, Y+1	; 0x01
    195a:	fa 81       	ldd	r31, Y+2	; 0x02
    195c:	96 83       	std	Z+6, r25	; 0x06
    195e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1960:	89 81       	ldd	r24, Y+1	; 0x01
    1962:	9a 81       	ldd	r25, Y+2	; 0x02
    1964:	03 96       	adiw	r24, 0x03	; 3
    1966:	e9 81       	ldd	r30, Y+1	; 0x01
    1968:	fa 81       	ldd	r31, Y+2	; 0x02
    196a:	90 87       	std	Z+8, r25	; 0x08
    196c:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    196e:	e9 81       	ldd	r30, Y+1	; 0x01
    1970:	fa 81       	ldd	r31, Y+2	; 0x02
    1972:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    1974:	0f 90       	pop	r0
    1976:	0f 90       	pop	r0
    1978:	cf 91       	pop	r28
    197a:	df 91       	pop	r29
    197c:	08 95       	ret

0000197e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    197e:	df 93       	push	r29
    1980:	cf 93       	push	r28
    1982:	00 d0       	rcall	.+0      	; 0x1984 <vListInitialiseItem+0x6>
    1984:	cd b7       	in	r28, 0x3d	; 61
    1986:	de b7       	in	r29, 0x3e	; 62
    1988:	9a 83       	std	Y+2, r25	; 0x02
    198a:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    198c:	e9 81       	ldd	r30, Y+1	; 0x01
    198e:	fa 81       	ldd	r31, Y+2	; 0x02
    1990:	11 86       	std	Z+9, r1	; 0x09
    1992:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    1994:	0f 90       	pop	r0
    1996:	0f 90       	pop	r0
    1998:	cf 91       	pop	r28
    199a:	df 91       	pop	r29
    199c:	08 95       	ret

0000199e <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    199e:	df 93       	push	r29
    19a0:	cf 93       	push	r28
    19a2:	00 d0       	rcall	.+0      	; 0x19a4 <vListInsertEnd+0x6>
    19a4:	00 d0       	rcall	.+0      	; 0x19a6 <vListInsertEnd+0x8>
    19a6:	00 d0       	rcall	.+0      	; 0x19a8 <vListInsertEnd+0xa>
    19a8:	cd b7       	in	r28, 0x3d	; 61
    19aa:	de b7       	in	r29, 0x3e	; 62
    19ac:	9c 83       	std	Y+4, r25	; 0x04
    19ae:	8b 83       	std	Y+3, r24	; 0x03
    19b0:	7e 83       	std	Y+6, r23	; 0x06
    19b2:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    19b4:	eb 81       	ldd	r30, Y+3	; 0x03
    19b6:	fc 81       	ldd	r31, Y+4	; 0x04
    19b8:	81 81       	ldd	r24, Z+1	; 0x01
    19ba:	92 81       	ldd	r25, Z+2	; 0x02
    19bc:	9a 83       	std	Y+2, r25	; 0x02
    19be:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    19c0:	ed 81       	ldd	r30, Y+5	; 0x05
    19c2:	fe 81       	ldd	r31, Y+6	; 0x06
    19c4:	89 81       	ldd	r24, Y+1	; 0x01
    19c6:	9a 81       	ldd	r25, Y+2	; 0x02
    19c8:	93 83       	std	Z+3, r25	; 0x03
    19ca:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    19cc:	e9 81       	ldd	r30, Y+1	; 0x01
    19ce:	fa 81       	ldd	r31, Y+2	; 0x02
    19d0:	84 81       	ldd	r24, Z+4	; 0x04
    19d2:	95 81       	ldd	r25, Z+5	; 0x05
    19d4:	ed 81       	ldd	r30, Y+5	; 0x05
    19d6:	fe 81       	ldd	r31, Y+6	; 0x06
    19d8:	95 83       	std	Z+5, r25	; 0x05
    19da:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    19dc:	e9 81       	ldd	r30, Y+1	; 0x01
    19de:	fa 81       	ldd	r31, Y+2	; 0x02
    19e0:	04 80       	ldd	r0, Z+4	; 0x04
    19e2:	f5 81       	ldd	r31, Z+5	; 0x05
    19e4:	e0 2d       	mov	r30, r0
    19e6:	8d 81       	ldd	r24, Y+5	; 0x05
    19e8:	9e 81       	ldd	r25, Y+6	; 0x06
    19ea:	93 83       	std	Z+3, r25	; 0x03
    19ec:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    19ee:	e9 81       	ldd	r30, Y+1	; 0x01
    19f0:	fa 81       	ldd	r31, Y+2	; 0x02
    19f2:	8d 81       	ldd	r24, Y+5	; 0x05
    19f4:	9e 81       	ldd	r25, Y+6	; 0x06
    19f6:	95 83       	std	Z+5, r25	; 0x05
    19f8:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    19fa:	ed 81       	ldd	r30, Y+5	; 0x05
    19fc:	fe 81       	ldd	r31, Y+6	; 0x06
    19fe:	8b 81       	ldd	r24, Y+3	; 0x03
    1a00:	9c 81       	ldd	r25, Y+4	; 0x04
    1a02:	91 87       	std	Z+9, r25	; 0x09
    1a04:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1a06:	eb 81       	ldd	r30, Y+3	; 0x03
    1a08:	fc 81       	ldd	r31, Y+4	; 0x04
    1a0a:	80 81       	ld	r24, Z
    1a0c:	8f 5f       	subi	r24, 0xFF	; 255
    1a0e:	eb 81       	ldd	r30, Y+3	; 0x03
    1a10:	fc 81       	ldd	r31, Y+4	; 0x04
    1a12:	80 83       	st	Z, r24
}
    1a14:	26 96       	adiw	r28, 0x06	; 6
    1a16:	0f b6       	in	r0, 0x3f	; 63
    1a18:	f8 94       	cli
    1a1a:	de bf       	out	0x3e, r29	; 62
    1a1c:	0f be       	out	0x3f, r0	; 63
    1a1e:	cd bf       	out	0x3d, r28	; 61
    1a20:	cf 91       	pop	r28
    1a22:	df 91       	pop	r29
    1a24:	08 95       	ret

00001a26 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1a26:	df 93       	push	r29
    1a28:	cf 93       	push	r28
    1a2a:	cd b7       	in	r28, 0x3d	; 61
    1a2c:	de b7       	in	r29, 0x3e	; 62
    1a2e:	28 97       	sbiw	r28, 0x08	; 8
    1a30:	0f b6       	in	r0, 0x3f	; 63
    1a32:	f8 94       	cli
    1a34:	de bf       	out	0x3e, r29	; 62
    1a36:	0f be       	out	0x3f, r0	; 63
    1a38:	cd bf       	out	0x3d, r28	; 61
    1a3a:	9e 83       	std	Y+6, r25	; 0x06
    1a3c:	8d 83       	std	Y+5, r24	; 0x05
    1a3e:	78 87       	std	Y+8, r23	; 0x08
    1a40:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1a42:	ef 81       	ldd	r30, Y+7	; 0x07
    1a44:	f8 85       	ldd	r31, Y+8	; 0x08
    1a46:	80 81       	ld	r24, Z
    1a48:	91 81       	ldd	r25, Z+1	; 0x01
    1a4a:	9a 83       	std	Y+2, r25	; 0x02
    1a4c:	89 83       	std	Y+1, r24	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1a4e:	89 81       	ldd	r24, Y+1	; 0x01
    1a50:	9a 81       	ldd	r25, Y+2	; 0x02
    1a52:	2f ef       	ldi	r18, 0xFF	; 255
    1a54:	8f 3f       	cpi	r24, 0xFF	; 255
    1a56:	92 07       	cpc	r25, r18
    1a58:	39 f4       	brne	.+14     	; 0x1a68 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1a5a:	ed 81       	ldd	r30, Y+5	; 0x05
    1a5c:	fe 81       	ldd	r31, Y+6	; 0x06
    1a5e:	87 81       	ldd	r24, Z+7	; 0x07
    1a60:	90 85       	ldd	r25, Z+8	; 0x08
    1a62:	9c 83       	std	Y+4, r25	; 0x04
    1a64:	8b 83       	std	Y+3, r24	; 0x03
    1a66:	18 c0       	rjmp	.+48     	; 0x1a98 <vListInsert+0x72>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    1a68:	8d 81       	ldd	r24, Y+5	; 0x05
    1a6a:	9e 81       	ldd	r25, Y+6	; 0x06
    1a6c:	03 96       	adiw	r24, 0x03	; 3
    1a6e:	9c 83       	std	Y+4, r25	; 0x04
    1a70:	8b 83       	std	Y+3, r24	; 0x03
    1a72:	06 c0       	rjmp	.+12     	; 0x1a80 <vListInsert+0x5a>
    1a74:	eb 81       	ldd	r30, Y+3	; 0x03
    1a76:	fc 81       	ldd	r31, Y+4	; 0x04
    1a78:	82 81       	ldd	r24, Z+2	; 0x02
    1a7a:	93 81       	ldd	r25, Z+3	; 0x03
    1a7c:	9c 83       	std	Y+4, r25	; 0x04
    1a7e:	8b 83       	std	Y+3, r24	; 0x03
    1a80:	eb 81       	ldd	r30, Y+3	; 0x03
    1a82:	fc 81       	ldd	r31, Y+4	; 0x04
    1a84:	02 80       	ldd	r0, Z+2	; 0x02
    1a86:	f3 81       	ldd	r31, Z+3	; 0x03
    1a88:	e0 2d       	mov	r30, r0
    1a8a:	20 81       	ld	r18, Z
    1a8c:	31 81       	ldd	r19, Z+1	; 0x01
    1a8e:	89 81       	ldd	r24, Y+1	; 0x01
    1a90:	9a 81       	ldd	r25, Y+2	; 0x02
    1a92:	82 17       	cp	r24, r18
    1a94:	93 07       	cpc	r25, r19
    1a96:	70 f7       	brcc	.-36     	; 0x1a74 <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1a98:	eb 81       	ldd	r30, Y+3	; 0x03
    1a9a:	fc 81       	ldd	r31, Y+4	; 0x04
    1a9c:	82 81       	ldd	r24, Z+2	; 0x02
    1a9e:	93 81       	ldd	r25, Z+3	; 0x03
    1aa0:	ef 81       	ldd	r30, Y+7	; 0x07
    1aa2:	f8 85       	ldd	r31, Y+8	; 0x08
    1aa4:	93 83       	std	Z+3, r25	; 0x03
    1aa6:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1aa8:	ef 81       	ldd	r30, Y+7	; 0x07
    1aaa:	f8 85       	ldd	r31, Y+8	; 0x08
    1aac:	02 80       	ldd	r0, Z+2	; 0x02
    1aae:	f3 81       	ldd	r31, Z+3	; 0x03
    1ab0:	e0 2d       	mov	r30, r0
    1ab2:	8f 81       	ldd	r24, Y+7	; 0x07
    1ab4:	98 85       	ldd	r25, Y+8	; 0x08
    1ab6:	95 83       	std	Z+5, r25	; 0x05
    1ab8:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1aba:	ef 81       	ldd	r30, Y+7	; 0x07
    1abc:	f8 85       	ldd	r31, Y+8	; 0x08
    1abe:	8b 81       	ldd	r24, Y+3	; 0x03
    1ac0:	9c 81       	ldd	r25, Y+4	; 0x04
    1ac2:	95 83       	std	Z+5, r25	; 0x05
    1ac4:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1ac6:	eb 81       	ldd	r30, Y+3	; 0x03
    1ac8:	fc 81       	ldd	r31, Y+4	; 0x04
    1aca:	8f 81       	ldd	r24, Y+7	; 0x07
    1acc:	98 85       	ldd	r25, Y+8	; 0x08
    1ace:	93 83       	std	Z+3, r25	; 0x03
    1ad0:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    1ad2:	ef 81       	ldd	r30, Y+7	; 0x07
    1ad4:	f8 85       	ldd	r31, Y+8	; 0x08
    1ad6:	8d 81       	ldd	r24, Y+5	; 0x05
    1ad8:	9e 81       	ldd	r25, Y+6	; 0x06
    1ada:	91 87       	std	Z+9, r25	; 0x09
    1adc:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1ade:	ed 81       	ldd	r30, Y+5	; 0x05
    1ae0:	fe 81       	ldd	r31, Y+6	; 0x06
    1ae2:	80 81       	ld	r24, Z
    1ae4:	8f 5f       	subi	r24, 0xFF	; 255
    1ae6:	ed 81       	ldd	r30, Y+5	; 0x05
    1ae8:	fe 81       	ldd	r31, Y+6	; 0x06
    1aea:	80 83       	st	Z, r24
}
    1aec:	28 96       	adiw	r28, 0x08	; 8
    1aee:	0f b6       	in	r0, 0x3f	; 63
    1af0:	f8 94       	cli
    1af2:	de bf       	out	0x3e, r29	; 62
    1af4:	0f be       	out	0x3f, r0	; 63
    1af6:	cd bf       	out	0x3d, r28	; 61
    1af8:	cf 91       	pop	r28
    1afa:	df 91       	pop	r29
    1afc:	08 95       	ret

00001afe <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1afe:	df 93       	push	r29
    1b00:	cf 93       	push	r28
    1b02:	00 d0       	rcall	.+0      	; 0x1b04 <uxListRemove+0x6>
    1b04:	00 d0       	rcall	.+0      	; 0x1b06 <uxListRemove+0x8>
    1b06:	cd b7       	in	r28, 0x3d	; 61
    1b08:	de b7       	in	r29, 0x3e	; 62
    1b0a:	9c 83       	std	Y+4, r25	; 0x04
    1b0c:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    1b0e:	eb 81       	ldd	r30, Y+3	; 0x03
    1b10:	fc 81       	ldd	r31, Y+4	; 0x04
    1b12:	80 85       	ldd	r24, Z+8	; 0x08
    1b14:	91 85       	ldd	r25, Z+9	; 0x09
    1b16:	9a 83       	std	Y+2, r25	; 0x02
    1b18:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1b1a:	eb 81       	ldd	r30, Y+3	; 0x03
    1b1c:	fc 81       	ldd	r31, Y+4	; 0x04
    1b1e:	a2 81       	ldd	r26, Z+2	; 0x02
    1b20:	b3 81       	ldd	r27, Z+3	; 0x03
    1b22:	eb 81       	ldd	r30, Y+3	; 0x03
    1b24:	fc 81       	ldd	r31, Y+4	; 0x04
    1b26:	84 81       	ldd	r24, Z+4	; 0x04
    1b28:	95 81       	ldd	r25, Z+5	; 0x05
    1b2a:	15 96       	adiw	r26, 0x05	; 5
    1b2c:	9c 93       	st	X, r25
    1b2e:	8e 93       	st	-X, r24
    1b30:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1b32:	eb 81       	ldd	r30, Y+3	; 0x03
    1b34:	fc 81       	ldd	r31, Y+4	; 0x04
    1b36:	a4 81       	ldd	r26, Z+4	; 0x04
    1b38:	b5 81       	ldd	r27, Z+5	; 0x05
    1b3a:	eb 81       	ldd	r30, Y+3	; 0x03
    1b3c:	fc 81       	ldd	r31, Y+4	; 0x04
    1b3e:	82 81       	ldd	r24, Z+2	; 0x02
    1b40:	93 81       	ldd	r25, Z+3	; 0x03
    1b42:	13 96       	adiw	r26, 0x03	; 3
    1b44:	9c 93       	st	X, r25
    1b46:	8e 93       	st	-X, r24
    1b48:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1b4a:	e9 81       	ldd	r30, Y+1	; 0x01
    1b4c:	fa 81       	ldd	r31, Y+2	; 0x02
    1b4e:	21 81       	ldd	r18, Z+1	; 0x01
    1b50:	32 81       	ldd	r19, Z+2	; 0x02
    1b52:	8b 81       	ldd	r24, Y+3	; 0x03
    1b54:	9c 81       	ldd	r25, Y+4	; 0x04
    1b56:	28 17       	cp	r18, r24
    1b58:	39 07       	cpc	r19, r25
    1b5a:	41 f4       	brne	.+16     	; 0x1b6c <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1b5c:	eb 81       	ldd	r30, Y+3	; 0x03
    1b5e:	fc 81       	ldd	r31, Y+4	; 0x04
    1b60:	84 81       	ldd	r24, Z+4	; 0x04
    1b62:	95 81       	ldd	r25, Z+5	; 0x05
    1b64:	e9 81       	ldd	r30, Y+1	; 0x01
    1b66:	fa 81       	ldd	r31, Y+2	; 0x02
    1b68:	92 83       	std	Z+2, r25	; 0x02
    1b6a:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    1b6c:	eb 81       	ldd	r30, Y+3	; 0x03
    1b6e:	fc 81       	ldd	r31, Y+4	; 0x04
    1b70:	11 86       	std	Z+9, r1	; 0x09
    1b72:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1b74:	e9 81       	ldd	r30, Y+1	; 0x01
    1b76:	fa 81       	ldd	r31, Y+2	; 0x02
    1b78:	80 81       	ld	r24, Z
    1b7a:	81 50       	subi	r24, 0x01	; 1
    1b7c:	e9 81       	ldd	r30, Y+1	; 0x01
    1b7e:	fa 81       	ldd	r31, Y+2	; 0x02
    1b80:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    1b82:	e9 81       	ldd	r30, Y+1	; 0x01
    1b84:	fa 81       	ldd	r31, Y+2	; 0x02
    1b86:	80 81       	ld	r24, Z
}
    1b88:	0f 90       	pop	r0
    1b8a:	0f 90       	pop	r0
    1b8c:	0f 90       	pop	r0
    1b8e:	0f 90       	pop	r0
    1b90:	cf 91       	pop	r28
    1b92:	df 91       	pop	r29
    1b94:	08 95       	ret

00001b96 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    1b96:	df 93       	push	r29
    1b98:	cf 93       	push	r28
    1b9a:	cd b7       	in	r28, 0x3d	; 61
    1b9c:	de b7       	in	r29, 0x3e	; 62
    1b9e:	28 97       	sbiw	r28, 0x08	; 8
    1ba0:	0f b6       	in	r0, 0x3f	; 63
    1ba2:	f8 94       	cli
    1ba4:	de bf       	out	0x3e, r29	; 62
    1ba6:	0f be       	out	0x3f, r0	; 63
    1ba8:	cd bf       	out	0x3d, r28	; 61
    1baa:	9c 83       	std	Y+4, r25	; 0x04
    1bac:	8b 83       	std	Y+3, r24	; 0x03
    1bae:	7e 83       	std	Y+6, r23	; 0x06
    1bb0:	6d 83       	std	Y+5, r22	; 0x05
    1bb2:	58 87       	std	Y+8, r21	; 0x08
    1bb4:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    1bb6:	eb 81       	ldd	r30, Y+3	; 0x03
    1bb8:	fc 81       	ldd	r31, Y+4	; 0x04
    1bba:	81 e1       	ldi	r24, 0x11	; 17
    1bbc:	80 83       	st	Z, r24
	pxTopOfStack--;
    1bbe:	8b 81       	ldd	r24, Y+3	; 0x03
    1bc0:	9c 81       	ldd	r25, Y+4	; 0x04
    1bc2:	01 97       	sbiw	r24, 0x01	; 1
    1bc4:	9c 83       	std	Y+4, r25	; 0x04
    1bc6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    1bc8:	eb 81       	ldd	r30, Y+3	; 0x03
    1bca:	fc 81       	ldd	r31, Y+4	; 0x04
    1bcc:	82 e2       	ldi	r24, 0x22	; 34
    1bce:	80 83       	st	Z, r24
	pxTopOfStack--;
    1bd0:	8b 81       	ldd	r24, Y+3	; 0x03
    1bd2:	9c 81       	ldd	r25, Y+4	; 0x04
    1bd4:	01 97       	sbiw	r24, 0x01	; 1
    1bd6:	9c 83       	std	Y+4, r25	; 0x04
    1bd8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    1bda:	eb 81       	ldd	r30, Y+3	; 0x03
    1bdc:	fc 81       	ldd	r31, Y+4	; 0x04
    1bde:	83 e3       	ldi	r24, 0x33	; 51
    1be0:	80 83       	st	Z, r24
	pxTopOfStack--;
    1be2:	8b 81       	ldd	r24, Y+3	; 0x03
    1be4:	9c 81       	ldd	r25, Y+4	; 0x04
    1be6:	01 97       	sbiw	r24, 0x01	; 1
    1be8:	9c 83       	std	Y+4, r25	; 0x04
    1bea:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    1bec:	8d 81       	ldd	r24, Y+5	; 0x05
    1bee:	9e 81       	ldd	r25, Y+6	; 0x06
    1bf0:	9a 83       	std	Y+2, r25	; 0x02
    1bf2:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1bf4:	89 81       	ldd	r24, Y+1	; 0x01
    1bf6:	eb 81       	ldd	r30, Y+3	; 0x03
    1bf8:	fc 81       	ldd	r31, Y+4	; 0x04
    1bfa:	80 83       	st	Z, r24
	pxTopOfStack--;
    1bfc:	8b 81       	ldd	r24, Y+3	; 0x03
    1bfe:	9c 81       	ldd	r25, Y+4	; 0x04
    1c00:	01 97       	sbiw	r24, 0x01	; 1
    1c02:	9c 83       	std	Y+4, r25	; 0x04
    1c04:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1c06:	89 81       	ldd	r24, Y+1	; 0x01
    1c08:	9a 81       	ldd	r25, Y+2	; 0x02
    1c0a:	89 2f       	mov	r24, r25
    1c0c:	99 27       	eor	r25, r25
    1c0e:	9a 83       	std	Y+2, r25	; 0x02
    1c10:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1c12:	89 81       	ldd	r24, Y+1	; 0x01
    1c14:	eb 81       	ldd	r30, Y+3	; 0x03
    1c16:	fc 81       	ldd	r31, Y+4	; 0x04
    1c18:	80 83       	st	Z, r24
	pxTopOfStack--;
    1c1a:	8b 81       	ldd	r24, Y+3	; 0x03
    1c1c:	9c 81       	ldd	r25, Y+4	; 0x04
    1c1e:	01 97       	sbiw	r24, 0x01	; 1
    1c20:	9c 83       	std	Y+4, r25	; 0x04
    1c22:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    1c24:	eb 81       	ldd	r30, Y+3	; 0x03
    1c26:	fc 81       	ldd	r31, Y+4	; 0x04
    1c28:	10 82       	st	Z, r1
	pxTopOfStack--;
    1c2a:	8b 81       	ldd	r24, Y+3	; 0x03
    1c2c:	9c 81       	ldd	r25, Y+4	; 0x04
    1c2e:	01 97       	sbiw	r24, 0x01	; 1
    1c30:	9c 83       	std	Y+4, r25	; 0x04
    1c32:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1c34:	eb 81       	ldd	r30, Y+3	; 0x03
    1c36:	fc 81       	ldd	r31, Y+4	; 0x04
    1c38:	80 e8       	ldi	r24, 0x80	; 128
    1c3a:	80 83       	st	Z, r24
	pxTopOfStack--;
    1c3c:	8b 81       	ldd	r24, Y+3	; 0x03
    1c3e:	9c 81       	ldd	r25, Y+4	; 0x04
    1c40:	01 97       	sbiw	r24, 0x01	; 1
    1c42:	9c 83       	std	Y+4, r25	; 0x04
    1c44:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    1c46:	eb 81       	ldd	r30, Y+3	; 0x03
    1c48:	fc 81       	ldd	r31, Y+4	; 0x04
    1c4a:	10 82       	st	Z, r1
	pxTopOfStack--;
    1c4c:	8b 81       	ldd	r24, Y+3	; 0x03
    1c4e:	9c 81       	ldd	r25, Y+4	; 0x04
    1c50:	01 97       	sbiw	r24, 0x01	; 1
    1c52:	9c 83       	std	Y+4, r25	; 0x04
    1c54:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    1c56:	eb 81       	ldd	r30, Y+3	; 0x03
    1c58:	fc 81       	ldd	r31, Y+4	; 0x04
    1c5a:	82 e0       	ldi	r24, 0x02	; 2
    1c5c:	80 83       	st	Z, r24
	pxTopOfStack--;
    1c5e:	8b 81       	ldd	r24, Y+3	; 0x03
    1c60:	9c 81       	ldd	r25, Y+4	; 0x04
    1c62:	01 97       	sbiw	r24, 0x01	; 1
    1c64:	9c 83       	std	Y+4, r25	; 0x04
    1c66:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    1c68:	eb 81       	ldd	r30, Y+3	; 0x03
    1c6a:	fc 81       	ldd	r31, Y+4	; 0x04
    1c6c:	83 e0       	ldi	r24, 0x03	; 3
    1c6e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1c70:	8b 81       	ldd	r24, Y+3	; 0x03
    1c72:	9c 81       	ldd	r25, Y+4	; 0x04
    1c74:	01 97       	sbiw	r24, 0x01	; 1
    1c76:	9c 83       	std	Y+4, r25	; 0x04
    1c78:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    1c7a:	eb 81       	ldd	r30, Y+3	; 0x03
    1c7c:	fc 81       	ldd	r31, Y+4	; 0x04
    1c7e:	84 e0       	ldi	r24, 0x04	; 4
    1c80:	80 83       	st	Z, r24
	pxTopOfStack--;
    1c82:	8b 81       	ldd	r24, Y+3	; 0x03
    1c84:	9c 81       	ldd	r25, Y+4	; 0x04
    1c86:	01 97       	sbiw	r24, 0x01	; 1
    1c88:	9c 83       	std	Y+4, r25	; 0x04
    1c8a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    1c8c:	eb 81       	ldd	r30, Y+3	; 0x03
    1c8e:	fc 81       	ldd	r31, Y+4	; 0x04
    1c90:	85 e0       	ldi	r24, 0x05	; 5
    1c92:	80 83       	st	Z, r24
	pxTopOfStack--;
    1c94:	8b 81       	ldd	r24, Y+3	; 0x03
    1c96:	9c 81       	ldd	r25, Y+4	; 0x04
    1c98:	01 97       	sbiw	r24, 0x01	; 1
    1c9a:	9c 83       	std	Y+4, r25	; 0x04
    1c9c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    1c9e:	eb 81       	ldd	r30, Y+3	; 0x03
    1ca0:	fc 81       	ldd	r31, Y+4	; 0x04
    1ca2:	86 e0       	ldi	r24, 0x06	; 6
    1ca4:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ca6:	8b 81       	ldd	r24, Y+3	; 0x03
    1ca8:	9c 81       	ldd	r25, Y+4	; 0x04
    1caa:	01 97       	sbiw	r24, 0x01	; 1
    1cac:	9c 83       	std	Y+4, r25	; 0x04
    1cae:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    1cb0:	eb 81       	ldd	r30, Y+3	; 0x03
    1cb2:	fc 81       	ldd	r31, Y+4	; 0x04
    1cb4:	87 e0       	ldi	r24, 0x07	; 7
    1cb6:	80 83       	st	Z, r24
	pxTopOfStack--;
    1cb8:	8b 81       	ldd	r24, Y+3	; 0x03
    1cba:	9c 81       	ldd	r25, Y+4	; 0x04
    1cbc:	01 97       	sbiw	r24, 0x01	; 1
    1cbe:	9c 83       	std	Y+4, r25	; 0x04
    1cc0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    1cc2:	eb 81       	ldd	r30, Y+3	; 0x03
    1cc4:	fc 81       	ldd	r31, Y+4	; 0x04
    1cc6:	88 e0       	ldi	r24, 0x08	; 8
    1cc8:	80 83       	st	Z, r24
	pxTopOfStack--;
    1cca:	8b 81       	ldd	r24, Y+3	; 0x03
    1ccc:	9c 81       	ldd	r25, Y+4	; 0x04
    1cce:	01 97       	sbiw	r24, 0x01	; 1
    1cd0:	9c 83       	std	Y+4, r25	; 0x04
    1cd2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    1cd4:	eb 81       	ldd	r30, Y+3	; 0x03
    1cd6:	fc 81       	ldd	r31, Y+4	; 0x04
    1cd8:	89 e0       	ldi	r24, 0x09	; 9
    1cda:	80 83       	st	Z, r24
	pxTopOfStack--;
    1cdc:	8b 81       	ldd	r24, Y+3	; 0x03
    1cde:	9c 81       	ldd	r25, Y+4	; 0x04
    1ce0:	01 97       	sbiw	r24, 0x01	; 1
    1ce2:	9c 83       	std	Y+4, r25	; 0x04
    1ce4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    1ce6:	eb 81       	ldd	r30, Y+3	; 0x03
    1ce8:	fc 81       	ldd	r31, Y+4	; 0x04
    1cea:	80 e1       	ldi	r24, 0x10	; 16
    1cec:	80 83       	st	Z, r24
	pxTopOfStack--;
    1cee:	8b 81       	ldd	r24, Y+3	; 0x03
    1cf0:	9c 81       	ldd	r25, Y+4	; 0x04
    1cf2:	01 97       	sbiw	r24, 0x01	; 1
    1cf4:	9c 83       	std	Y+4, r25	; 0x04
    1cf6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    1cf8:	eb 81       	ldd	r30, Y+3	; 0x03
    1cfa:	fc 81       	ldd	r31, Y+4	; 0x04
    1cfc:	81 e1       	ldi	r24, 0x11	; 17
    1cfe:	80 83       	st	Z, r24
	pxTopOfStack--;
    1d00:	8b 81       	ldd	r24, Y+3	; 0x03
    1d02:	9c 81       	ldd	r25, Y+4	; 0x04
    1d04:	01 97       	sbiw	r24, 0x01	; 1
    1d06:	9c 83       	std	Y+4, r25	; 0x04
    1d08:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    1d0a:	eb 81       	ldd	r30, Y+3	; 0x03
    1d0c:	fc 81       	ldd	r31, Y+4	; 0x04
    1d0e:	82 e1       	ldi	r24, 0x12	; 18
    1d10:	80 83       	st	Z, r24
	pxTopOfStack--;
    1d12:	8b 81       	ldd	r24, Y+3	; 0x03
    1d14:	9c 81       	ldd	r25, Y+4	; 0x04
    1d16:	01 97       	sbiw	r24, 0x01	; 1
    1d18:	9c 83       	std	Y+4, r25	; 0x04
    1d1a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    1d1c:	eb 81       	ldd	r30, Y+3	; 0x03
    1d1e:	fc 81       	ldd	r31, Y+4	; 0x04
    1d20:	83 e1       	ldi	r24, 0x13	; 19
    1d22:	80 83       	st	Z, r24
	pxTopOfStack--;
    1d24:	8b 81       	ldd	r24, Y+3	; 0x03
    1d26:	9c 81       	ldd	r25, Y+4	; 0x04
    1d28:	01 97       	sbiw	r24, 0x01	; 1
    1d2a:	9c 83       	std	Y+4, r25	; 0x04
    1d2c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    1d2e:	eb 81       	ldd	r30, Y+3	; 0x03
    1d30:	fc 81       	ldd	r31, Y+4	; 0x04
    1d32:	84 e1       	ldi	r24, 0x14	; 20
    1d34:	80 83       	st	Z, r24
	pxTopOfStack--;
    1d36:	8b 81       	ldd	r24, Y+3	; 0x03
    1d38:	9c 81       	ldd	r25, Y+4	; 0x04
    1d3a:	01 97       	sbiw	r24, 0x01	; 1
    1d3c:	9c 83       	std	Y+4, r25	; 0x04
    1d3e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    1d40:	eb 81       	ldd	r30, Y+3	; 0x03
    1d42:	fc 81       	ldd	r31, Y+4	; 0x04
    1d44:	85 e1       	ldi	r24, 0x15	; 21
    1d46:	80 83       	st	Z, r24
	pxTopOfStack--;
    1d48:	8b 81       	ldd	r24, Y+3	; 0x03
    1d4a:	9c 81       	ldd	r25, Y+4	; 0x04
    1d4c:	01 97       	sbiw	r24, 0x01	; 1
    1d4e:	9c 83       	std	Y+4, r25	; 0x04
    1d50:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    1d52:	eb 81       	ldd	r30, Y+3	; 0x03
    1d54:	fc 81       	ldd	r31, Y+4	; 0x04
    1d56:	86 e1       	ldi	r24, 0x16	; 22
    1d58:	80 83       	st	Z, r24
	pxTopOfStack--;
    1d5a:	8b 81       	ldd	r24, Y+3	; 0x03
    1d5c:	9c 81       	ldd	r25, Y+4	; 0x04
    1d5e:	01 97       	sbiw	r24, 0x01	; 1
    1d60:	9c 83       	std	Y+4, r25	; 0x04
    1d62:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    1d64:	eb 81       	ldd	r30, Y+3	; 0x03
    1d66:	fc 81       	ldd	r31, Y+4	; 0x04
    1d68:	87 e1       	ldi	r24, 0x17	; 23
    1d6a:	80 83       	st	Z, r24
	pxTopOfStack--;
    1d6c:	8b 81       	ldd	r24, Y+3	; 0x03
    1d6e:	9c 81       	ldd	r25, Y+4	; 0x04
    1d70:	01 97       	sbiw	r24, 0x01	; 1
    1d72:	9c 83       	std	Y+4, r25	; 0x04
    1d74:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    1d76:	eb 81       	ldd	r30, Y+3	; 0x03
    1d78:	fc 81       	ldd	r31, Y+4	; 0x04
    1d7a:	88 e1       	ldi	r24, 0x18	; 24
    1d7c:	80 83       	st	Z, r24
	pxTopOfStack--;
    1d7e:	8b 81       	ldd	r24, Y+3	; 0x03
    1d80:	9c 81       	ldd	r25, Y+4	; 0x04
    1d82:	01 97       	sbiw	r24, 0x01	; 1
    1d84:	9c 83       	std	Y+4, r25	; 0x04
    1d86:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    1d88:	eb 81       	ldd	r30, Y+3	; 0x03
    1d8a:	fc 81       	ldd	r31, Y+4	; 0x04
    1d8c:	89 e1       	ldi	r24, 0x19	; 25
    1d8e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1d90:	8b 81       	ldd	r24, Y+3	; 0x03
    1d92:	9c 81       	ldd	r25, Y+4	; 0x04
    1d94:	01 97       	sbiw	r24, 0x01	; 1
    1d96:	9c 83       	std	Y+4, r25	; 0x04
    1d98:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    1d9a:	eb 81       	ldd	r30, Y+3	; 0x03
    1d9c:	fc 81       	ldd	r31, Y+4	; 0x04
    1d9e:	80 e2       	ldi	r24, 0x20	; 32
    1da0:	80 83       	st	Z, r24
	pxTopOfStack--;
    1da2:	8b 81       	ldd	r24, Y+3	; 0x03
    1da4:	9c 81       	ldd	r25, Y+4	; 0x04
    1da6:	01 97       	sbiw	r24, 0x01	; 1
    1da8:	9c 83       	std	Y+4, r25	; 0x04
    1daa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    1dac:	eb 81       	ldd	r30, Y+3	; 0x03
    1dae:	fc 81       	ldd	r31, Y+4	; 0x04
    1db0:	81 e2       	ldi	r24, 0x21	; 33
    1db2:	80 83       	st	Z, r24
	pxTopOfStack--;
    1db4:	8b 81       	ldd	r24, Y+3	; 0x03
    1db6:	9c 81       	ldd	r25, Y+4	; 0x04
    1db8:	01 97       	sbiw	r24, 0x01	; 1
    1dba:	9c 83       	std	Y+4, r25	; 0x04
    1dbc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    1dbe:	eb 81       	ldd	r30, Y+3	; 0x03
    1dc0:	fc 81       	ldd	r31, Y+4	; 0x04
    1dc2:	82 e2       	ldi	r24, 0x22	; 34
    1dc4:	80 83       	st	Z, r24
	pxTopOfStack--;
    1dc6:	8b 81       	ldd	r24, Y+3	; 0x03
    1dc8:	9c 81       	ldd	r25, Y+4	; 0x04
    1dca:	01 97       	sbiw	r24, 0x01	; 1
    1dcc:	9c 83       	std	Y+4, r25	; 0x04
    1dce:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    1dd0:	eb 81       	ldd	r30, Y+3	; 0x03
    1dd2:	fc 81       	ldd	r31, Y+4	; 0x04
    1dd4:	83 e2       	ldi	r24, 0x23	; 35
    1dd6:	80 83       	st	Z, r24
	pxTopOfStack--;
    1dd8:	8b 81       	ldd	r24, Y+3	; 0x03
    1dda:	9c 81       	ldd	r25, Y+4	; 0x04
    1ddc:	01 97       	sbiw	r24, 0x01	; 1
    1dde:	9c 83       	std	Y+4, r25	; 0x04
    1de0:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    1de2:	8f 81       	ldd	r24, Y+7	; 0x07
    1de4:	98 85       	ldd	r25, Y+8	; 0x08
    1de6:	9a 83       	std	Y+2, r25	; 0x02
    1de8:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1dea:	89 81       	ldd	r24, Y+1	; 0x01
    1dec:	eb 81       	ldd	r30, Y+3	; 0x03
    1dee:	fc 81       	ldd	r31, Y+4	; 0x04
    1df0:	80 83       	st	Z, r24
	pxTopOfStack--;
    1df2:	8b 81       	ldd	r24, Y+3	; 0x03
    1df4:	9c 81       	ldd	r25, Y+4	; 0x04
    1df6:	01 97       	sbiw	r24, 0x01	; 1
    1df8:	9c 83       	std	Y+4, r25	; 0x04
    1dfa:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1dfc:	89 81       	ldd	r24, Y+1	; 0x01
    1dfe:	9a 81       	ldd	r25, Y+2	; 0x02
    1e00:	89 2f       	mov	r24, r25
    1e02:	99 27       	eor	r25, r25
    1e04:	9a 83       	std	Y+2, r25	; 0x02
    1e06:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1e08:	89 81       	ldd	r24, Y+1	; 0x01
    1e0a:	eb 81       	ldd	r30, Y+3	; 0x03
    1e0c:	fc 81       	ldd	r31, Y+4	; 0x04
    1e0e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e10:	8b 81       	ldd	r24, Y+3	; 0x03
    1e12:	9c 81       	ldd	r25, Y+4	; 0x04
    1e14:	01 97       	sbiw	r24, 0x01	; 1
    1e16:	9c 83       	std	Y+4, r25	; 0x04
    1e18:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    1e1a:	eb 81       	ldd	r30, Y+3	; 0x03
    1e1c:	fc 81       	ldd	r31, Y+4	; 0x04
    1e1e:	86 e2       	ldi	r24, 0x26	; 38
    1e20:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e22:	8b 81       	ldd	r24, Y+3	; 0x03
    1e24:	9c 81       	ldd	r25, Y+4	; 0x04
    1e26:	01 97       	sbiw	r24, 0x01	; 1
    1e28:	9c 83       	std	Y+4, r25	; 0x04
    1e2a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    1e2c:	eb 81       	ldd	r30, Y+3	; 0x03
    1e2e:	fc 81       	ldd	r31, Y+4	; 0x04
    1e30:	87 e2       	ldi	r24, 0x27	; 39
    1e32:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e34:	8b 81       	ldd	r24, Y+3	; 0x03
    1e36:	9c 81       	ldd	r25, Y+4	; 0x04
    1e38:	01 97       	sbiw	r24, 0x01	; 1
    1e3a:	9c 83       	std	Y+4, r25	; 0x04
    1e3c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    1e3e:	eb 81       	ldd	r30, Y+3	; 0x03
    1e40:	fc 81       	ldd	r31, Y+4	; 0x04
    1e42:	88 e2       	ldi	r24, 0x28	; 40
    1e44:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e46:	8b 81       	ldd	r24, Y+3	; 0x03
    1e48:	9c 81       	ldd	r25, Y+4	; 0x04
    1e4a:	01 97       	sbiw	r24, 0x01	; 1
    1e4c:	9c 83       	std	Y+4, r25	; 0x04
    1e4e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    1e50:	eb 81       	ldd	r30, Y+3	; 0x03
    1e52:	fc 81       	ldd	r31, Y+4	; 0x04
    1e54:	89 e2       	ldi	r24, 0x29	; 41
    1e56:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e58:	8b 81       	ldd	r24, Y+3	; 0x03
    1e5a:	9c 81       	ldd	r25, Y+4	; 0x04
    1e5c:	01 97       	sbiw	r24, 0x01	; 1
    1e5e:	9c 83       	std	Y+4, r25	; 0x04
    1e60:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    1e62:	eb 81       	ldd	r30, Y+3	; 0x03
    1e64:	fc 81       	ldd	r31, Y+4	; 0x04
    1e66:	80 e3       	ldi	r24, 0x30	; 48
    1e68:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e6a:	8b 81       	ldd	r24, Y+3	; 0x03
    1e6c:	9c 81       	ldd	r25, Y+4	; 0x04
    1e6e:	01 97       	sbiw	r24, 0x01	; 1
    1e70:	9c 83       	std	Y+4, r25	; 0x04
    1e72:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    1e74:	eb 81       	ldd	r30, Y+3	; 0x03
    1e76:	fc 81       	ldd	r31, Y+4	; 0x04
    1e78:	81 e3       	ldi	r24, 0x31	; 49
    1e7a:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e7c:	8b 81       	ldd	r24, Y+3	; 0x03
    1e7e:	9c 81       	ldd	r25, Y+4	; 0x04
    1e80:	01 97       	sbiw	r24, 0x01	; 1
    1e82:	9c 83       	std	Y+4, r25	; 0x04
    1e84:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    1e86:	8b 81       	ldd	r24, Y+3	; 0x03
    1e88:	9c 81       	ldd	r25, Y+4	; 0x04
}
    1e8a:	28 96       	adiw	r28, 0x08	; 8
    1e8c:	0f b6       	in	r0, 0x3f	; 63
    1e8e:	f8 94       	cli
    1e90:	de bf       	out	0x3e, r29	; 62
    1e92:	0f be       	out	0x3f, r0	; 63
    1e94:	cd bf       	out	0x3d, r28	; 61
    1e96:	cf 91       	pop	r28
    1e98:	df 91       	pop	r29
    1e9a:	08 95       	ret

00001e9c <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    1e9c:	df 93       	push	r29
    1e9e:	cf 93       	push	r28
    1ea0:	cd b7       	in	r28, 0x3d	; 61
    1ea2:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    1ea4:	0e 94 40 10 	call	0x2080	; 0x2080 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    1ea8:	a0 91 a0 06 	lds	r26, 0x06A0
    1eac:	b0 91 a1 06 	lds	r27, 0x06A1
    1eb0:	cd 91       	ld	r28, X+
    1eb2:	cd bf       	out	0x3d, r28	; 61
    1eb4:	dd 91       	ld	r29, X+
    1eb6:	de bf       	out	0x3e, r29	; 62
    1eb8:	ff 91       	pop	r31
    1eba:	ef 91       	pop	r30
    1ebc:	df 91       	pop	r29
    1ebe:	cf 91       	pop	r28
    1ec0:	bf 91       	pop	r27
    1ec2:	af 91       	pop	r26
    1ec4:	9f 91       	pop	r25
    1ec6:	8f 91       	pop	r24
    1ec8:	7f 91       	pop	r23
    1eca:	6f 91       	pop	r22
    1ecc:	5f 91       	pop	r21
    1ece:	4f 91       	pop	r20
    1ed0:	3f 91       	pop	r19
    1ed2:	2f 91       	pop	r18
    1ed4:	1f 91       	pop	r17
    1ed6:	0f 91       	pop	r16
    1ed8:	ff 90       	pop	r15
    1eda:	ef 90       	pop	r14
    1edc:	df 90       	pop	r13
    1ede:	cf 90       	pop	r12
    1ee0:	bf 90       	pop	r11
    1ee2:	af 90       	pop	r10
    1ee4:	9f 90       	pop	r9
    1ee6:	8f 90       	pop	r8
    1ee8:	7f 90       	pop	r7
    1eea:	6f 90       	pop	r6
    1eec:	5f 90       	pop	r5
    1eee:	4f 90       	pop	r4
    1ef0:	3f 90       	pop	r3
    1ef2:	2f 90       	pop	r2
    1ef4:	1f 90       	pop	r1
    1ef6:	0f 90       	pop	r0
    1ef8:	0f be       	out	0x3f, r0	; 63
    1efa:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1efc:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    1efe:	81 e0       	ldi	r24, 0x01	; 1
}
    1f00:	cf 91       	pop	r28
    1f02:	df 91       	pop	r29
    1f04:	08 95       	ret

00001f06 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1f06:	df 93       	push	r29
    1f08:	cf 93       	push	r28
    1f0a:	cd b7       	in	r28, 0x3d	; 61
    1f0c:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    1f0e:	cf 91       	pop	r28
    1f10:	df 91       	pop	r29
    1f12:	08 95       	ret

00001f14 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1f14:	0f 92       	push	r0
    1f16:	0f b6       	in	r0, 0x3f	; 63
    1f18:	f8 94       	cli
    1f1a:	0f 92       	push	r0
    1f1c:	1f 92       	push	r1
    1f1e:	11 24       	eor	r1, r1
    1f20:	2f 92       	push	r2
    1f22:	3f 92       	push	r3
    1f24:	4f 92       	push	r4
    1f26:	5f 92       	push	r5
    1f28:	6f 92       	push	r6
    1f2a:	7f 92       	push	r7
    1f2c:	8f 92       	push	r8
    1f2e:	9f 92       	push	r9
    1f30:	af 92       	push	r10
    1f32:	bf 92       	push	r11
    1f34:	cf 92       	push	r12
    1f36:	df 92       	push	r13
    1f38:	ef 92       	push	r14
    1f3a:	ff 92       	push	r15
    1f3c:	0f 93       	push	r16
    1f3e:	1f 93       	push	r17
    1f40:	2f 93       	push	r18
    1f42:	3f 93       	push	r19
    1f44:	4f 93       	push	r20
    1f46:	5f 93       	push	r21
    1f48:	6f 93       	push	r22
    1f4a:	7f 93       	push	r23
    1f4c:	8f 93       	push	r24
    1f4e:	9f 93       	push	r25
    1f50:	af 93       	push	r26
    1f52:	bf 93       	push	r27
    1f54:	cf 93       	push	r28
    1f56:	df 93       	push	r29
    1f58:	ef 93       	push	r30
    1f5a:	ff 93       	push	r31
    1f5c:	a0 91 a0 06 	lds	r26, 0x06A0
    1f60:	b0 91 a1 06 	lds	r27, 0x06A1
    1f64:	0d b6       	in	r0, 0x3d	; 61
    1f66:	0d 92       	st	X+, r0
    1f68:	0e b6       	in	r0, 0x3e	; 62
    1f6a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1f6c:	0e 94 f4 24 	call	0x49e8	; 0x49e8 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1f70:	a0 91 a0 06 	lds	r26, 0x06A0
    1f74:	b0 91 a1 06 	lds	r27, 0x06A1
    1f78:	cd 91       	ld	r28, X+
    1f7a:	cd bf       	out	0x3d, r28	; 61
    1f7c:	dd 91       	ld	r29, X+
    1f7e:	de bf       	out	0x3e, r29	; 62
    1f80:	ff 91       	pop	r31
    1f82:	ef 91       	pop	r30
    1f84:	df 91       	pop	r29
    1f86:	cf 91       	pop	r28
    1f88:	bf 91       	pop	r27
    1f8a:	af 91       	pop	r26
    1f8c:	9f 91       	pop	r25
    1f8e:	8f 91       	pop	r24
    1f90:	7f 91       	pop	r23
    1f92:	6f 91       	pop	r22
    1f94:	5f 91       	pop	r21
    1f96:	4f 91       	pop	r20
    1f98:	3f 91       	pop	r19
    1f9a:	2f 91       	pop	r18
    1f9c:	1f 91       	pop	r17
    1f9e:	0f 91       	pop	r16
    1fa0:	ff 90       	pop	r15
    1fa2:	ef 90       	pop	r14
    1fa4:	df 90       	pop	r13
    1fa6:	cf 90       	pop	r12
    1fa8:	bf 90       	pop	r11
    1faa:	af 90       	pop	r10
    1fac:	9f 90       	pop	r9
    1fae:	8f 90       	pop	r8
    1fb0:	7f 90       	pop	r7
    1fb2:	6f 90       	pop	r6
    1fb4:	5f 90       	pop	r5
    1fb6:	4f 90       	pop	r4
    1fb8:	3f 90       	pop	r3
    1fba:	2f 90       	pop	r2
    1fbc:	1f 90       	pop	r1
    1fbe:	0f 90       	pop	r0
    1fc0:	0f be       	out	0x3f, r0	; 63
    1fc2:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1fc4:	08 95       	ret

00001fc6 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1fc6:	0f 92       	push	r0
    1fc8:	0f b6       	in	r0, 0x3f	; 63
    1fca:	f8 94       	cli
    1fcc:	0f 92       	push	r0
    1fce:	1f 92       	push	r1
    1fd0:	11 24       	eor	r1, r1
    1fd2:	2f 92       	push	r2
    1fd4:	3f 92       	push	r3
    1fd6:	4f 92       	push	r4
    1fd8:	5f 92       	push	r5
    1fda:	6f 92       	push	r6
    1fdc:	7f 92       	push	r7
    1fde:	8f 92       	push	r8
    1fe0:	9f 92       	push	r9
    1fe2:	af 92       	push	r10
    1fe4:	bf 92       	push	r11
    1fe6:	cf 92       	push	r12
    1fe8:	df 92       	push	r13
    1fea:	ef 92       	push	r14
    1fec:	ff 92       	push	r15
    1fee:	0f 93       	push	r16
    1ff0:	1f 93       	push	r17
    1ff2:	2f 93       	push	r18
    1ff4:	3f 93       	push	r19
    1ff6:	4f 93       	push	r20
    1ff8:	5f 93       	push	r21
    1ffa:	6f 93       	push	r22
    1ffc:	7f 93       	push	r23
    1ffe:	8f 93       	push	r24
    2000:	9f 93       	push	r25
    2002:	af 93       	push	r26
    2004:	bf 93       	push	r27
    2006:	cf 93       	push	r28
    2008:	df 93       	push	r29
    200a:	ef 93       	push	r30
    200c:	ff 93       	push	r31
    200e:	a0 91 a0 06 	lds	r26, 0x06A0
    2012:	b0 91 a1 06 	lds	r27, 0x06A1
    2016:	0d b6       	in	r0, 0x3d	; 61
    2018:	0d 92       	st	X+, r0
    201a:	0e b6       	in	r0, 0x3e	; 62
    201c:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    201e:	0e 94 3b 24 	call	0x4876	; 0x4876 <xTaskIncrementTick>
    2022:	88 23       	and	r24, r24
    2024:	11 f0       	breq	.+4      	; 0x202a <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    2026:	0e 94 f4 24 	call	0x49e8	; 0x49e8 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    202a:	a0 91 a0 06 	lds	r26, 0x06A0
    202e:	b0 91 a1 06 	lds	r27, 0x06A1
    2032:	cd 91       	ld	r28, X+
    2034:	cd bf       	out	0x3d, r28	; 61
    2036:	dd 91       	ld	r29, X+
    2038:	de bf       	out	0x3e, r29	; 62
    203a:	ff 91       	pop	r31
    203c:	ef 91       	pop	r30
    203e:	df 91       	pop	r29
    2040:	cf 91       	pop	r28
    2042:	bf 91       	pop	r27
    2044:	af 91       	pop	r26
    2046:	9f 91       	pop	r25
    2048:	8f 91       	pop	r24
    204a:	7f 91       	pop	r23
    204c:	6f 91       	pop	r22
    204e:	5f 91       	pop	r21
    2050:	4f 91       	pop	r20
    2052:	3f 91       	pop	r19
    2054:	2f 91       	pop	r18
    2056:	1f 91       	pop	r17
    2058:	0f 91       	pop	r16
    205a:	ff 90       	pop	r15
    205c:	ef 90       	pop	r14
    205e:	df 90       	pop	r13
    2060:	cf 90       	pop	r12
    2062:	bf 90       	pop	r11
    2064:	af 90       	pop	r10
    2066:	9f 90       	pop	r9
    2068:	8f 90       	pop	r8
    206a:	7f 90       	pop	r7
    206c:	6f 90       	pop	r6
    206e:	5f 90       	pop	r5
    2070:	4f 90       	pop	r4
    2072:	3f 90       	pop	r3
    2074:	2f 90       	pop	r2
    2076:	1f 90       	pop	r1
    2078:	0f 90       	pop	r0
    207a:	0f be       	out	0x3f, r0	; 63
    207c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    207e:	08 95       	ret

00002080 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    2080:	df 93       	push	r29
    2082:	cf 93       	push	r28
    2084:	00 d0       	rcall	.+0      	; 0x2086 <prvSetupTimerInterrupt+0x6>
    2086:	00 d0       	rcall	.+0      	; 0x2088 <prvSetupTimerInterrupt+0x8>
    2088:	00 d0       	rcall	.+0      	; 0x208a <prvSetupTimerInterrupt+0xa>
    208a:	cd b7       	in	r28, 0x3d	; 61
    208c:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    208e:	80 e4       	ldi	r24, 0x40	; 64
    2090:	9f e1       	ldi	r25, 0x1F	; 31
    2092:	a0 e0       	ldi	r26, 0x00	; 0
    2094:	b0 e0       	ldi	r27, 0x00	; 0
    2096:	8b 83       	std	Y+3, r24	; 0x03
    2098:	9c 83       	std	Y+4, r25	; 0x04
    209a:	ad 83       	std	Y+5, r26	; 0x05
    209c:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    209e:	8b 81       	ldd	r24, Y+3	; 0x03
    20a0:	9c 81       	ldd	r25, Y+4	; 0x04
    20a2:	ad 81       	ldd	r26, Y+5	; 0x05
    20a4:	be 81       	ldd	r27, Y+6	; 0x06
    20a6:	68 94       	set
    20a8:	15 f8       	bld	r1, 5
    20aa:	b6 95       	lsr	r27
    20ac:	a7 95       	ror	r26
    20ae:	97 95       	ror	r25
    20b0:	87 95       	ror	r24
    20b2:	16 94       	lsr	r1
    20b4:	d1 f7       	brne	.-12     	; 0x20aa <prvSetupTimerInterrupt+0x2a>
    20b6:	8b 83       	std	Y+3, r24	; 0x03
    20b8:	9c 83       	std	Y+4, r25	; 0x04
    20ba:	ad 83       	std	Y+5, r26	; 0x05
    20bc:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    20be:	8b 81       	ldd	r24, Y+3	; 0x03
    20c0:	9c 81       	ldd	r25, Y+4	; 0x04
    20c2:	ad 81       	ldd	r26, Y+5	; 0x05
    20c4:	be 81       	ldd	r27, Y+6	; 0x06
    20c6:	01 97       	sbiw	r24, 0x01	; 1
    20c8:	a1 09       	sbc	r26, r1
    20ca:	b1 09       	sbc	r27, r1
    20cc:	8b 83       	std	Y+3, r24	; 0x03
    20ce:	9c 83       	std	Y+4, r25	; 0x04
    20d0:	ad 83       	std	Y+5, r26	; 0x05
    20d2:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    20d4:	8b 81       	ldd	r24, Y+3	; 0x03
    20d6:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    20d8:	8b 81       	ldd	r24, Y+3	; 0x03
    20da:	9c 81       	ldd	r25, Y+4	; 0x04
    20dc:	ad 81       	ldd	r26, Y+5	; 0x05
    20de:	be 81       	ldd	r27, Y+6	; 0x06
    20e0:	89 2f       	mov	r24, r25
    20e2:	9a 2f       	mov	r25, r26
    20e4:	ab 2f       	mov	r26, r27
    20e6:	bb 27       	eor	r27, r27
    20e8:	8b 83       	std	Y+3, r24	; 0x03
    20ea:	9c 83       	std	Y+4, r25	; 0x04
    20ec:	ad 83       	std	Y+5, r26	; 0x05
    20ee:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    20f0:	8b 81       	ldd	r24, Y+3	; 0x03
    20f2:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    20f4:	eb e4       	ldi	r30, 0x4B	; 75
    20f6:	f0 e0       	ldi	r31, 0x00	; 0
    20f8:	8a 81       	ldd	r24, Y+2	; 0x02
    20fa:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    20fc:	ea e4       	ldi	r30, 0x4A	; 74
    20fe:	f0 e0       	ldi	r31, 0x00	; 0
    2100:	89 81       	ldd	r24, Y+1	; 0x01
    2102:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    2104:	8b e0       	ldi	r24, 0x0B	; 11
    2106:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    2108:	ee e4       	ldi	r30, 0x4E	; 78
    210a:	f0 e0       	ldi	r31, 0x00	; 0
    210c:	89 81       	ldd	r24, Y+1	; 0x01
    210e:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    2110:	e9 e5       	ldi	r30, 0x59	; 89
    2112:	f0 e0       	ldi	r31, 0x00	; 0
    2114:	80 81       	ld	r24, Z
    2116:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    2118:	89 81       	ldd	r24, Y+1	; 0x01
    211a:	80 61       	ori	r24, 0x10	; 16
    211c:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    211e:	e9 e5       	ldi	r30, 0x59	; 89
    2120:	f0 e0       	ldi	r31, 0x00	; 0
    2122:	89 81       	ldd	r24, Y+1	; 0x01
    2124:	80 83       	st	Z, r24
}
    2126:	26 96       	adiw	r28, 0x06	; 6
    2128:	0f b6       	in	r0, 0x3f	; 63
    212a:	f8 94       	cli
    212c:	de bf       	out	0x3e, r29	; 62
    212e:	0f be       	out	0x3f, r0	; 63
    2130:	cd bf       	out	0x3d, r28	; 61
    2132:	cf 91       	pop	r28
    2134:	df 91       	pop	r29
    2136:	08 95       	ret

00002138 <__vector_7>:
	 * tick count.  We don't need to switch context, this can only be done by
	 * manual calls to taskYIELD();
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
    2138:	1f 92       	push	r1
    213a:	0f 92       	push	r0
    213c:	0f b6       	in	r0, 0x3f	; 63
    213e:	0f 92       	push	r0
    2140:	11 24       	eor	r1, r1
    2142:	2f 93       	push	r18
    2144:	3f 93       	push	r19
    2146:	4f 93       	push	r20
    2148:	5f 93       	push	r21
    214a:	6f 93       	push	r22
    214c:	7f 93       	push	r23
    214e:	8f 93       	push	r24
    2150:	9f 93       	push	r25
    2152:	af 93       	push	r26
    2154:	bf 93       	push	r27
    2156:	ef 93       	push	r30
    2158:	ff 93       	push	r31
    215a:	df 93       	push	r29
    215c:	cf 93       	push	r28
    215e:	cd b7       	in	r28, 0x3d	; 61
    2160:	de b7       	in	r29, 0x3e	; 62
		xTaskIncrementTick();
    2162:	0e 94 3b 24 	call	0x4876	; 0x4876 <xTaskIncrementTick>
	}
    2166:	cf 91       	pop	r28
    2168:	df 91       	pop	r29
    216a:	ff 91       	pop	r31
    216c:	ef 91       	pop	r30
    216e:	bf 91       	pop	r27
    2170:	af 91       	pop	r26
    2172:	9f 91       	pop	r25
    2174:	8f 91       	pop	r24
    2176:	7f 91       	pop	r23
    2178:	6f 91       	pop	r22
    217a:	5f 91       	pop	r21
    217c:	4f 91       	pop	r20
    217e:	3f 91       	pop	r19
    2180:	2f 91       	pop	r18
    2182:	0f 90       	pop	r0
    2184:	0f be       	out	0x3f, r0	; 63
    2186:	0f 90       	pop	r0
    2188:	1f 90       	pop	r1
    218a:	18 95       	reti

0000218c <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    218c:	df 93       	push	r29
    218e:	cf 93       	push	r28
    2190:	00 d0       	rcall	.+0      	; 0x2192 <xQueueGenericReset+0x6>
    2192:	00 d0       	rcall	.+0      	; 0x2194 <xQueueGenericReset+0x8>
    2194:	0f 92       	push	r0
    2196:	cd b7       	in	r28, 0x3d	; 61
    2198:	de b7       	in	r29, 0x3e	; 62
    219a:	9c 83       	std	Y+4, r25	; 0x04
    219c:	8b 83       	std	Y+3, r24	; 0x03
    219e:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = xQueue;
    21a0:	8b 81       	ldd	r24, Y+3	; 0x03
    21a2:	9c 81       	ldd	r25, Y+4	; 0x04
    21a4:	9a 83       	std	Y+2, r25	; 0x02
    21a6:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    21a8:	0f b6       	in	r0, 0x3f	; 63
    21aa:	f8 94       	cli
    21ac:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    21ae:	e9 81       	ldd	r30, Y+1	; 0x01
    21b0:	fa 81       	ldd	r31, Y+2	; 0x02
    21b2:	40 81       	ld	r20, Z
    21b4:	51 81       	ldd	r21, Z+1	; 0x01
    21b6:	e9 81       	ldd	r30, Y+1	; 0x01
    21b8:	fa 81       	ldd	r31, Y+2	; 0x02
    21ba:	83 8d       	ldd	r24, Z+27	; 0x1b
    21bc:	28 2f       	mov	r18, r24
    21be:	30 e0       	ldi	r19, 0x00	; 0
    21c0:	e9 81       	ldd	r30, Y+1	; 0x01
    21c2:	fa 81       	ldd	r31, Y+2	; 0x02
    21c4:	84 8d       	ldd	r24, Z+28	; 0x1c
    21c6:	88 2f       	mov	r24, r24
    21c8:	90 e0       	ldi	r25, 0x00	; 0
    21ca:	bc 01       	movw	r22, r24
    21cc:	26 9f       	mul	r18, r22
    21ce:	c0 01       	movw	r24, r0
    21d0:	27 9f       	mul	r18, r23
    21d2:	90 0d       	add	r25, r0
    21d4:	36 9f       	mul	r19, r22
    21d6:	90 0d       	add	r25, r0
    21d8:	11 24       	eor	r1, r1
    21da:	84 0f       	add	r24, r20
    21dc:	95 1f       	adc	r25, r21
    21de:	e9 81       	ldd	r30, Y+1	; 0x01
    21e0:	fa 81       	ldd	r31, Y+2	; 0x02
    21e2:	95 83       	std	Z+5, r25	; 0x05
    21e4:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    21e6:	e9 81       	ldd	r30, Y+1	; 0x01
    21e8:	fa 81       	ldd	r31, Y+2	; 0x02
    21ea:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    21ec:	e9 81       	ldd	r30, Y+1	; 0x01
    21ee:	fa 81       	ldd	r31, Y+2	; 0x02
    21f0:	80 81       	ld	r24, Z
    21f2:	91 81       	ldd	r25, Z+1	; 0x01
    21f4:	e9 81       	ldd	r30, Y+1	; 0x01
    21f6:	fa 81       	ldd	r31, Y+2	; 0x02
    21f8:	93 83       	std	Z+3, r25	; 0x03
    21fa:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    21fc:	e9 81       	ldd	r30, Y+1	; 0x01
    21fe:	fa 81       	ldd	r31, Y+2	; 0x02
    2200:	40 81       	ld	r20, Z
    2202:	51 81       	ldd	r21, Z+1	; 0x01
    2204:	e9 81       	ldd	r30, Y+1	; 0x01
    2206:	fa 81       	ldd	r31, Y+2	; 0x02
    2208:	83 8d       	ldd	r24, Z+27	; 0x1b
    220a:	88 2f       	mov	r24, r24
    220c:	90 e0       	ldi	r25, 0x00	; 0
    220e:	9c 01       	movw	r18, r24
    2210:	21 50       	subi	r18, 0x01	; 1
    2212:	30 40       	sbci	r19, 0x00	; 0
    2214:	e9 81       	ldd	r30, Y+1	; 0x01
    2216:	fa 81       	ldd	r31, Y+2	; 0x02
    2218:	84 8d       	ldd	r24, Z+28	; 0x1c
    221a:	88 2f       	mov	r24, r24
    221c:	90 e0       	ldi	r25, 0x00	; 0
    221e:	bc 01       	movw	r22, r24
    2220:	26 9f       	mul	r18, r22
    2222:	c0 01       	movw	r24, r0
    2224:	27 9f       	mul	r18, r23
    2226:	90 0d       	add	r25, r0
    2228:	36 9f       	mul	r19, r22
    222a:	90 0d       	add	r25, r0
    222c:	11 24       	eor	r1, r1
    222e:	84 0f       	add	r24, r20
    2230:	95 1f       	adc	r25, r21
    2232:	e9 81       	ldd	r30, Y+1	; 0x01
    2234:	fa 81       	ldd	r31, Y+2	; 0x02
    2236:	97 83       	std	Z+7, r25	; 0x07
    2238:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    223a:	e9 81       	ldd	r30, Y+1	; 0x01
    223c:	fa 81       	ldd	r31, Y+2	; 0x02
    223e:	8f ef       	ldi	r24, 0xFF	; 255
    2240:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    2242:	e9 81       	ldd	r30, Y+1	; 0x01
    2244:	fa 81       	ldd	r31, Y+2	; 0x02
    2246:	8f ef       	ldi	r24, 0xFF	; 255
    2248:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    224a:	8d 81       	ldd	r24, Y+5	; 0x05
    224c:	88 23       	and	r24, r24
    224e:	59 f4       	brne	.+22     	; 0x2266 <xQueueGenericReset+0xda>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2250:	e9 81       	ldd	r30, Y+1	; 0x01
    2252:	fa 81       	ldd	r31, Y+2	; 0x02
    2254:	80 85       	ldd	r24, Z+8	; 0x08
    2256:	88 23       	and	r24, r24
    2258:	81 f0       	breq	.+32     	; 0x227a <xQueueGenericReset+0xee>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    225a:	89 81       	ldd	r24, Y+1	; 0x01
    225c:	9a 81       	ldd	r25, Y+2	; 0x02
    225e:	08 96       	adiw	r24, 0x08	; 8
    2260:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <xTaskRemoveFromEventList>
    2264:	0a c0       	rjmp	.+20     	; 0x227a <xQueueGenericReset+0xee>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    2266:	89 81       	ldd	r24, Y+1	; 0x01
    2268:	9a 81       	ldd	r25, Y+2	; 0x02
    226a:	08 96       	adiw	r24, 0x08	; 8
    226c:	0e 94 95 0c 	call	0x192a	; 0x192a <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    2270:	89 81       	ldd	r24, Y+1	; 0x01
    2272:	9a 81       	ldd	r25, Y+2	; 0x02
    2274:	41 96       	adiw	r24, 0x11	; 17
    2276:	0e 94 95 0c 	call	0x192a	; 0x192a <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    227a:	0f 90       	pop	r0
    227c:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    227e:	81 e0       	ldi	r24, 0x01	; 1
}
    2280:	0f 90       	pop	r0
    2282:	0f 90       	pop	r0
    2284:	0f 90       	pop	r0
    2286:	0f 90       	pop	r0
    2288:	0f 90       	pop	r0
    228a:	cf 91       	pop	r28
    228c:	df 91       	pop	r29
    228e:	08 95       	ret

00002290 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    2290:	0f 93       	push	r16
    2292:	1f 93       	push	r17
    2294:	df 93       	push	r29
    2296:	cf 93       	push	r28
    2298:	cd b7       	in	r28, 0x3d	; 61
    229a:	de b7       	in	r29, 0x3e	; 62
    229c:	29 97       	sbiw	r28, 0x09	; 9
    229e:	0f b6       	in	r0, 0x3f	; 63
    22a0:	f8 94       	cli
    22a2:	de bf       	out	0x3e, r29	; 62
    22a4:	0f be       	out	0x3f, r0	; 63
    22a6:	cd bf       	out	0x3d, r28	; 61
    22a8:	8f 83       	std	Y+7, r24	; 0x07
    22aa:	68 87       	std	Y+8, r22	; 0x08
    22ac:	49 87       	std	Y+9, r20	; 0x09
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    22ae:	88 85       	ldd	r24, Y+8	; 0x08
    22b0:	88 23       	and	r24, r24
    22b2:	19 f4       	brne	.+6      	; 0x22ba <xQueueGenericCreate+0x2a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    22b4:	1c 82       	std	Y+4, r1	; 0x04
    22b6:	1b 82       	std	Y+3, r1	; 0x03
    22b8:	10 c0       	rjmp	.+32     	; 0x22da <xQueueGenericCreate+0x4a>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    22ba:	8f 81       	ldd	r24, Y+7	; 0x07
    22bc:	28 2f       	mov	r18, r24
    22be:	30 e0       	ldi	r19, 0x00	; 0
    22c0:	88 85       	ldd	r24, Y+8	; 0x08
    22c2:	88 2f       	mov	r24, r24
    22c4:	90 e0       	ldi	r25, 0x00	; 0
    22c6:	ac 01       	movw	r20, r24
    22c8:	24 9f       	mul	r18, r20
    22ca:	c0 01       	movw	r24, r0
    22cc:	25 9f       	mul	r18, r21
    22ce:	90 0d       	add	r25, r0
    22d0:	34 9f       	mul	r19, r20
    22d2:	90 0d       	add	r25, r0
    22d4:	11 24       	eor	r1, r1
    22d6:	9c 83       	std	Y+4, r25	; 0x04
    22d8:	8b 83       	std	Y+3, r24	; 0x03
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    22da:	8b 81       	ldd	r24, Y+3	; 0x03
    22dc:	9c 81       	ldd	r25, Y+4	; 0x04
    22de:	4f 96       	adiw	r24, 0x1f	; 31
    22e0:	0e 94 19 0c 	call	0x1832	; 0x1832 <pvPortMalloc>
    22e4:	9e 83       	std	Y+6, r25	; 0x06
    22e6:	8d 83       	std	Y+5, r24	; 0x05

		if( pxNewQueue != NULL )
    22e8:	8d 81       	ldd	r24, Y+5	; 0x05
    22ea:	9e 81       	ldd	r25, Y+6	; 0x06
    22ec:	00 97       	sbiw	r24, 0x00	; 0
    22ee:	a1 f0       	breq	.+40     	; 0x2318 <xQueueGenericCreate+0x88>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
    22f0:	8d 81       	ldd	r24, Y+5	; 0x05
    22f2:	9e 81       	ldd	r25, Y+6	; 0x06
    22f4:	9a 83       	std	Y+2, r25	; 0x02
    22f6:	89 83       	std	Y+1, r24	; 0x01
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    22f8:	89 81       	ldd	r24, Y+1	; 0x01
    22fa:	9a 81       	ldd	r25, Y+2	; 0x02
    22fc:	4f 96       	adiw	r24, 0x1f	; 31
    22fe:	9a 83       	std	Y+2, r25	; 0x02
    2300:	89 83       	std	Y+1, r24	; 0x01
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    2302:	29 81       	ldd	r18, Y+1	; 0x01
    2304:	3a 81       	ldd	r19, Y+2	; 0x02
    2306:	ed 81       	ldd	r30, Y+5	; 0x05
    2308:	fe 81       	ldd	r31, Y+6	; 0x06
    230a:	8f 81       	ldd	r24, Y+7	; 0x07
    230c:	68 85       	ldd	r22, Y+8	; 0x08
    230e:	a9 01       	movw	r20, r18
    2310:	29 85       	ldd	r18, Y+9	; 0x09
    2312:	8f 01       	movw	r16, r30
    2314:	0e 94 99 11 	call	0x2332	; 0x2332 <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
    2318:	8d 81       	ldd	r24, Y+5	; 0x05
    231a:	9e 81       	ldd	r25, Y+6	; 0x06
	}
    231c:	29 96       	adiw	r28, 0x09	; 9
    231e:	0f b6       	in	r0, 0x3f	; 63
    2320:	f8 94       	cli
    2322:	de bf       	out	0x3e, r29	; 62
    2324:	0f be       	out	0x3f, r0	; 63
    2326:	cd bf       	out	0x3d, r28	; 61
    2328:	cf 91       	pop	r28
    232a:	df 91       	pop	r29
    232c:	1f 91       	pop	r17
    232e:	0f 91       	pop	r16
    2330:	08 95       	ret

00002332 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    2332:	0f 93       	push	r16
    2334:	1f 93       	push	r17
    2336:	df 93       	push	r29
    2338:	cf 93       	push	r28
    233a:	cd b7       	in	r28, 0x3d	; 61
    233c:	de b7       	in	r29, 0x3e	; 62
    233e:	27 97       	sbiw	r28, 0x07	; 7
    2340:	0f b6       	in	r0, 0x3f	; 63
    2342:	f8 94       	cli
    2344:	de bf       	out	0x3e, r29	; 62
    2346:	0f be       	out	0x3f, r0	; 63
    2348:	cd bf       	out	0x3d, r28	; 61
    234a:	89 83       	std	Y+1, r24	; 0x01
    234c:	6a 83       	std	Y+2, r22	; 0x02
    234e:	5c 83       	std	Y+4, r21	; 0x04
    2350:	4b 83       	std	Y+3, r20	; 0x03
    2352:	2d 83       	std	Y+5, r18	; 0x05
    2354:	1f 83       	std	Y+7, r17	; 0x07
    2356:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    2358:	8a 81       	ldd	r24, Y+2	; 0x02
    235a:	88 23       	and	r24, r24
    235c:	39 f4       	brne	.+14     	; 0x236c <prvInitialiseNewQueue+0x3a>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    235e:	8e 81       	ldd	r24, Y+6	; 0x06
    2360:	9f 81       	ldd	r25, Y+7	; 0x07
    2362:	ee 81       	ldd	r30, Y+6	; 0x06
    2364:	ff 81       	ldd	r31, Y+7	; 0x07
    2366:	91 83       	std	Z+1, r25	; 0x01
    2368:	80 83       	st	Z, r24
    236a:	06 c0       	rjmp	.+12     	; 0x2378 <prvInitialiseNewQueue+0x46>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    236c:	8b 81       	ldd	r24, Y+3	; 0x03
    236e:	9c 81       	ldd	r25, Y+4	; 0x04
    2370:	ee 81       	ldd	r30, Y+6	; 0x06
    2372:	ff 81       	ldd	r31, Y+7	; 0x07
    2374:	91 83       	std	Z+1, r25	; 0x01
    2376:	80 83       	st	Z, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    2378:	ee 81       	ldd	r30, Y+6	; 0x06
    237a:	ff 81       	ldd	r31, Y+7	; 0x07
    237c:	89 81       	ldd	r24, Y+1	; 0x01
    237e:	83 8f       	std	Z+27, r24	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    2380:	ee 81       	ldd	r30, Y+6	; 0x06
    2382:	ff 81       	ldd	r31, Y+7	; 0x07
    2384:	8a 81       	ldd	r24, Y+2	; 0x02
    2386:	84 8f       	std	Z+28, r24	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    2388:	8e 81       	ldd	r24, Y+6	; 0x06
    238a:	9f 81       	ldd	r25, Y+7	; 0x07
    238c:	61 e0       	ldi	r22, 0x01	; 1
    238e:	0e 94 c6 10 	call	0x218c	; 0x218c <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    2392:	27 96       	adiw	r28, 0x07	; 7
    2394:	0f b6       	in	r0, 0x3f	; 63
    2396:	f8 94       	cli
    2398:	de bf       	out	0x3e, r29	; 62
    239a:	0f be       	out	0x3f, r0	; 63
    239c:	cd bf       	out	0x3d, r28	; 61
    239e:	cf 91       	pop	r28
    23a0:	df 91       	pop	r29
    23a2:	1f 91       	pop	r17
    23a4:	0f 91       	pop	r16
    23a6:	08 95       	ret

000023a8 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    23a8:	df 93       	push	r29
    23aa:	cf 93       	push	r28
    23ac:	cd b7       	in	r28, 0x3d	; 61
    23ae:	de b7       	in	r29, 0x3e	; 62
    23b0:	2f 97       	sbiw	r28, 0x0f	; 15
    23b2:	0f b6       	in	r0, 0x3f	; 63
    23b4:	f8 94       	cli
    23b6:	de bf       	out	0x3e, r29	; 62
    23b8:	0f be       	out	0x3f, r0	; 63
    23ba:	cd bf       	out	0x3d, r28	; 61
    23bc:	99 87       	std	Y+9, r25	; 0x09
    23be:	88 87       	std	Y+8, r24	; 0x08
    23c0:	7b 87       	std	Y+11, r23	; 0x0b
    23c2:	6a 87       	std	Y+10, r22	; 0x0a
    23c4:	5d 87       	std	Y+13, r21	; 0x0d
    23c6:	4c 87       	std	Y+12, r20	; 0x0c
    23c8:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    23ca:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    23cc:	88 85       	ldd	r24, Y+8	; 0x08
    23ce:	99 85       	ldd	r25, Y+9	; 0x09
    23d0:	9a 83       	std	Y+2, r25	; 0x02
    23d2:	89 83       	std	Y+1, r24	; 0x01
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    23d4:	0f b6       	in	r0, 0x3f	; 63
    23d6:	f8 94       	cli
    23d8:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    23da:	e9 81       	ldd	r30, Y+1	; 0x01
    23dc:	fa 81       	ldd	r31, Y+2	; 0x02
    23de:	92 8d       	ldd	r25, Z+26	; 0x1a
    23e0:	e9 81       	ldd	r30, Y+1	; 0x01
    23e2:	fa 81       	ldd	r31, Y+2	; 0x02
    23e4:	83 8d       	ldd	r24, Z+27	; 0x1b
    23e6:	98 17       	cp	r25, r24
    23e8:	18 f0       	brcs	.+6      	; 0x23f0 <xQueueGenericSend+0x48>
    23ea:	8e 85       	ldd	r24, Y+14	; 0x0e
    23ec:	82 30       	cpi	r24, 0x02	; 2
    23ee:	c1 f4       	brne	.+48     	; 0x2420 <xQueueGenericSend+0x78>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    23f0:	89 81       	ldd	r24, Y+1	; 0x01
    23f2:	9a 81       	ldd	r25, Y+2	; 0x02
    23f4:	2a 85       	ldd	r18, Y+10	; 0x0a
    23f6:	3b 85       	ldd	r19, Y+11	; 0x0b
    23f8:	b9 01       	movw	r22, r18
    23fa:	4e 85       	ldd	r20, Y+14	; 0x0e
    23fc:	0e 94 10 16 	call	0x2c20	; 0x2c20 <prvCopyDataToQueue>
    2400:	8b 83       	std	Y+3, r24	; 0x03

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2402:	e9 81       	ldd	r30, Y+1	; 0x01
    2404:	fa 81       	ldd	r31, Y+2	; 0x02
    2406:	81 89       	ldd	r24, Z+17	; 0x11
    2408:	88 23       	and	r24, r24
    240a:	29 f0       	breq	.+10     	; 0x2416 <xQueueGenericSend+0x6e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    240c:	89 81       	ldd	r24, Y+1	; 0x01
    240e:	9a 81       	ldd	r25, Y+2	; 0x02
    2410:	41 96       	adiw	r24, 0x11	; 17
    2412:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <xTaskRemoveFromEventList>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    2416:	0f 90       	pop	r0
    2418:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    241a:	81 e0       	ldi	r24, 0x01	; 1
    241c:	8f 87       	std	Y+15, r24	; 0x0f
    241e:	5c c0       	rjmp	.+184    	; 0x24d8 <xQueueGenericSend+0x130>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2420:	8c 85       	ldd	r24, Y+12	; 0x0c
    2422:	9d 85       	ldd	r25, Y+13	; 0x0d
    2424:	00 97       	sbiw	r24, 0x00	; 0
    2426:	21 f4       	brne	.+8      	; 0x2430 <xQueueGenericSend+0x88>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2428:	0f 90       	pop	r0
    242a:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    242c:	1f 86       	std	Y+15, r1	; 0x0f
    242e:	54 c0       	rjmp	.+168    	; 0x24d8 <xQueueGenericSend+0x130>
				}
				else if( xEntryTimeSet == pdFALSE )
    2430:	8c 81       	ldd	r24, Y+4	; 0x04
    2432:	88 23       	and	r24, r24
    2434:	31 f4       	brne	.+12     	; 0x2442 <xQueueGenericSend+0x9a>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    2436:	ce 01       	movw	r24, r28
    2438:	05 96       	adiw	r24, 0x05	; 5
    243a:	0e 94 99 26 	call	0x4d32	; 0x4d32 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    243e:	81 e0       	ldi	r24, 0x01	; 1
    2440:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2442:	0f 90       	pop	r0
    2444:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2446:	0e 94 43 23 	call	0x4686	; 0x4686 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    244a:	0f b6       	in	r0, 0x3f	; 63
    244c:	f8 94       	cli
    244e:	0f 92       	push	r0
    2450:	e9 81       	ldd	r30, Y+1	; 0x01
    2452:	fa 81       	ldd	r31, Y+2	; 0x02
    2454:	85 8d       	ldd	r24, Z+29	; 0x1d
    2456:	8f 3f       	cpi	r24, 0xFF	; 255
    2458:	19 f4       	brne	.+6      	; 0x2460 <xQueueGenericSend+0xb8>
    245a:	e9 81       	ldd	r30, Y+1	; 0x01
    245c:	fa 81       	ldd	r31, Y+2	; 0x02
    245e:	15 8e       	std	Z+29, r1	; 0x1d
    2460:	e9 81       	ldd	r30, Y+1	; 0x01
    2462:	fa 81       	ldd	r31, Y+2	; 0x02
    2464:	86 8d       	ldd	r24, Z+30	; 0x1e
    2466:	8f 3f       	cpi	r24, 0xFF	; 255
    2468:	19 f4       	brne	.+6      	; 0x2470 <xQueueGenericSend+0xc8>
    246a:	e9 81       	ldd	r30, Y+1	; 0x01
    246c:	fa 81       	ldd	r31, Y+2	; 0x02
    246e:	16 8e       	std	Z+30, r1	; 0x1e
    2470:	0f 90       	pop	r0
    2472:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2474:	ce 01       	movw	r24, r28
    2476:	05 96       	adiw	r24, 0x05	; 5
    2478:	9e 01       	movw	r18, r28
    247a:	24 5f       	subi	r18, 0xF4	; 244
    247c:	3f 4f       	sbci	r19, 0xFF	; 255
    247e:	b9 01       	movw	r22, r18
    2480:	0e 94 b2 26 	call	0x4d64	; 0x4d64 <xTaskCheckForTimeOut>
    2484:	88 23       	and	r24, r24
    2486:	09 f5       	brne	.+66     	; 0x24ca <xQueueGenericSend+0x122>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2488:	89 81       	ldd	r24, Y+1	; 0x01
    248a:	9a 81       	ldd	r25, Y+2	; 0x02
    248c:	0e 94 8c 17 	call	0x2f18	; 0x2f18 <prvIsQueueFull>
    2490:	88 23       	and	r24, r24
    2492:	a1 f0       	breq	.+40     	; 0x24bc <xQueueGenericSend+0x114>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2494:	89 81       	ldd	r24, Y+1	; 0x01
    2496:	9a 81       	ldd	r25, Y+2	; 0x02
    2498:	08 96       	adiw	r24, 0x08	; 8
    249a:	2c 85       	ldd	r18, Y+12	; 0x0c
    249c:	3d 85       	ldd	r19, Y+13	; 0x0d
    249e:	b9 01       	movw	r22, r18
    24a0:	0e 94 61 25 	call	0x4ac2	; 0x4ac2 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    24a4:	89 81       	ldd	r24, Y+1	; 0x01
    24a6:	9a 81       	ldd	r25, Y+2	; 0x02
    24a8:	0e 94 fd 16 	call	0x2dfa	; 0x2dfa <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    24ac:	0e 94 4f 23 	call	0x469e	; 0x469e <xTaskResumeAll>
    24b0:	88 23       	and	r24, r24
    24b2:	09 f0       	breq	.+2      	; 0x24b6 <xQueueGenericSend+0x10e>
    24b4:	8f cf       	rjmp	.-226    	; 0x23d4 <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    24b6:	0e 94 8a 0f 	call	0x1f14	; 0x1f14 <vPortYield>
    24ba:	8c cf       	rjmp	.-232    	; 0x23d4 <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    24bc:	89 81       	ldd	r24, Y+1	; 0x01
    24be:	9a 81       	ldd	r25, Y+2	; 0x02
    24c0:	0e 94 fd 16 	call	0x2dfa	; 0x2dfa <prvUnlockQueue>
				( void ) xTaskResumeAll();
    24c4:	0e 94 4f 23 	call	0x469e	; 0x469e <xTaskResumeAll>
    24c8:	85 cf       	rjmp	.-246    	; 0x23d4 <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    24ca:	89 81       	ldd	r24, Y+1	; 0x01
    24cc:	9a 81       	ldd	r25, Y+2	; 0x02
    24ce:	0e 94 fd 16 	call	0x2dfa	; 0x2dfa <prvUnlockQueue>
			( void ) xTaskResumeAll();
    24d2:	0e 94 4f 23 	call	0x469e	; 0x469e <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    24d6:	1f 86       	std	Y+15, r1	; 0x0f
    24d8:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	} /*lint -restore */
}
    24da:	2f 96       	adiw	r28, 0x0f	; 15
    24dc:	0f b6       	in	r0, 0x3f	; 63
    24de:	f8 94       	cli
    24e0:	de bf       	out	0x3e, r29	; 62
    24e2:	0f be       	out	0x3f, r0	; 63
    24e4:	cd bf       	out	0x3d, r28	; 61
    24e6:	cf 91       	pop	r28
    24e8:	df 91       	pop	r29
    24ea:	08 95       	ret

000024ec <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    24ec:	df 93       	push	r29
    24ee:	cf 93       	push	r28
    24f0:	cd b7       	in	r28, 0x3d	; 61
    24f2:	de b7       	in	r29, 0x3e	; 62
    24f4:	2c 97       	sbiw	r28, 0x0c	; 12
    24f6:	0f b6       	in	r0, 0x3f	; 63
    24f8:	f8 94       	cli
    24fa:	de bf       	out	0x3e, r29	; 62
    24fc:	0f be       	out	0x3f, r0	; 63
    24fe:	cd bf       	out	0x3d, r28	; 61
    2500:	9f 83       	std	Y+7, r25	; 0x07
    2502:	8e 83       	std	Y+6, r24	; 0x06
    2504:	79 87       	std	Y+9, r23	; 0x09
    2506:	68 87       	std	Y+8, r22	; 0x08
    2508:	5b 87       	std	Y+11, r21	; 0x0b
    250a:	4a 87       	std	Y+10, r20	; 0x0a
    250c:	2c 87       	std	Y+12, r18	; 0x0c
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    250e:	8e 81       	ldd	r24, Y+6	; 0x06
    2510:	9f 81       	ldd	r25, Y+7	; 0x07
    2512:	9b 83       	std	Y+3, r25	; 0x03
    2514:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2516:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2518:	ea 81       	ldd	r30, Y+2	; 0x02
    251a:	fb 81       	ldd	r31, Y+3	; 0x03
    251c:	92 8d       	ldd	r25, Z+26	; 0x1a
    251e:	ea 81       	ldd	r30, Y+2	; 0x02
    2520:	fb 81       	ldd	r31, Y+3	; 0x03
    2522:	83 8d       	ldd	r24, Z+27	; 0x1b
    2524:	98 17       	cp	r25, r24
    2526:	18 f0       	brcs	.+6      	; 0x252e <xQueueGenericSendFromISR+0x42>
    2528:	8c 85       	ldd	r24, Y+12	; 0x0c
    252a:	82 30       	cpi	r24, 0x02	; 2
    252c:	61 f5       	brne	.+88     	; 0x2586 <xQueueGenericSendFromISR+0x9a>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    252e:	ea 81       	ldd	r30, Y+2	; 0x02
    2530:	fb 81       	ldd	r31, Y+3	; 0x03
    2532:	86 8d       	ldd	r24, Z+30	; 0x1e
    2534:	89 83       	std	Y+1, r24	; 0x01
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2536:	8a 81       	ldd	r24, Y+2	; 0x02
    2538:	9b 81       	ldd	r25, Y+3	; 0x03
    253a:	28 85       	ldd	r18, Y+8	; 0x08
    253c:	39 85       	ldd	r19, Y+9	; 0x09
    253e:	b9 01       	movw	r22, r18
    2540:	4c 85       	ldd	r20, Y+12	; 0x0c
    2542:	0e 94 10 16 	call	0x2c20	; 0x2c20 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    2546:	89 81       	ldd	r24, Y+1	; 0x01
    2548:	8f 3f       	cpi	r24, 0xFF	; 255
    254a:	a9 f4       	brne	.+42     	; 0x2576 <xQueueGenericSendFromISR+0x8a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    254c:	ea 81       	ldd	r30, Y+2	; 0x02
    254e:	fb 81       	ldd	r31, Y+3	; 0x03
    2550:	81 89       	ldd	r24, Z+17	; 0x11
    2552:	88 23       	and	r24, r24
    2554:	a9 f0       	breq	.+42     	; 0x2580 <xQueueGenericSendFromISR+0x94>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2556:	8a 81       	ldd	r24, Y+2	; 0x02
    2558:	9b 81       	ldd	r25, Y+3	; 0x03
    255a:	41 96       	adiw	r24, 0x11	; 17
    255c:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <xTaskRemoveFromEventList>
    2560:	88 23       	and	r24, r24
    2562:	71 f0       	breq	.+28     	; 0x2580 <xQueueGenericSendFromISR+0x94>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    2564:	8a 85       	ldd	r24, Y+10	; 0x0a
    2566:	9b 85       	ldd	r25, Y+11	; 0x0b
    2568:	00 97       	sbiw	r24, 0x00	; 0
    256a:	51 f0       	breq	.+20     	; 0x2580 <xQueueGenericSendFromISR+0x94>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    256c:	ea 85       	ldd	r30, Y+10	; 0x0a
    256e:	fb 85       	ldd	r31, Y+11	; 0x0b
    2570:	81 e0       	ldi	r24, 0x01	; 1
    2572:	80 83       	st	Z, r24
    2574:	05 c0       	rjmp	.+10     	; 0x2580 <xQueueGenericSendFromISR+0x94>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    2576:	89 81       	ldd	r24, Y+1	; 0x01
    2578:	8f 5f       	subi	r24, 0xFF	; 255
    257a:	ea 81       	ldd	r30, Y+2	; 0x02
    257c:	fb 81       	ldd	r31, Y+3	; 0x03
    257e:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    2580:	81 e0       	ldi	r24, 0x01	; 1
    2582:	8d 83       	std	Y+5, r24	; 0x05
    2584:	01 c0       	rjmp	.+2      	; 0x2588 <xQueueGenericSendFromISR+0x9c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2586:	1d 82       	std	Y+5, r1	; 0x05
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2588:	8d 81       	ldd	r24, Y+5	; 0x05
}
    258a:	2c 96       	adiw	r28, 0x0c	; 12
    258c:	0f b6       	in	r0, 0x3f	; 63
    258e:	f8 94       	cli
    2590:	de bf       	out	0x3e, r29	; 62
    2592:	0f be       	out	0x3f, r0	; 63
    2594:	cd bf       	out	0x3d, r28	; 61
    2596:	cf 91       	pop	r28
    2598:	df 91       	pop	r29
    259a:	08 95       	ret

0000259c <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    259c:	df 93       	push	r29
    259e:	cf 93       	push	r28
    25a0:	cd b7       	in	r28, 0x3d	; 61
    25a2:	de b7       	in	r29, 0x3e	; 62
    25a4:	2a 97       	sbiw	r28, 0x0a	; 10
    25a6:	0f b6       	in	r0, 0x3f	; 63
    25a8:	f8 94       	cli
    25aa:	de bf       	out	0x3e, r29	; 62
    25ac:	0f be       	out	0x3f, r0	; 63
    25ae:	cd bf       	out	0x3d, r28	; 61
    25b0:	98 87       	std	Y+8, r25	; 0x08
    25b2:	8f 83       	std	Y+7, r24	; 0x07
    25b4:	7a 87       	std	Y+10, r23	; 0x0a
    25b6:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    25b8:	8f 81       	ldd	r24, Y+7	; 0x07
    25ba:	98 85       	ldd	r25, Y+8	; 0x08
    25bc:	9c 83       	std	Y+4, r25	; 0x04
    25be:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    25c0:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    25c2:	eb 81       	ldd	r30, Y+3	; 0x03
    25c4:	fc 81       	ldd	r31, Y+4	; 0x04
    25c6:	82 8d       	ldd	r24, Z+26	; 0x1a
    25c8:	8a 83       	std	Y+2, r24	; 0x02

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    25ca:	eb 81       	ldd	r30, Y+3	; 0x03
    25cc:	fc 81       	ldd	r31, Y+4	; 0x04
    25ce:	93 8d       	ldd	r25, Z+27	; 0x1b
    25d0:	8a 81       	ldd	r24, Y+2	; 0x02
    25d2:	89 17       	cp	r24, r25
    25d4:	48 f5       	brcc	.+82     	; 0x2628 <xQueueGiveFromISR+0x8c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    25d6:	eb 81       	ldd	r30, Y+3	; 0x03
    25d8:	fc 81       	ldd	r31, Y+4	; 0x04
    25da:	86 8d       	ldd	r24, Z+30	; 0x1e
    25dc:	89 83       	std	Y+1, r24	; 0x01
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    25de:	8a 81       	ldd	r24, Y+2	; 0x02
    25e0:	8f 5f       	subi	r24, 0xFF	; 255
    25e2:	eb 81       	ldd	r30, Y+3	; 0x03
    25e4:	fc 81       	ldd	r31, Y+4	; 0x04
    25e6:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    25e8:	89 81       	ldd	r24, Y+1	; 0x01
    25ea:	8f 3f       	cpi	r24, 0xFF	; 255
    25ec:	a9 f4       	brne	.+42     	; 0x2618 <xQueueGiveFromISR+0x7c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    25ee:	eb 81       	ldd	r30, Y+3	; 0x03
    25f0:	fc 81       	ldd	r31, Y+4	; 0x04
    25f2:	81 89       	ldd	r24, Z+17	; 0x11
    25f4:	88 23       	and	r24, r24
    25f6:	a9 f0       	breq	.+42     	; 0x2622 <xQueueGiveFromISR+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    25f8:	8b 81       	ldd	r24, Y+3	; 0x03
    25fa:	9c 81       	ldd	r25, Y+4	; 0x04
    25fc:	41 96       	adiw	r24, 0x11	; 17
    25fe:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <xTaskRemoveFromEventList>
    2602:	88 23       	and	r24, r24
    2604:	71 f0       	breq	.+28     	; 0x2622 <xQueueGiveFromISR+0x86>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    2606:	89 85       	ldd	r24, Y+9	; 0x09
    2608:	9a 85       	ldd	r25, Y+10	; 0x0a
    260a:	00 97       	sbiw	r24, 0x00	; 0
    260c:	51 f0       	breq	.+20     	; 0x2622 <xQueueGiveFromISR+0x86>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    260e:	e9 85       	ldd	r30, Y+9	; 0x09
    2610:	fa 85       	ldd	r31, Y+10	; 0x0a
    2612:	81 e0       	ldi	r24, 0x01	; 1
    2614:	80 83       	st	Z, r24
    2616:	05 c0       	rjmp	.+10     	; 0x2622 <xQueueGiveFromISR+0x86>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    2618:	89 81       	ldd	r24, Y+1	; 0x01
    261a:	8f 5f       	subi	r24, 0xFF	; 255
    261c:	eb 81       	ldd	r30, Y+3	; 0x03
    261e:	fc 81       	ldd	r31, Y+4	; 0x04
    2620:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    2622:	81 e0       	ldi	r24, 0x01	; 1
    2624:	8e 83       	std	Y+6, r24	; 0x06
    2626:	01 c0       	rjmp	.+2      	; 0x262a <xQueueGiveFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2628:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    262a:	8e 81       	ldd	r24, Y+6	; 0x06
}
    262c:	2a 96       	adiw	r28, 0x0a	; 10
    262e:	0f b6       	in	r0, 0x3f	; 63
    2630:	f8 94       	cli
    2632:	de bf       	out	0x3e, r29	; 62
    2634:	0f be       	out	0x3f, r0	; 63
    2636:	cd bf       	out	0x3d, r28	; 61
    2638:	cf 91       	pop	r28
    263a:	df 91       	pop	r29
    263c:	08 95       	ret

0000263e <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    263e:	df 93       	push	r29
    2640:	cf 93       	push	r28
    2642:	cd b7       	in	r28, 0x3d	; 61
    2644:	de b7       	in	r29, 0x3e	; 62
    2646:	2e 97       	sbiw	r28, 0x0e	; 14
    2648:	0f b6       	in	r0, 0x3f	; 63
    264a:	f8 94       	cli
    264c:	de bf       	out	0x3e, r29	; 62
    264e:	0f be       	out	0x3f, r0	; 63
    2650:	cd bf       	out	0x3d, r28	; 61
    2652:	99 87       	std	Y+9, r25	; 0x09
    2654:	88 87       	std	Y+8, r24	; 0x08
    2656:	7b 87       	std	Y+11, r23	; 0x0b
    2658:	6a 87       	std	Y+10, r22	; 0x0a
    265a:	5d 87       	std	Y+13, r21	; 0x0d
    265c:	4c 87       	std	Y+12, r20	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    265e:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    2660:	88 85       	ldd	r24, Y+8	; 0x08
    2662:	99 85       	ldd	r25, Y+9	; 0x09
    2664:	9b 83       	std	Y+3, r25	; 0x03
    2666:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2668:	0f b6       	in	r0, 0x3f	; 63
    266a:	f8 94       	cli
    266c:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    266e:	ea 81       	ldd	r30, Y+2	; 0x02
    2670:	fb 81       	ldd	r31, Y+3	; 0x03
    2672:	82 8d       	ldd	r24, Z+26	; 0x1a
    2674:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2676:	89 81       	ldd	r24, Y+1	; 0x01
    2678:	88 23       	and	r24, r24
    267a:	d9 f0       	breq	.+54     	; 0x26b2 <xQueueReceive+0x74>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    267c:	8a 81       	ldd	r24, Y+2	; 0x02
    267e:	9b 81       	ldd	r25, Y+3	; 0x03
    2680:	2a 85       	ldd	r18, Y+10	; 0x0a
    2682:	3b 85       	ldd	r19, Y+11	; 0x0b
    2684:	b9 01       	movw	r22, r18
    2686:	0e 94 b6 16 	call	0x2d6c	; 0x2d6c <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    268a:	89 81       	ldd	r24, Y+1	; 0x01
    268c:	81 50       	subi	r24, 0x01	; 1
    268e:	ea 81       	ldd	r30, Y+2	; 0x02
    2690:	fb 81       	ldd	r31, Y+3	; 0x03
    2692:	82 8f       	std	Z+26, r24	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2694:	ea 81       	ldd	r30, Y+2	; 0x02
    2696:	fb 81       	ldd	r31, Y+3	; 0x03
    2698:	80 85       	ldd	r24, Z+8	; 0x08
    269a:	88 23       	and	r24, r24
    269c:	29 f0       	breq	.+10     	; 0x26a8 <xQueueReceive+0x6a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    269e:	8a 81       	ldd	r24, Y+2	; 0x02
    26a0:	9b 81       	ldd	r25, Y+3	; 0x03
    26a2:	08 96       	adiw	r24, 0x08	; 8
    26a4:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <xTaskRemoveFromEventList>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    26a8:	0f 90       	pop	r0
    26aa:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    26ac:	81 e0       	ldi	r24, 0x01	; 1
    26ae:	8e 87       	std	Y+14, r24	; 0x0e
    26b0:	63 c0       	rjmp	.+198    	; 0x2778 <xQueueReceive+0x13a>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    26b2:	8c 85       	ldd	r24, Y+12	; 0x0c
    26b4:	9d 85       	ldd	r25, Y+13	; 0x0d
    26b6:	00 97       	sbiw	r24, 0x00	; 0
    26b8:	21 f4       	brne	.+8      	; 0x26c2 <xQueueReceive+0x84>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    26ba:	0f 90       	pop	r0
    26bc:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    26be:	1e 86       	std	Y+14, r1	; 0x0e
    26c0:	5b c0       	rjmp	.+182    	; 0x2778 <xQueueReceive+0x13a>
				}
				else if( xEntryTimeSet == pdFALSE )
    26c2:	8c 81       	ldd	r24, Y+4	; 0x04
    26c4:	88 23       	and	r24, r24
    26c6:	31 f4       	brne	.+12     	; 0x26d4 <xQueueReceive+0x96>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    26c8:	ce 01       	movw	r24, r28
    26ca:	05 96       	adiw	r24, 0x05	; 5
    26cc:	0e 94 99 26 	call	0x4d32	; 0x4d32 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    26d0:	81 e0       	ldi	r24, 0x01	; 1
    26d2:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    26d4:	0f 90       	pop	r0
    26d6:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    26d8:	0e 94 43 23 	call	0x4686	; 0x4686 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    26dc:	0f b6       	in	r0, 0x3f	; 63
    26de:	f8 94       	cli
    26e0:	0f 92       	push	r0
    26e2:	ea 81       	ldd	r30, Y+2	; 0x02
    26e4:	fb 81       	ldd	r31, Y+3	; 0x03
    26e6:	85 8d       	ldd	r24, Z+29	; 0x1d
    26e8:	8f 3f       	cpi	r24, 0xFF	; 255
    26ea:	19 f4       	brne	.+6      	; 0x26f2 <xQueueReceive+0xb4>
    26ec:	ea 81       	ldd	r30, Y+2	; 0x02
    26ee:	fb 81       	ldd	r31, Y+3	; 0x03
    26f0:	15 8e       	std	Z+29, r1	; 0x1d
    26f2:	ea 81       	ldd	r30, Y+2	; 0x02
    26f4:	fb 81       	ldd	r31, Y+3	; 0x03
    26f6:	86 8d       	ldd	r24, Z+30	; 0x1e
    26f8:	8f 3f       	cpi	r24, 0xFF	; 255
    26fa:	19 f4       	brne	.+6      	; 0x2702 <xQueueReceive+0xc4>
    26fc:	ea 81       	ldd	r30, Y+2	; 0x02
    26fe:	fb 81       	ldd	r31, Y+3	; 0x03
    2700:	16 8e       	std	Z+30, r1	; 0x1e
    2702:	0f 90       	pop	r0
    2704:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2706:	ce 01       	movw	r24, r28
    2708:	05 96       	adiw	r24, 0x05	; 5
    270a:	9e 01       	movw	r18, r28
    270c:	24 5f       	subi	r18, 0xF4	; 244
    270e:	3f 4f       	sbci	r19, 0xFF	; 255
    2710:	b9 01       	movw	r22, r18
    2712:	0e 94 b2 26 	call	0x4d64	; 0x4d64 <xTaskCheckForTimeOut>
    2716:	88 23       	and	r24, r24
    2718:	09 f5       	brne	.+66     	; 0x275c <xQueueReceive+0x11e>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    271a:	8a 81       	ldd	r24, Y+2	; 0x02
    271c:	9b 81       	ldd	r25, Y+3	; 0x03
    271e:	0e 94 50 17 	call	0x2ea0	; 0x2ea0 <prvIsQueueEmpty>
    2722:	88 23       	and	r24, r24
    2724:	a1 f0       	breq	.+40     	; 0x274e <xQueueReceive+0x110>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2726:	8a 81       	ldd	r24, Y+2	; 0x02
    2728:	9b 81       	ldd	r25, Y+3	; 0x03
    272a:	41 96       	adiw	r24, 0x11	; 17
    272c:	2c 85       	ldd	r18, Y+12	; 0x0c
    272e:	3d 85       	ldd	r19, Y+13	; 0x0d
    2730:	b9 01       	movw	r22, r18
    2732:	0e 94 61 25 	call	0x4ac2	; 0x4ac2 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2736:	8a 81       	ldd	r24, Y+2	; 0x02
    2738:	9b 81       	ldd	r25, Y+3	; 0x03
    273a:	0e 94 fd 16 	call	0x2dfa	; 0x2dfa <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    273e:	0e 94 4f 23 	call	0x469e	; 0x469e <xTaskResumeAll>
    2742:	88 23       	and	r24, r24
    2744:	09 f0       	breq	.+2      	; 0x2748 <xQueueReceive+0x10a>
    2746:	90 cf       	rjmp	.-224    	; 0x2668 <xQueueReceive+0x2a>
				{
					portYIELD_WITHIN_API();
    2748:	0e 94 8a 0f 	call	0x1f14	; 0x1f14 <vPortYield>
    274c:	8d cf       	rjmp	.-230    	; 0x2668 <xQueueReceive+0x2a>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    274e:	8a 81       	ldd	r24, Y+2	; 0x02
    2750:	9b 81       	ldd	r25, Y+3	; 0x03
    2752:	0e 94 fd 16 	call	0x2dfa	; 0x2dfa <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2756:	0e 94 4f 23 	call	0x469e	; 0x469e <xTaskResumeAll>
    275a:	86 cf       	rjmp	.-244    	; 0x2668 <xQueueReceive+0x2a>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    275c:	8a 81       	ldd	r24, Y+2	; 0x02
    275e:	9b 81       	ldd	r25, Y+3	; 0x03
    2760:	0e 94 fd 16 	call	0x2dfa	; 0x2dfa <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2764:	0e 94 4f 23 	call	0x469e	; 0x469e <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2768:	8a 81       	ldd	r24, Y+2	; 0x02
    276a:	9b 81       	ldd	r25, Y+3	; 0x03
    276c:	0e 94 50 17 	call	0x2ea0	; 0x2ea0 <prvIsQueueEmpty>
    2770:	88 23       	and	r24, r24
    2772:	09 f4       	brne	.+2      	; 0x2776 <xQueueReceive+0x138>
    2774:	79 cf       	rjmp	.-270    	; 0x2668 <xQueueReceive+0x2a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    2776:	1e 86       	std	Y+14, r1	; 0x0e
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    2778:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    277a:	2e 96       	adiw	r28, 0x0e	; 14
    277c:	0f b6       	in	r0, 0x3f	; 63
    277e:	f8 94       	cli
    2780:	de bf       	out	0x3e, r29	; 62
    2782:	0f be       	out	0x3f, r0	; 63
    2784:	cd bf       	out	0x3d, r28	; 61
    2786:	cf 91       	pop	r28
    2788:	df 91       	pop	r29
    278a:	08 95       	ret

0000278c <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    278c:	df 93       	push	r29
    278e:	cf 93       	push	r28
    2790:	cd b7       	in	r28, 0x3d	; 61
    2792:	de b7       	in	r29, 0x3e	; 62
    2794:	2c 97       	sbiw	r28, 0x0c	; 12
    2796:	0f b6       	in	r0, 0x3f	; 63
    2798:	f8 94       	cli
    279a:	de bf       	out	0x3e, r29	; 62
    279c:	0f be       	out	0x3f, r0	; 63
    279e:	cd bf       	out	0x3d, r28	; 61
    27a0:	99 87       	std	Y+9, r25	; 0x09
    27a2:	88 87       	std	Y+8, r24	; 0x08
    27a4:	7b 87       	std	Y+11, r23	; 0x0b
    27a6:	6a 87       	std	Y+10, r22	; 0x0a
BaseType_t xEntryTimeSet = pdFALSE;
    27a8:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    27aa:	88 85       	ldd	r24, Y+8	; 0x08
    27ac:	99 85       	ldd	r25, Y+9	; 0x09
    27ae:	9b 83       	std	Y+3, r25	; 0x03
    27b0:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    27b2:	0f b6       	in	r0, 0x3f	; 63
    27b4:	f8 94       	cli
    27b6:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    27b8:	ea 81       	ldd	r30, Y+2	; 0x02
    27ba:	fb 81       	ldd	r31, Y+3	; 0x03
    27bc:	82 8d       	ldd	r24, Z+26	; 0x1a
    27be:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    27c0:	89 81       	ldd	r24, Y+1	; 0x01
    27c2:	88 23       	and	r24, r24
    27c4:	a1 f0       	breq	.+40     	; 0x27ee <xQueueSemaphoreTake+0x62>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    27c6:	89 81       	ldd	r24, Y+1	; 0x01
    27c8:	81 50       	subi	r24, 0x01	; 1
    27ca:	ea 81       	ldd	r30, Y+2	; 0x02
    27cc:	fb 81       	ldd	r31, Y+3	; 0x03
    27ce:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    27d0:	ea 81       	ldd	r30, Y+2	; 0x02
    27d2:	fb 81       	ldd	r31, Y+3	; 0x03
    27d4:	80 85       	ldd	r24, Z+8	; 0x08
    27d6:	88 23       	and	r24, r24
    27d8:	29 f0       	breq	.+10     	; 0x27e4 <xQueueSemaphoreTake+0x58>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    27da:	8a 81       	ldd	r24, Y+2	; 0x02
    27dc:	9b 81       	ldd	r25, Y+3	; 0x03
    27de:	08 96       	adiw	r24, 0x08	; 8
    27e0:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <xTaskRemoveFromEventList>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    27e4:	0f 90       	pop	r0
    27e6:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    27e8:	81 e0       	ldi	r24, 0x01	; 1
    27ea:	8c 87       	std	Y+12, r24	; 0x0c
    27ec:	63 c0       	rjmp	.+198    	; 0x28b4 <xQueueSemaphoreTake+0x128>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    27ee:	8a 85       	ldd	r24, Y+10	; 0x0a
    27f0:	9b 85       	ldd	r25, Y+11	; 0x0b
    27f2:	00 97       	sbiw	r24, 0x00	; 0
    27f4:	21 f4       	brne	.+8      	; 0x27fe <xQueueSemaphoreTake+0x72>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    27f6:	0f 90       	pop	r0
    27f8:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    27fa:	1c 86       	std	Y+12, r1	; 0x0c
    27fc:	5b c0       	rjmp	.+182    	; 0x28b4 <xQueueSemaphoreTake+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    27fe:	8c 81       	ldd	r24, Y+4	; 0x04
    2800:	88 23       	and	r24, r24
    2802:	31 f4       	brne	.+12     	; 0x2810 <xQueueSemaphoreTake+0x84>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    2804:	ce 01       	movw	r24, r28
    2806:	05 96       	adiw	r24, 0x05	; 5
    2808:	0e 94 99 26 	call	0x4d32	; 0x4d32 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    280c:	81 e0       	ldi	r24, 0x01	; 1
    280e:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2810:	0f 90       	pop	r0
    2812:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    2814:	0e 94 43 23 	call	0x4686	; 0x4686 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2818:	0f b6       	in	r0, 0x3f	; 63
    281a:	f8 94       	cli
    281c:	0f 92       	push	r0
    281e:	ea 81       	ldd	r30, Y+2	; 0x02
    2820:	fb 81       	ldd	r31, Y+3	; 0x03
    2822:	85 8d       	ldd	r24, Z+29	; 0x1d
    2824:	8f 3f       	cpi	r24, 0xFF	; 255
    2826:	19 f4       	brne	.+6      	; 0x282e <xQueueSemaphoreTake+0xa2>
    2828:	ea 81       	ldd	r30, Y+2	; 0x02
    282a:	fb 81       	ldd	r31, Y+3	; 0x03
    282c:	15 8e       	std	Z+29, r1	; 0x1d
    282e:	ea 81       	ldd	r30, Y+2	; 0x02
    2830:	fb 81       	ldd	r31, Y+3	; 0x03
    2832:	86 8d       	ldd	r24, Z+30	; 0x1e
    2834:	8f 3f       	cpi	r24, 0xFF	; 255
    2836:	19 f4       	brne	.+6      	; 0x283e <xQueueSemaphoreTake+0xb2>
    2838:	ea 81       	ldd	r30, Y+2	; 0x02
    283a:	fb 81       	ldd	r31, Y+3	; 0x03
    283c:	16 8e       	std	Z+30, r1	; 0x1e
    283e:	0f 90       	pop	r0
    2840:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2842:	ce 01       	movw	r24, r28
    2844:	05 96       	adiw	r24, 0x05	; 5
    2846:	9e 01       	movw	r18, r28
    2848:	26 5f       	subi	r18, 0xF6	; 246
    284a:	3f 4f       	sbci	r19, 0xFF	; 255
    284c:	b9 01       	movw	r22, r18
    284e:	0e 94 b2 26 	call	0x4d64	; 0x4d64 <xTaskCheckForTimeOut>
    2852:	88 23       	and	r24, r24
    2854:	09 f5       	brne	.+66     	; 0x2898 <xQueueSemaphoreTake+0x10c>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2856:	8a 81       	ldd	r24, Y+2	; 0x02
    2858:	9b 81       	ldd	r25, Y+3	; 0x03
    285a:	0e 94 50 17 	call	0x2ea0	; 0x2ea0 <prvIsQueueEmpty>
    285e:	88 23       	and	r24, r24
    2860:	a1 f0       	breq	.+40     	; 0x288a <xQueueSemaphoreTake+0xfe>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2862:	8a 81       	ldd	r24, Y+2	; 0x02
    2864:	9b 81       	ldd	r25, Y+3	; 0x03
    2866:	41 96       	adiw	r24, 0x11	; 17
    2868:	2a 85       	ldd	r18, Y+10	; 0x0a
    286a:	3b 85       	ldd	r19, Y+11	; 0x0b
    286c:	b9 01       	movw	r22, r18
    286e:	0e 94 61 25 	call	0x4ac2	; 0x4ac2 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2872:	8a 81       	ldd	r24, Y+2	; 0x02
    2874:	9b 81       	ldd	r25, Y+3	; 0x03
    2876:	0e 94 fd 16 	call	0x2dfa	; 0x2dfa <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    287a:	0e 94 4f 23 	call	0x469e	; 0x469e <xTaskResumeAll>
    287e:	88 23       	and	r24, r24
    2880:	09 f0       	breq	.+2      	; 0x2884 <xQueueSemaphoreTake+0xf8>
    2882:	97 cf       	rjmp	.-210    	; 0x27b2 <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    2884:	0e 94 8a 0f 	call	0x1f14	; 0x1f14 <vPortYield>
    2888:	94 cf       	rjmp	.-216    	; 0x27b2 <xQueueSemaphoreTake+0x26>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    288a:	8a 81       	ldd	r24, Y+2	; 0x02
    288c:	9b 81       	ldd	r25, Y+3	; 0x03
    288e:	0e 94 fd 16 	call	0x2dfa	; 0x2dfa <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2892:	0e 94 4f 23 	call	0x469e	; 0x469e <xTaskResumeAll>
    2896:	8d cf       	rjmp	.-230    	; 0x27b2 <xQueueSemaphoreTake+0x26>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    2898:	8a 81       	ldd	r24, Y+2	; 0x02
    289a:	9b 81       	ldd	r25, Y+3	; 0x03
    289c:	0e 94 fd 16 	call	0x2dfa	; 0x2dfa <prvUnlockQueue>
			( void ) xTaskResumeAll();
    28a0:	0e 94 4f 23 	call	0x469e	; 0x469e <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    28a4:	8a 81       	ldd	r24, Y+2	; 0x02
    28a6:	9b 81       	ldd	r25, Y+3	; 0x03
    28a8:	0e 94 50 17 	call	0x2ea0	; 0x2ea0 <prvIsQueueEmpty>
    28ac:	88 23       	and	r24, r24
    28ae:	09 f4       	brne	.+2      	; 0x28b2 <xQueueSemaphoreTake+0x126>
    28b0:	80 cf       	rjmp	.-256    	; 0x27b2 <xQueueSemaphoreTake+0x26>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    28b2:	1c 86       	std	Y+12, r1	; 0x0c
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    28b4:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    28b6:	2c 96       	adiw	r28, 0x0c	; 12
    28b8:	0f b6       	in	r0, 0x3f	; 63
    28ba:	f8 94       	cli
    28bc:	de bf       	out	0x3e, r29	; 62
    28be:	0f be       	out	0x3f, r0	; 63
    28c0:	cd bf       	out	0x3d, r28	; 61
    28c2:	cf 91       	pop	r28
    28c4:	df 91       	pop	r29
    28c6:	08 95       	ret

000028c8 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    28c8:	df 93       	push	r29
    28ca:	cf 93       	push	r28
    28cc:	cd b7       	in	r28, 0x3d	; 61
    28ce:	de b7       	in	r29, 0x3e	; 62
    28d0:	60 97       	sbiw	r28, 0x10	; 16
    28d2:	0f b6       	in	r0, 0x3f	; 63
    28d4:	f8 94       	cli
    28d6:	de bf       	out	0x3e, r29	; 62
    28d8:	0f be       	out	0x3f, r0	; 63
    28da:	cd bf       	out	0x3d, r28	; 61
    28dc:	9b 87       	std	Y+11, r25	; 0x0b
    28de:	8a 87       	std	Y+10, r24	; 0x0a
    28e0:	7d 87       	std	Y+13, r23	; 0x0d
    28e2:	6c 87       	std	Y+12, r22	; 0x0c
    28e4:	5f 87       	std	Y+15, r21	; 0x0f
    28e6:	4e 87       	std	Y+14, r20	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE;
    28e8:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    28ea:	8a 85       	ldd	r24, Y+10	; 0x0a
    28ec:	9b 85       	ldd	r25, Y+11	; 0x0b
    28ee:	9b 83       	std	Y+3, r25	; 0x03
    28f0:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    28f2:	0f b6       	in	r0, 0x3f	; 63
    28f4:	f8 94       	cli
    28f6:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    28f8:	ea 81       	ldd	r30, Y+2	; 0x02
    28fa:	fb 81       	ldd	r31, Y+3	; 0x03
    28fc:	82 8d       	ldd	r24, Z+26	; 0x1a
    28fe:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2900:	89 81       	ldd	r24, Y+1	; 0x01
    2902:	88 23       	and	r24, r24
    2904:	11 f1       	breq	.+68     	; 0x294a <xQueuePeek+0x82>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    2906:	ea 81       	ldd	r30, Y+2	; 0x02
    2908:	fb 81       	ldd	r31, Y+3	; 0x03
    290a:	86 81       	ldd	r24, Z+6	; 0x06
    290c:	97 81       	ldd	r25, Z+7	; 0x07
    290e:	9d 83       	std	Y+5, r25	; 0x05
    2910:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    2912:	8a 81       	ldd	r24, Y+2	; 0x02
    2914:	9b 81       	ldd	r25, Y+3	; 0x03
    2916:	2c 85       	ldd	r18, Y+12	; 0x0c
    2918:	3d 85       	ldd	r19, Y+13	; 0x0d
    291a:	b9 01       	movw	r22, r18
    291c:	0e 94 b6 16 	call	0x2d6c	; 0x2d6c <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2920:	ea 81       	ldd	r30, Y+2	; 0x02
    2922:	fb 81       	ldd	r31, Y+3	; 0x03
    2924:	8c 81       	ldd	r24, Y+4	; 0x04
    2926:	9d 81       	ldd	r25, Y+5	; 0x05
    2928:	97 83       	std	Z+7, r25	; 0x07
    292a:	86 83       	std	Z+6, r24	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    292c:	ea 81       	ldd	r30, Y+2	; 0x02
    292e:	fb 81       	ldd	r31, Y+3	; 0x03
    2930:	81 89       	ldd	r24, Z+17	; 0x11
    2932:	88 23       	and	r24, r24
    2934:	29 f0       	breq	.+10     	; 0x2940 <xQueuePeek+0x78>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2936:	8a 81       	ldd	r24, Y+2	; 0x02
    2938:	9b 81       	ldd	r25, Y+3	; 0x03
    293a:	41 96       	adiw	r24, 0x11	; 17
    293c:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <xTaskRemoveFromEventList>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    2940:	0f 90       	pop	r0
    2942:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2944:	81 e0       	ldi	r24, 0x01	; 1
    2946:	88 8b       	std	Y+16, r24	; 0x10
    2948:	63 c0       	rjmp	.+198    	; 0x2a10 <xQueuePeek+0x148>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    294a:	8e 85       	ldd	r24, Y+14	; 0x0e
    294c:	9f 85       	ldd	r25, Y+15	; 0x0f
    294e:	00 97       	sbiw	r24, 0x00	; 0
    2950:	21 f4       	brne	.+8      	; 0x295a <xQueuePeek+0x92>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2952:	0f 90       	pop	r0
    2954:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2956:	18 8a       	std	Y+16, r1	; 0x10
    2958:	5b c0       	rjmp	.+182    	; 0x2a10 <xQueuePeek+0x148>
				}
				else if( xEntryTimeSet == pdFALSE )
    295a:	8e 81       	ldd	r24, Y+6	; 0x06
    295c:	88 23       	and	r24, r24
    295e:	31 f4       	brne	.+12     	; 0x296c <xQueuePeek+0xa4>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    2960:	ce 01       	movw	r24, r28
    2962:	07 96       	adiw	r24, 0x07	; 7
    2964:	0e 94 99 26 	call	0x4d32	; 0x4d32 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2968:	81 e0       	ldi	r24, 0x01	; 1
    296a:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    296c:	0f 90       	pop	r0
    296e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2970:	0e 94 43 23 	call	0x4686	; 0x4686 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2974:	0f b6       	in	r0, 0x3f	; 63
    2976:	f8 94       	cli
    2978:	0f 92       	push	r0
    297a:	ea 81       	ldd	r30, Y+2	; 0x02
    297c:	fb 81       	ldd	r31, Y+3	; 0x03
    297e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2980:	8f 3f       	cpi	r24, 0xFF	; 255
    2982:	19 f4       	brne	.+6      	; 0x298a <xQueuePeek+0xc2>
    2984:	ea 81       	ldd	r30, Y+2	; 0x02
    2986:	fb 81       	ldd	r31, Y+3	; 0x03
    2988:	15 8e       	std	Z+29, r1	; 0x1d
    298a:	ea 81       	ldd	r30, Y+2	; 0x02
    298c:	fb 81       	ldd	r31, Y+3	; 0x03
    298e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2990:	8f 3f       	cpi	r24, 0xFF	; 255
    2992:	19 f4       	brne	.+6      	; 0x299a <xQueuePeek+0xd2>
    2994:	ea 81       	ldd	r30, Y+2	; 0x02
    2996:	fb 81       	ldd	r31, Y+3	; 0x03
    2998:	16 8e       	std	Z+30, r1	; 0x1e
    299a:	0f 90       	pop	r0
    299c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    299e:	ce 01       	movw	r24, r28
    29a0:	07 96       	adiw	r24, 0x07	; 7
    29a2:	9e 01       	movw	r18, r28
    29a4:	22 5f       	subi	r18, 0xF2	; 242
    29a6:	3f 4f       	sbci	r19, 0xFF	; 255
    29a8:	b9 01       	movw	r22, r18
    29aa:	0e 94 b2 26 	call	0x4d64	; 0x4d64 <xTaskCheckForTimeOut>
    29ae:	88 23       	and	r24, r24
    29b0:	09 f5       	brne	.+66     	; 0x29f4 <xQueuePeek+0x12c>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    29b2:	8a 81       	ldd	r24, Y+2	; 0x02
    29b4:	9b 81       	ldd	r25, Y+3	; 0x03
    29b6:	0e 94 50 17 	call	0x2ea0	; 0x2ea0 <prvIsQueueEmpty>
    29ba:	88 23       	and	r24, r24
    29bc:	a1 f0       	breq	.+40     	; 0x29e6 <xQueuePeek+0x11e>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    29be:	8a 81       	ldd	r24, Y+2	; 0x02
    29c0:	9b 81       	ldd	r25, Y+3	; 0x03
    29c2:	41 96       	adiw	r24, 0x11	; 17
    29c4:	2e 85       	ldd	r18, Y+14	; 0x0e
    29c6:	3f 85       	ldd	r19, Y+15	; 0x0f
    29c8:	b9 01       	movw	r22, r18
    29ca:	0e 94 61 25 	call	0x4ac2	; 0x4ac2 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    29ce:	8a 81       	ldd	r24, Y+2	; 0x02
    29d0:	9b 81       	ldd	r25, Y+3	; 0x03
    29d2:	0e 94 fd 16 	call	0x2dfa	; 0x2dfa <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    29d6:	0e 94 4f 23 	call	0x469e	; 0x469e <xTaskResumeAll>
    29da:	88 23       	and	r24, r24
    29dc:	09 f0       	breq	.+2      	; 0x29e0 <xQueuePeek+0x118>
    29de:	89 cf       	rjmp	.-238    	; 0x28f2 <xQueuePeek+0x2a>
				{
					portYIELD_WITHIN_API();
    29e0:	0e 94 8a 0f 	call	0x1f14	; 0x1f14 <vPortYield>
    29e4:	86 cf       	rjmp	.-244    	; 0x28f2 <xQueuePeek+0x2a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    29e6:	8a 81       	ldd	r24, Y+2	; 0x02
    29e8:	9b 81       	ldd	r25, Y+3	; 0x03
    29ea:	0e 94 fd 16 	call	0x2dfa	; 0x2dfa <prvUnlockQueue>
				( void ) xTaskResumeAll();
    29ee:	0e 94 4f 23 	call	0x469e	; 0x469e <xTaskResumeAll>
    29f2:	7f cf       	rjmp	.-258    	; 0x28f2 <xQueuePeek+0x2a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    29f4:	8a 81       	ldd	r24, Y+2	; 0x02
    29f6:	9b 81       	ldd	r25, Y+3	; 0x03
    29f8:	0e 94 fd 16 	call	0x2dfa	; 0x2dfa <prvUnlockQueue>
			( void ) xTaskResumeAll();
    29fc:	0e 94 4f 23 	call	0x469e	; 0x469e <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2a00:	8a 81       	ldd	r24, Y+2	; 0x02
    2a02:	9b 81       	ldd	r25, Y+3	; 0x03
    2a04:	0e 94 50 17 	call	0x2ea0	; 0x2ea0 <prvIsQueueEmpty>
    2a08:	88 23       	and	r24, r24
    2a0a:	09 f4       	brne	.+2      	; 0x2a0e <xQueuePeek+0x146>
    2a0c:	72 cf       	rjmp	.-284    	; 0x28f2 <xQueuePeek+0x2a>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    2a0e:	18 8a       	std	Y+16, r1	; 0x10
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    2a10:	88 89       	ldd	r24, Y+16	; 0x10
}
    2a12:	60 96       	adiw	r28, 0x10	; 16
    2a14:	0f b6       	in	r0, 0x3f	; 63
    2a16:	f8 94       	cli
    2a18:	de bf       	out	0x3e, r29	; 62
    2a1a:	0f be       	out	0x3f, r0	; 63
    2a1c:	cd bf       	out	0x3d, r28	; 61
    2a1e:	cf 91       	pop	r28
    2a20:	df 91       	pop	r29
    2a22:	08 95       	ret

00002a24 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    2a24:	df 93       	push	r29
    2a26:	cf 93       	push	r28
    2a28:	cd b7       	in	r28, 0x3d	; 61
    2a2a:	de b7       	in	r29, 0x3e	; 62
    2a2c:	2c 97       	sbiw	r28, 0x0c	; 12
    2a2e:	0f b6       	in	r0, 0x3f	; 63
    2a30:	f8 94       	cli
    2a32:	de bf       	out	0x3e, r29	; 62
    2a34:	0f be       	out	0x3f, r0	; 63
    2a36:	cd bf       	out	0x3d, r28	; 61
    2a38:	98 87       	std	Y+8, r25	; 0x08
    2a3a:	8f 83       	std	Y+7, r24	; 0x07
    2a3c:	7a 87       	std	Y+10, r23	; 0x0a
    2a3e:	69 87       	std	Y+9, r22	; 0x09
    2a40:	5c 87       	std	Y+12, r21	; 0x0c
    2a42:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    2a44:	8f 81       	ldd	r24, Y+7	; 0x07
    2a46:	98 85       	ldd	r25, Y+8	; 0x08
    2a48:	9c 83       	std	Y+4, r25	; 0x04
    2a4a:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2a4c:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2a4e:	eb 81       	ldd	r30, Y+3	; 0x03
    2a50:	fc 81       	ldd	r31, Y+4	; 0x04
    2a52:	82 8d       	ldd	r24, Z+26	; 0x1a
    2a54:	8a 83       	std	Y+2, r24	; 0x02

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2a56:	8a 81       	ldd	r24, Y+2	; 0x02
    2a58:	88 23       	and	r24, r24
    2a5a:	81 f1       	breq	.+96     	; 0x2abc <xQueueReceiveFromISR+0x98>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    2a5c:	eb 81       	ldd	r30, Y+3	; 0x03
    2a5e:	fc 81       	ldd	r31, Y+4	; 0x04
    2a60:	85 8d       	ldd	r24, Z+29	; 0x1d
    2a62:	89 83       	std	Y+1, r24	; 0x01

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2a64:	8b 81       	ldd	r24, Y+3	; 0x03
    2a66:	9c 81       	ldd	r25, Y+4	; 0x04
    2a68:	29 85       	ldd	r18, Y+9	; 0x09
    2a6a:	3a 85       	ldd	r19, Y+10	; 0x0a
    2a6c:	b9 01       	movw	r22, r18
    2a6e:	0e 94 b6 16 	call	0x2d6c	; 0x2d6c <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    2a72:	8a 81       	ldd	r24, Y+2	; 0x02
    2a74:	81 50       	subi	r24, 0x01	; 1
    2a76:	eb 81       	ldd	r30, Y+3	; 0x03
    2a78:	fc 81       	ldd	r31, Y+4	; 0x04
    2a7a:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    2a7c:	89 81       	ldd	r24, Y+1	; 0x01
    2a7e:	8f 3f       	cpi	r24, 0xFF	; 255
    2a80:	a9 f4       	brne	.+42     	; 0x2aac <xQueueReceiveFromISR+0x88>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2a82:	eb 81       	ldd	r30, Y+3	; 0x03
    2a84:	fc 81       	ldd	r31, Y+4	; 0x04
    2a86:	80 85       	ldd	r24, Z+8	; 0x08
    2a88:	88 23       	and	r24, r24
    2a8a:	a9 f0       	breq	.+42     	; 0x2ab6 <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2a8c:	8b 81       	ldd	r24, Y+3	; 0x03
    2a8e:	9c 81       	ldd	r25, Y+4	; 0x04
    2a90:	08 96       	adiw	r24, 0x08	; 8
    2a92:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <xTaskRemoveFromEventList>
    2a96:	88 23       	and	r24, r24
    2a98:	71 f0       	breq	.+28     	; 0x2ab6 <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    2a9a:	8b 85       	ldd	r24, Y+11	; 0x0b
    2a9c:	9c 85       	ldd	r25, Y+12	; 0x0c
    2a9e:	00 97       	sbiw	r24, 0x00	; 0
    2aa0:	51 f0       	breq	.+20     	; 0x2ab6 <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    2aa2:	eb 85       	ldd	r30, Y+11	; 0x0b
    2aa4:	fc 85       	ldd	r31, Y+12	; 0x0c
    2aa6:	81 e0       	ldi	r24, 0x01	; 1
    2aa8:	80 83       	st	Z, r24
    2aaa:	05 c0       	rjmp	.+10     	; 0x2ab6 <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    2aac:	89 81       	ldd	r24, Y+1	; 0x01
    2aae:	8f 5f       	subi	r24, 0xFF	; 255
    2ab0:	eb 81       	ldd	r30, Y+3	; 0x03
    2ab2:	fc 81       	ldd	r31, Y+4	; 0x04
    2ab4:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    2ab6:	81 e0       	ldi	r24, 0x01	; 1
    2ab8:	8e 83       	std	Y+6, r24	; 0x06
    2aba:	01 c0       	rjmp	.+2      	; 0x2abe <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    2abc:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2abe:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2ac0:	2c 96       	adiw	r28, 0x0c	; 12
    2ac2:	0f b6       	in	r0, 0x3f	; 63
    2ac4:	f8 94       	cli
    2ac6:	de bf       	out	0x3e, r29	; 62
    2ac8:	0f be       	out	0x3f, r0	; 63
    2aca:	cd bf       	out	0x3d, r28	; 61
    2acc:	cf 91       	pop	r28
    2ace:	df 91       	pop	r29
    2ad0:	08 95       	ret

00002ad2 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    2ad2:	df 93       	push	r29
    2ad4:	cf 93       	push	r28
    2ad6:	cd b7       	in	r28, 0x3d	; 61
    2ad8:	de b7       	in	r29, 0x3e	; 62
    2ada:	2a 97       	sbiw	r28, 0x0a	; 10
    2adc:	0f b6       	in	r0, 0x3f	; 63
    2ade:	f8 94       	cli
    2ae0:	de bf       	out	0x3e, r29	; 62
    2ae2:	0f be       	out	0x3f, r0	; 63
    2ae4:	cd bf       	out	0x3d, r28	; 61
    2ae6:	98 87       	std	Y+8, r25	; 0x08
    2ae8:	8f 83       	std	Y+7, r24	; 0x07
    2aea:	7a 87       	std	Y+10, r23	; 0x0a
    2aec:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    2aee:	8f 81       	ldd	r24, Y+7	; 0x07
    2af0:	98 85       	ldd	r25, Y+8	; 0x08
    2af2:	9a 83       	std	Y+2, r25	; 0x02
    2af4:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2af6:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2af8:	e9 81       	ldd	r30, Y+1	; 0x01
    2afa:	fa 81       	ldd	r31, Y+2	; 0x02
    2afc:	82 8d       	ldd	r24, Z+26	; 0x1a
    2afe:	88 23       	and	r24, r24
    2b00:	b1 f0       	breq	.+44     	; 0x2b2e <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    2b02:	e9 81       	ldd	r30, Y+1	; 0x01
    2b04:	fa 81       	ldd	r31, Y+2	; 0x02
    2b06:	86 81       	ldd	r24, Z+6	; 0x06
    2b08:	97 81       	ldd	r25, Z+7	; 0x07
    2b0a:	9c 83       	std	Y+4, r25	; 0x04
    2b0c:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2b0e:	89 81       	ldd	r24, Y+1	; 0x01
    2b10:	9a 81       	ldd	r25, Y+2	; 0x02
    2b12:	29 85       	ldd	r18, Y+9	; 0x09
    2b14:	3a 85       	ldd	r19, Y+10	; 0x0a
    2b16:	b9 01       	movw	r22, r18
    2b18:	0e 94 b6 16 	call	0x2d6c	; 0x2d6c <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2b1c:	e9 81       	ldd	r30, Y+1	; 0x01
    2b1e:	fa 81       	ldd	r31, Y+2	; 0x02
    2b20:	8b 81       	ldd	r24, Y+3	; 0x03
    2b22:	9c 81       	ldd	r25, Y+4	; 0x04
    2b24:	97 83       	std	Z+7, r25	; 0x07
    2b26:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    2b28:	81 e0       	ldi	r24, 0x01	; 1
    2b2a:	8e 83       	std	Y+6, r24	; 0x06
    2b2c:	01 c0       	rjmp	.+2      	; 0x2b30 <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    2b2e:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2b30:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2b32:	2a 96       	adiw	r28, 0x0a	; 10
    2b34:	0f b6       	in	r0, 0x3f	; 63
    2b36:	f8 94       	cli
    2b38:	de bf       	out	0x3e, r29	; 62
    2b3a:	0f be       	out	0x3f, r0	; 63
    2b3c:	cd bf       	out	0x3d, r28	; 61
    2b3e:	cf 91       	pop	r28
    2b40:	df 91       	pop	r29
    2b42:	08 95       	ret

00002b44 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    2b44:	df 93       	push	r29
    2b46:	cf 93       	push	r28
    2b48:	00 d0       	rcall	.+0      	; 0x2b4a <uxQueueMessagesWaiting+0x6>
    2b4a:	0f 92       	push	r0
    2b4c:	cd b7       	in	r28, 0x3d	; 61
    2b4e:	de b7       	in	r29, 0x3e	; 62
    2b50:	9b 83       	std	Y+3, r25	; 0x03
    2b52:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    2b54:	0f b6       	in	r0, 0x3f	; 63
    2b56:	f8 94       	cli
    2b58:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    2b5a:	ea 81       	ldd	r30, Y+2	; 0x02
    2b5c:	fb 81       	ldd	r31, Y+3	; 0x03
    2b5e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2b60:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    2b62:	0f 90       	pop	r0
    2b64:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    2b66:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2b68:	0f 90       	pop	r0
    2b6a:	0f 90       	pop	r0
    2b6c:	0f 90       	pop	r0
    2b6e:	cf 91       	pop	r28
    2b70:	df 91       	pop	r29
    2b72:	08 95       	ret

00002b74 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    2b74:	df 93       	push	r29
    2b76:	cf 93       	push	r28
    2b78:	00 d0       	rcall	.+0      	; 0x2b7a <uxQueueSpacesAvailable+0x6>
    2b7a:	00 d0       	rcall	.+0      	; 0x2b7c <uxQueueSpacesAvailable+0x8>
    2b7c:	0f 92       	push	r0
    2b7e:	cd b7       	in	r28, 0x3d	; 61
    2b80:	de b7       	in	r29, 0x3e	; 62
    2b82:	9d 83       	std	Y+5, r25	; 0x05
    2b84:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    2b86:	8c 81       	ldd	r24, Y+4	; 0x04
    2b88:	9d 81       	ldd	r25, Y+5	; 0x05
    2b8a:	9a 83       	std	Y+2, r25	; 0x02
    2b8c:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2b8e:	0f b6       	in	r0, 0x3f	; 63
    2b90:	f8 94       	cli
    2b92:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    2b94:	e9 81       	ldd	r30, Y+1	; 0x01
    2b96:	fa 81       	ldd	r31, Y+2	; 0x02
    2b98:	93 8d       	ldd	r25, Z+27	; 0x1b
    2b9a:	e9 81       	ldd	r30, Y+1	; 0x01
    2b9c:	fa 81       	ldd	r31, Y+2	; 0x02
    2b9e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2ba0:	29 2f       	mov	r18, r25
    2ba2:	28 1b       	sub	r18, r24
    2ba4:	82 2f       	mov	r24, r18
    2ba6:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    2ba8:	0f 90       	pop	r0
    2baa:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    2bac:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2bae:	0f 90       	pop	r0
    2bb0:	0f 90       	pop	r0
    2bb2:	0f 90       	pop	r0
    2bb4:	0f 90       	pop	r0
    2bb6:	0f 90       	pop	r0
    2bb8:	cf 91       	pop	r28
    2bba:	df 91       	pop	r29
    2bbc:	08 95       	ret

00002bbe <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    2bbe:	df 93       	push	r29
    2bc0:	cf 93       	push	r28
    2bc2:	00 d0       	rcall	.+0      	; 0x2bc4 <uxQueueMessagesWaitingFromISR+0x6>
    2bc4:	00 d0       	rcall	.+0      	; 0x2bc6 <uxQueueMessagesWaitingFromISR+0x8>
    2bc6:	0f 92       	push	r0
    2bc8:	cd b7       	in	r28, 0x3d	; 61
    2bca:	de b7       	in	r29, 0x3e	; 62
    2bcc:	9d 83       	std	Y+5, r25	; 0x05
    2bce:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    2bd0:	8c 81       	ldd	r24, Y+4	; 0x04
    2bd2:	9d 81       	ldd	r25, Y+5	; 0x05
    2bd4:	9a 83       	std	Y+2, r25	; 0x02
    2bd6:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    2bd8:	e9 81       	ldd	r30, Y+1	; 0x01
    2bda:	fa 81       	ldd	r31, Y+2	; 0x02
    2bdc:	82 8d       	ldd	r24, Z+26	; 0x1a
    2bde:	8b 83       	std	Y+3, r24	; 0x03

	return uxReturn;
    2be0:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2be2:	0f 90       	pop	r0
    2be4:	0f 90       	pop	r0
    2be6:	0f 90       	pop	r0
    2be8:	0f 90       	pop	r0
    2bea:	0f 90       	pop	r0
    2bec:	cf 91       	pop	r28
    2bee:	df 91       	pop	r29
    2bf0:	08 95       	ret

00002bf2 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    2bf2:	df 93       	push	r29
    2bf4:	cf 93       	push	r28
    2bf6:	00 d0       	rcall	.+0      	; 0x2bf8 <vQueueDelete+0x6>
    2bf8:	00 d0       	rcall	.+0      	; 0x2bfa <vQueueDelete+0x8>
    2bfa:	cd b7       	in	r28, 0x3d	; 61
    2bfc:	de b7       	in	r29, 0x3e	; 62
    2bfe:	9c 83       	std	Y+4, r25	; 0x04
    2c00:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = xQueue;
    2c02:	8b 81       	ldd	r24, Y+3	; 0x03
    2c04:	9c 81       	ldd	r25, Y+4	; 0x04
    2c06:	9a 83       	std	Y+2, r25	; 0x02
    2c08:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    2c0a:	89 81       	ldd	r24, Y+1	; 0x01
    2c0c:	9a 81       	ldd	r25, Y+2	; 0x02
    2c0e:	0e 94 6f 0c 	call	0x18de	; 0x18de <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    2c12:	0f 90       	pop	r0
    2c14:	0f 90       	pop	r0
    2c16:	0f 90       	pop	r0
    2c18:	0f 90       	pop	r0
    2c1a:	cf 91       	pop	r28
    2c1c:	df 91       	pop	r29
    2c1e:	08 95       	ret

00002c20 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    2c20:	df 93       	push	r29
    2c22:	cf 93       	push	r28
    2c24:	cd b7       	in	r28, 0x3d	; 61
    2c26:	de b7       	in	r29, 0x3e	; 62
    2c28:	27 97       	sbiw	r28, 0x07	; 7
    2c2a:	0f b6       	in	r0, 0x3f	; 63
    2c2c:	f8 94       	cli
    2c2e:	de bf       	out	0x3e, r29	; 62
    2c30:	0f be       	out	0x3f, r0	; 63
    2c32:	cd bf       	out	0x3d, r28	; 61
    2c34:	9c 83       	std	Y+4, r25	; 0x04
    2c36:	8b 83       	std	Y+3, r24	; 0x03
    2c38:	7e 83       	std	Y+6, r23	; 0x06
    2c3a:	6d 83       	std	Y+5, r22	; 0x05
    2c3c:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    2c3e:	1a 82       	std	Y+2, r1	; 0x02
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2c40:	eb 81       	ldd	r30, Y+3	; 0x03
    2c42:	fc 81       	ldd	r31, Y+4	; 0x04
    2c44:	82 8d       	ldd	r24, Z+26	; 0x1a
    2c46:	89 83       	std	Y+1, r24	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    2c48:	eb 81       	ldd	r30, Y+3	; 0x03
    2c4a:	fc 81       	ldd	r31, Y+4	; 0x04
    2c4c:	84 8d       	ldd	r24, Z+28	; 0x1c
    2c4e:	88 23       	and	r24, r24
    2c50:	09 f4       	brne	.+2      	; 0x2c54 <prvCopyDataToQueue+0x34>
    2c52:	7d c0       	rjmp	.+250    	; 0x2d4e <prvCopyDataToQueue+0x12e>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    2c54:	8f 81       	ldd	r24, Y+7	; 0x07
    2c56:	88 23       	and	r24, r24
    2c58:	99 f5       	brne	.+102    	; 0x2cc0 <prvCopyDataToQueue+0xa0>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2c5a:	eb 81       	ldd	r30, Y+3	; 0x03
    2c5c:	fc 81       	ldd	r31, Y+4	; 0x04
    2c5e:	62 81       	ldd	r22, Z+2	; 0x02
    2c60:	73 81       	ldd	r23, Z+3	; 0x03
    2c62:	eb 81       	ldd	r30, Y+3	; 0x03
    2c64:	fc 81       	ldd	r31, Y+4	; 0x04
    2c66:	84 8d       	ldd	r24, Z+28	; 0x1c
    2c68:	48 2f       	mov	r20, r24
    2c6a:	50 e0       	ldi	r21, 0x00	; 0
    2c6c:	2d 81       	ldd	r18, Y+5	; 0x05
    2c6e:	3e 81       	ldd	r19, Y+6	; 0x06
    2c70:	cb 01       	movw	r24, r22
    2c72:	b9 01       	movw	r22, r18
    2c74:	0e 94 23 31 	call	0x6246	; 0x6246 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    2c78:	eb 81       	ldd	r30, Y+3	; 0x03
    2c7a:	fc 81       	ldd	r31, Y+4	; 0x04
    2c7c:	22 81       	ldd	r18, Z+2	; 0x02
    2c7e:	33 81       	ldd	r19, Z+3	; 0x03
    2c80:	eb 81       	ldd	r30, Y+3	; 0x03
    2c82:	fc 81       	ldd	r31, Y+4	; 0x04
    2c84:	84 8d       	ldd	r24, Z+28	; 0x1c
    2c86:	88 2f       	mov	r24, r24
    2c88:	90 e0       	ldi	r25, 0x00	; 0
    2c8a:	82 0f       	add	r24, r18
    2c8c:	93 1f       	adc	r25, r19
    2c8e:	eb 81       	ldd	r30, Y+3	; 0x03
    2c90:	fc 81       	ldd	r31, Y+4	; 0x04
    2c92:	93 83       	std	Z+3, r25	; 0x03
    2c94:	82 83       	std	Z+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2c96:	eb 81       	ldd	r30, Y+3	; 0x03
    2c98:	fc 81       	ldd	r31, Y+4	; 0x04
    2c9a:	22 81       	ldd	r18, Z+2	; 0x02
    2c9c:	33 81       	ldd	r19, Z+3	; 0x03
    2c9e:	eb 81       	ldd	r30, Y+3	; 0x03
    2ca0:	fc 81       	ldd	r31, Y+4	; 0x04
    2ca2:	84 81       	ldd	r24, Z+4	; 0x04
    2ca4:	95 81       	ldd	r25, Z+5	; 0x05
    2ca6:	28 17       	cp	r18, r24
    2ca8:	39 07       	cpc	r19, r25
    2caa:	08 f4       	brcc	.+2      	; 0x2cae <prvCopyDataToQueue+0x8e>
    2cac:	50 c0       	rjmp	.+160    	; 0x2d4e <prvCopyDataToQueue+0x12e>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    2cae:	eb 81       	ldd	r30, Y+3	; 0x03
    2cb0:	fc 81       	ldd	r31, Y+4	; 0x04
    2cb2:	80 81       	ld	r24, Z
    2cb4:	91 81       	ldd	r25, Z+1	; 0x01
    2cb6:	eb 81       	ldd	r30, Y+3	; 0x03
    2cb8:	fc 81       	ldd	r31, Y+4	; 0x04
    2cba:	93 83       	std	Z+3, r25	; 0x03
    2cbc:	82 83       	std	Z+2, r24	; 0x02
    2cbe:	47 c0       	rjmp	.+142    	; 0x2d4e <prvCopyDataToQueue+0x12e>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    2cc0:	eb 81       	ldd	r30, Y+3	; 0x03
    2cc2:	fc 81       	ldd	r31, Y+4	; 0x04
    2cc4:	66 81       	ldd	r22, Z+6	; 0x06
    2cc6:	77 81       	ldd	r23, Z+7	; 0x07
    2cc8:	eb 81       	ldd	r30, Y+3	; 0x03
    2cca:	fc 81       	ldd	r31, Y+4	; 0x04
    2ccc:	84 8d       	ldd	r24, Z+28	; 0x1c
    2cce:	48 2f       	mov	r20, r24
    2cd0:	50 e0       	ldi	r21, 0x00	; 0
    2cd2:	2d 81       	ldd	r18, Y+5	; 0x05
    2cd4:	3e 81       	ldd	r19, Y+6	; 0x06
    2cd6:	cb 01       	movw	r24, r22
    2cd8:	b9 01       	movw	r22, r18
    2cda:	0e 94 23 31 	call	0x6246	; 0x6246 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    2cde:	eb 81       	ldd	r30, Y+3	; 0x03
    2ce0:	fc 81       	ldd	r31, Y+4	; 0x04
    2ce2:	26 81       	ldd	r18, Z+6	; 0x06
    2ce4:	37 81       	ldd	r19, Z+7	; 0x07
    2ce6:	eb 81       	ldd	r30, Y+3	; 0x03
    2ce8:	fc 81       	ldd	r31, Y+4	; 0x04
    2cea:	84 8d       	ldd	r24, Z+28	; 0x1c
    2cec:	88 2f       	mov	r24, r24
    2cee:	90 e0       	ldi	r25, 0x00	; 0
    2cf0:	90 95       	com	r25
    2cf2:	81 95       	neg	r24
    2cf4:	9f 4f       	sbci	r25, 0xFF	; 255
    2cf6:	82 0f       	add	r24, r18
    2cf8:	93 1f       	adc	r25, r19
    2cfa:	eb 81       	ldd	r30, Y+3	; 0x03
    2cfc:	fc 81       	ldd	r31, Y+4	; 0x04
    2cfe:	97 83       	std	Z+7, r25	; 0x07
    2d00:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2d02:	eb 81       	ldd	r30, Y+3	; 0x03
    2d04:	fc 81       	ldd	r31, Y+4	; 0x04
    2d06:	26 81       	ldd	r18, Z+6	; 0x06
    2d08:	37 81       	ldd	r19, Z+7	; 0x07
    2d0a:	eb 81       	ldd	r30, Y+3	; 0x03
    2d0c:	fc 81       	ldd	r31, Y+4	; 0x04
    2d0e:	80 81       	ld	r24, Z
    2d10:	91 81       	ldd	r25, Z+1	; 0x01
    2d12:	28 17       	cp	r18, r24
    2d14:	39 07       	cpc	r19, r25
    2d16:	90 f4       	brcc	.+36     	; 0x2d3c <prvCopyDataToQueue+0x11c>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    2d18:	eb 81       	ldd	r30, Y+3	; 0x03
    2d1a:	fc 81       	ldd	r31, Y+4	; 0x04
    2d1c:	24 81       	ldd	r18, Z+4	; 0x04
    2d1e:	35 81       	ldd	r19, Z+5	; 0x05
    2d20:	eb 81       	ldd	r30, Y+3	; 0x03
    2d22:	fc 81       	ldd	r31, Y+4	; 0x04
    2d24:	84 8d       	ldd	r24, Z+28	; 0x1c
    2d26:	88 2f       	mov	r24, r24
    2d28:	90 e0       	ldi	r25, 0x00	; 0
    2d2a:	90 95       	com	r25
    2d2c:	81 95       	neg	r24
    2d2e:	9f 4f       	sbci	r25, 0xFF	; 255
    2d30:	82 0f       	add	r24, r18
    2d32:	93 1f       	adc	r25, r19
    2d34:	eb 81       	ldd	r30, Y+3	; 0x03
    2d36:	fc 81       	ldd	r31, Y+4	; 0x04
    2d38:	97 83       	std	Z+7, r25	; 0x07
    2d3a:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    2d3c:	8f 81       	ldd	r24, Y+7	; 0x07
    2d3e:	82 30       	cpi	r24, 0x02	; 2
    2d40:	31 f4       	brne	.+12     	; 0x2d4e <prvCopyDataToQueue+0x12e>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2d42:	89 81       	ldd	r24, Y+1	; 0x01
    2d44:	88 23       	and	r24, r24
    2d46:	19 f0       	breq	.+6      	; 0x2d4e <prvCopyDataToQueue+0x12e>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    2d48:	89 81       	ldd	r24, Y+1	; 0x01
    2d4a:	81 50       	subi	r24, 0x01	; 1
    2d4c:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    2d4e:	89 81       	ldd	r24, Y+1	; 0x01
    2d50:	8f 5f       	subi	r24, 0xFF	; 255
    2d52:	eb 81       	ldd	r30, Y+3	; 0x03
    2d54:	fc 81       	ldd	r31, Y+4	; 0x04
    2d56:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    2d58:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2d5a:	27 96       	adiw	r28, 0x07	; 7
    2d5c:	0f b6       	in	r0, 0x3f	; 63
    2d5e:	f8 94       	cli
    2d60:	de bf       	out	0x3e, r29	; 62
    2d62:	0f be       	out	0x3f, r0	; 63
    2d64:	cd bf       	out	0x3d, r28	; 61
    2d66:	cf 91       	pop	r28
    2d68:	df 91       	pop	r29
    2d6a:	08 95       	ret

00002d6c <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    2d6c:	df 93       	push	r29
    2d6e:	cf 93       	push	r28
    2d70:	00 d0       	rcall	.+0      	; 0x2d72 <prvCopyDataFromQueue+0x6>
    2d72:	00 d0       	rcall	.+0      	; 0x2d74 <prvCopyDataFromQueue+0x8>
    2d74:	cd b7       	in	r28, 0x3d	; 61
    2d76:	de b7       	in	r29, 0x3e	; 62
    2d78:	9a 83       	std	Y+2, r25	; 0x02
    2d7a:	89 83       	std	Y+1, r24	; 0x01
    2d7c:	7c 83       	std	Y+4, r23	; 0x04
    2d7e:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    2d80:	e9 81       	ldd	r30, Y+1	; 0x01
    2d82:	fa 81       	ldd	r31, Y+2	; 0x02
    2d84:	84 8d       	ldd	r24, Z+28	; 0x1c
    2d86:	88 23       	and	r24, r24
    2d88:	89 f1       	breq	.+98     	; 0x2dec <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    2d8a:	e9 81       	ldd	r30, Y+1	; 0x01
    2d8c:	fa 81       	ldd	r31, Y+2	; 0x02
    2d8e:	26 81       	ldd	r18, Z+6	; 0x06
    2d90:	37 81       	ldd	r19, Z+7	; 0x07
    2d92:	e9 81       	ldd	r30, Y+1	; 0x01
    2d94:	fa 81       	ldd	r31, Y+2	; 0x02
    2d96:	84 8d       	ldd	r24, Z+28	; 0x1c
    2d98:	88 2f       	mov	r24, r24
    2d9a:	90 e0       	ldi	r25, 0x00	; 0
    2d9c:	82 0f       	add	r24, r18
    2d9e:	93 1f       	adc	r25, r19
    2da0:	e9 81       	ldd	r30, Y+1	; 0x01
    2da2:	fa 81       	ldd	r31, Y+2	; 0x02
    2da4:	97 83       	std	Z+7, r25	; 0x07
    2da6:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    2da8:	e9 81       	ldd	r30, Y+1	; 0x01
    2daa:	fa 81       	ldd	r31, Y+2	; 0x02
    2dac:	26 81       	ldd	r18, Z+6	; 0x06
    2dae:	37 81       	ldd	r19, Z+7	; 0x07
    2db0:	e9 81       	ldd	r30, Y+1	; 0x01
    2db2:	fa 81       	ldd	r31, Y+2	; 0x02
    2db4:	84 81       	ldd	r24, Z+4	; 0x04
    2db6:	95 81       	ldd	r25, Z+5	; 0x05
    2db8:	28 17       	cp	r18, r24
    2dba:	39 07       	cpc	r19, r25
    2dbc:	40 f0       	brcs	.+16     	; 0x2dce <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    2dbe:	e9 81       	ldd	r30, Y+1	; 0x01
    2dc0:	fa 81       	ldd	r31, Y+2	; 0x02
    2dc2:	80 81       	ld	r24, Z
    2dc4:	91 81       	ldd	r25, Z+1	; 0x01
    2dc6:	e9 81       	ldd	r30, Y+1	; 0x01
    2dc8:	fa 81       	ldd	r31, Y+2	; 0x02
    2dca:	97 83       	std	Z+7, r25	; 0x07
    2dcc:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2dce:	e9 81       	ldd	r30, Y+1	; 0x01
    2dd0:	fa 81       	ldd	r31, Y+2	; 0x02
    2dd2:	46 81       	ldd	r20, Z+6	; 0x06
    2dd4:	57 81       	ldd	r21, Z+7	; 0x07
    2dd6:	e9 81       	ldd	r30, Y+1	; 0x01
    2dd8:	fa 81       	ldd	r31, Y+2	; 0x02
    2dda:	84 8d       	ldd	r24, Z+28	; 0x1c
    2ddc:	28 2f       	mov	r18, r24
    2dde:	30 e0       	ldi	r19, 0x00	; 0
    2de0:	8b 81       	ldd	r24, Y+3	; 0x03
    2de2:	9c 81       	ldd	r25, Y+4	; 0x04
    2de4:	ba 01       	movw	r22, r20
    2de6:	a9 01       	movw	r20, r18
    2de8:	0e 94 23 31 	call	0x6246	; 0x6246 <memcpy>
	}
}
    2dec:	0f 90       	pop	r0
    2dee:	0f 90       	pop	r0
    2df0:	0f 90       	pop	r0
    2df2:	0f 90       	pop	r0
    2df4:	cf 91       	pop	r28
    2df6:	df 91       	pop	r29
    2df8:	08 95       	ret

00002dfa <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    2dfa:	df 93       	push	r29
    2dfc:	cf 93       	push	r28
    2dfe:	00 d0       	rcall	.+0      	; 0x2e00 <prvUnlockQueue+0x6>
    2e00:	00 d0       	rcall	.+0      	; 0x2e02 <prvUnlockQueue+0x8>
    2e02:	cd b7       	in	r28, 0x3d	; 61
    2e04:	de b7       	in	r29, 0x3e	; 62
    2e06:	9c 83       	std	Y+4, r25	; 0x04
    2e08:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    2e0a:	0f b6       	in	r0, 0x3f	; 63
    2e0c:	f8 94       	cli
    2e0e:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    2e10:	eb 81       	ldd	r30, Y+3	; 0x03
    2e12:	fc 81       	ldd	r31, Y+4	; 0x04
    2e14:	86 8d       	ldd	r24, Z+30	; 0x1e
    2e16:	8a 83       	std	Y+2, r24	; 0x02
    2e18:	11 c0       	rjmp	.+34     	; 0x2e3c <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2e1a:	eb 81       	ldd	r30, Y+3	; 0x03
    2e1c:	fc 81       	ldd	r31, Y+4	; 0x04
    2e1e:	81 89       	ldd	r24, Z+17	; 0x11
    2e20:	88 23       	and	r24, r24
    2e22:	79 f0       	breq	.+30     	; 0x2e42 <prvUnlockQueue+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2e24:	8b 81       	ldd	r24, Y+3	; 0x03
    2e26:	9c 81       	ldd	r25, Y+4	; 0x04
    2e28:	41 96       	adiw	r24, 0x11	; 17
    2e2a:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <xTaskRemoveFromEventList>
    2e2e:	88 23       	and	r24, r24
    2e30:	11 f0       	breq	.+4      	; 0x2e36 <prvUnlockQueue+0x3c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    2e32:	0e 94 1f 27 	call	0x4e3e	; 0x4e3e <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    2e36:	8a 81       	ldd	r24, Y+2	; 0x02
    2e38:	81 50       	subi	r24, 0x01	; 1
    2e3a:	8a 83       	std	Y+2, r24	; 0x02
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    2e3c:	8a 81       	ldd	r24, Y+2	; 0x02
    2e3e:	18 16       	cp	r1, r24
    2e40:	64 f3       	brlt	.-40     	; 0x2e1a <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    2e42:	eb 81       	ldd	r30, Y+3	; 0x03
    2e44:	fc 81       	ldd	r31, Y+4	; 0x04
    2e46:	8f ef       	ldi	r24, 0xFF	; 255
    2e48:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    2e4a:	0f 90       	pop	r0
    2e4c:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    2e4e:	0f b6       	in	r0, 0x3f	; 63
    2e50:	f8 94       	cli
    2e52:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    2e54:	eb 81       	ldd	r30, Y+3	; 0x03
    2e56:	fc 81       	ldd	r31, Y+4	; 0x04
    2e58:	85 8d       	ldd	r24, Z+29	; 0x1d
    2e5a:	89 83       	std	Y+1, r24	; 0x01
    2e5c:	11 c0       	rjmp	.+34     	; 0x2e80 <prvUnlockQueue+0x86>

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2e5e:	eb 81       	ldd	r30, Y+3	; 0x03
    2e60:	fc 81       	ldd	r31, Y+4	; 0x04
    2e62:	80 85       	ldd	r24, Z+8	; 0x08
    2e64:	88 23       	and	r24, r24
    2e66:	79 f0       	breq	.+30     	; 0x2e86 <prvUnlockQueue+0x8c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2e68:	8b 81       	ldd	r24, Y+3	; 0x03
    2e6a:	9c 81       	ldd	r25, Y+4	; 0x04
    2e6c:	08 96       	adiw	r24, 0x08	; 8
    2e6e:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <xTaskRemoveFromEventList>
    2e72:	88 23       	and	r24, r24
    2e74:	11 f0       	breq	.+4      	; 0x2e7a <prvUnlockQueue+0x80>
				{
					vTaskMissedYield();
    2e76:	0e 94 1f 27 	call	0x4e3e	; 0x4e3e <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    2e7a:	89 81       	ldd	r24, Y+1	; 0x01
    2e7c:	81 50       	subi	r24, 0x01	; 1
    2e7e:	89 83       	std	Y+1, r24	; 0x01
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    2e80:	89 81       	ldd	r24, Y+1	; 0x01
    2e82:	18 16       	cp	r1, r24
    2e84:	64 f3       	brlt	.-40     	; 0x2e5e <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    2e86:	eb 81       	ldd	r30, Y+3	; 0x03
    2e88:	fc 81       	ldd	r31, Y+4	; 0x04
    2e8a:	8f ef       	ldi	r24, 0xFF	; 255
    2e8c:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    2e8e:	0f 90       	pop	r0
    2e90:	0f be       	out	0x3f, r0	; 63
}
    2e92:	0f 90       	pop	r0
    2e94:	0f 90       	pop	r0
    2e96:	0f 90       	pop	r0
    2e98:	0f 90       	pop	r0
    2e9a:	cf 91       	pop	r28
    2e9c:	df 91       	pop	r29
    2e9e:	08 95       	ret

00002ea0 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    2ea0:	df 93       	push	r29
    2ea2:	cf 93       	push	r28
    2ea4:	00 d0       	rcall	.+0      	; 0x2ea6 <prvIsQueueEmpty+0x6>
    2ea6:	0f 92       	push	r0
    2ea8:	cd b7       	in	r28, 0x3d	; 61
    2eaa:	de b7       	in	r29, 0x3e	; 62
    2eac:	9b 83       	std	Y+3, r25	; 0x03
    2eae:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2eb0:	0f b6       	in	r0, 0x3f	; 63
    2eb2:	f8 94       	cli
    2eb4:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    2eb6:	ea 81       	ldd	r30, Y+2	; 0x02
    2eb8:	fb 81       	ldd	r31, Y+3	; 0x03
    2eba:	82 8d       	ldd	r24, Z+26	; 0x1a
    2ebc:	88 23       	and	r24, r24
    2ebe:	19 f4       	brne	.+6      	; 0x2ec6 <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    2ec0:	81 e0       	ldi	r24, 0x01	; 1
    2ec2:	89 83       	std	Y+1, r24	; 0x01
    2ec4:	01 c0       	rjmp	.+2      	; 0x2ec8 <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    2ec6:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2ec8:	0f 90       	pop	r0
    2eca:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2ecc:	89 81       	ldd	r24, Y+1	; 0x01
}
    2ece:	0f 90       	pop	r0
    2ed0:	0f 90       	pop	r0
    2ed2:	0f 90       	pop	r0
    2ed4:	cf 91       	pop	r28
    2ed6:	df 91       	pop	r29
    2ed8:	08 95       	ret

00002eda <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    2eda:	df 93       	push	r29
    2edc:	cf 93       	push	r28
    2ede:	00 d0       	rcall	.+0      	; 0x2ee0 <xQueueIsQueueEmptyFromISR+0x6>
    2ee0:	00 d0       	rcall	.+0      	; 0x2ee2 <xQueueIsQueueEmptyFromISR+0x8>
    2ee2:	0f 92       	push	r0
    2ee4:	cd b7       	in	r28, 0x3d	; 61
    2ee6:	de b7       	in	r29, 0x3e	; 62
    2ee8:	9d 83       	std	Y+5, r25	; 0x05
    2eea:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    2eec:	8c 81       	ldd	r24, Y+4	; 0x04
    2eee:	9d 81       	ldd	r25, Y+5	; 0x05
    2ef0:	9a 83       	std	Y+2, r25	; 0x02
    2ef2:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2ef4:	e9 81       	ldd	r30, Y+1	; 0x01
    2ef6:	fa 81       	ldd	r31, Y+2	; 0x02
    2ef8:	82 8d       	ldd	r24, Z+26	; 0x1a
    2efa:	88 23       	and	r24, r24
    2efc:	19 f4       	brne	.+6      	; 0x2f04 <xQueueIsQueueEmptyFromISR+0x2a>
	{
		xReturn = pdTRUE;
    2efe:	81 e0       	ldi	r24, 0x01	; 1
    2f00:	8b 83       	std	Y+3, r24	; 0x03
    2f02:	01 c0       	rjmp	.+2      	; 0x2f06 <xQueueIsQueueEmptyFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
    2f04:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    2f06:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2f08:	0f 90       	pop	r0
    2f0a:	0f 90       	pop	r0
    2f0c:	0f 90       	pop	r0
    2f0e:	0f 90       	pop	r0
    2f10:	0f 90       	pop	r0
    2f12:	cf 91       	pop	r28
    2f14:	df 91       	pop	r29
    2f16:	08 95       	ret

00002f18 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    2f18:	df 93       	push	r29
    2f1a:	cf 93       	push	r28
    2f1c:	00 d0       	rcall	.+0      	; 0x2f1e <prvIsQueueFull+0x6>
    2f1e:	0f 92       	push	r0
    2f20:	cd b7       	in	r28, 0x3d	; 61
    2f22:	de b7       	in	r29, 0x3e	; 62
    2f24:	9b 83       	std	Y+3, r25	; 0x03
    2f26:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2f28:	0f b6       	in	r0, 0x3f	; 63
    2f2a:	f8 94       	cli
    2f2c:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2f2e:	ea 81       	ldd	r30, Y+2	; 0x02
    2f30:	fb 81       	ldd	r31, Y+3	; 0x03
    2f32:	92 8d       	ldd	r25, Z+26	; 0x1a
    2f34:	ea 81       	ldd	r30, Y+2	; 0x02
    2f36:	fb 81       	ldd	r31, Y+3	; 0x03
    2f38:	83 8d       	ldd	r24, Z+27	; 0x1b
    2f3a:	98 17       	cp	r25, r24
    2f3c:	19 f4       	brne	.+6      	; 0x2f44 <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    2f3e:	81 e0       	ldi	r24, 0x01	; 1
    2f40:	89 83       	std	Y+1, r24	; 0x01
    2f42:	01 c0       	rjmp	.+2      	; 0x2f46 <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    2f44:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2f46:	0f 90       	pop	r0
    2f48:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2f4a:	89 81       	ldd	r24, Y+1	; 0x01
}
    2f4c:	0f 90       	pop	r0
    2f4e:	0f 90       	pop	r0
    2f50:	0f 90       	pop	r0
    2f52:	cf 91       	pop	r28
    2f54:	df 91       	pop	r29
    2f56:	08 95       	ret

00002f58 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    2f58:	df 93       	push	r29
    2f5a:	cf 93       	push	r28
    2f5c:	00 d0       	rcall	.+0      	; 0x2f5e <xQueueIsQueueFullFromISR+0x6>
    2f5e:	00 d0       	rcall	.+0      	; 0x2f60 <xQueueIsQueueFullFromISR+0x8>
    2f60:	0f 92       	push	r0
    2f62:	cd b7       	in	r28, 0x3d	; 61
    2f64:	de b7       	in	r29, 0x3e	; 62
    2f66:	9d 83       	std	Y+5, r25	; 0x05
    2f68:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    2f6a:	8c 81       	ldd	r24, Y+4	; 0x04
    2f6c:	9d 81       	ldd	r25, Y+5	; 0x05
    2f6e:	9a 83       	std	Y+2, r25	; 0x02
    2f70:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2f72:	e9 81       	ldd	r30, Y+1	; 0x01
    2f74:	fa 81       	ldd	r31, Y+2	; 0x02
    2f76:	92 8d       	ldd	r25, Z+26	; 0x1a
    2f78:	e9 81       	ldd	r30, Y+1	; 0x01
    2f7a:	fa 81       	ldd	r31, Y+2	; 0x02
    2f7c:	83 8d       	ldd	r24, Z+27	; 0x1b
    2f7e:	98 17       	cp	r25, r24
    2f80:	19 f4       	brne	.+6      	; 0x2f88 <xQueueIsQueueFullFromISR+0x30>
	{
		xReturn = pdTRUE;
    2f82:	81 e0       	ldi	r24, 0x01	; 1
    2f84:	8b 83       	std	Y+3, r24	; 0x03
    2f86:	01 c0       	rjmp	.+2      	; 0x2f8a <xQueueIsQueueFullFromISR+0x32>
	}
	else
	{
		xReturn = pdFALSE;
    2f88:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    2f8a:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2f8c:	0f 90       	pop	r0
    2f8e:	0f 90       	pop	r0
    2f90:	0f 90       	pop	r0
    2f92:	0f 90       	pop	r0
    2f94:	0f 90       	pop	r0
    2f96:	cf 91       	pop	r28
    2f98:	df 91       	pop	r29
    2f9a:	08 95       	ret

00002f9c <xStreamBufferGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer )
	{
    2f9c:	0f 93       	push	r16
    2f9e:	df 93       	push	r29
    2fa0:	cf 93       	push	r28
    2fa2:	cd b7       	in	r28, 0x3d	; 61
    2fa4:	de b7       	in	r29, 0x3e	; 62
    2fa6:	28 97       	sbiw	r28, 0x08	; 8
    2fa8:	0f b6       	in	r0, 0x3f	; 63
    2faa:	f8 94       	cli
    2fac:	de bf       	out	0x3e, r29	; 62
    2fae:	0f be       	out	0x3f, r0	; 63
    2fb0:	cd bf       	out	0x3d, r28	; 61
    2fb2:	9d 83       	std	Y+5, r25	; 0x05
    2fb4:	8c 83       	std	Y+4, r24	; 0x04
    2fb6:	7f 83       	std	Y+7, r23	; 0x07
    2fb8:	6e 83       	std	Y+6, r22	; 0x06
    2fba:	48 87       	std	Y+8, r20	; 0x08

		/* In case the stream buffer is going to be used as a message buffer
		(that is, it will hold discrete messages with a little meta data that
		says how big the next message is) check the buffer will be large enough
		to hold at least one message. */
		if( xIsMessageBuffer == pdTRUE )
    2fbc:	88 85       	ldd	r24, Y+8	; 0x08
    2fbe:	81 30       	cpi	r24, 0x01	; 1
    2fc0:	19 f4       	brne	.+6      	; 0x2fc8 <xStreamBufferGenericCreate+0x2c>
		{
			/* Is a message buffer but not statically allocated. */
			ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
    2fc2:	81 e0       	ldi	r24, 0x01	; 1
    2fc4:	89 83       	std	Y+1, r24	; 0x01
    2fc6:	01 c0       	rjmp	.+2      	; 0x2fca <xStreamBufferGenericCreate+0x2e>
			configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
		}
		else
		{
			/* Not a message buffer and not statically allocated. */
			ucFlags = 0;
    2fc8:	19 82       	std	Y+1, r1	; 0x01
		}
		configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

		/* A trigger level of 0 would cause a waiting task to unblock even when
		the buffer was empty. */
		if( xTriggerLevelBytes == ( size_t ) 0 )
    2fca:	8e 81       	ldd	r24, Y+6	; 0x06
    2fcc:	9f 81       	ldd	r25, Y+7	; 0x07
    2fce:	00 97       	sbiw	r24, 0x00	; 0
    2fd0:	21 f4       	brne	.+8      	; 0x2fda <xStreamBufferGenericCreate+0x3e>
		{
			xTriggerLevelBytes = ( size_t ) 1;
    2fd2:	81 e0       	ldi	r24, 0x01	; 1
    2fd4:	90 e0       	ldi	r25, 0x00	; 0
    2fd6:	9f 83       	std	Y+7, r25	; 0x07
    2fd8:	8e 83       	std	Y+6, r24	; 0x06
		and the buffer follows immediately after.  The requested size is
		incremented so the free space is returned as the user would expect -
		this is a quirk of the implementation that means otherwise the free
		space would be reported as one byte smaller than would be logically
		expected. */
		xBufferSizeBytes++;
    2fda:	8c 81       	ldd	r24, Y+4	; 0x04
    2fdc:	9d 81       	ldd	r25, Y+5	; 0x05
    2fde:	01 96       	adiw	r24, 0x01	; 1
    2fe0:	9d 83       	std	Y+5, r25	; 0x05
    2fe2:	8c 83       	std	Y+4, r24	; 0x04
		pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
    2fe4:	8c 81       	ldd	r24, Y+4	; 0x04
    2fe6:	9d 81       	ldd	r25, Y+5	; 0x05
    2fe8:	0f 96       	adiw	r24, 0x0f	; 15
    2fea:	0e 94 19 0c 	call	0x1832	; 0x1832 <pvPortMalloc>
    2fee:	9b 83       	std	Y+3, r25	; 0x03
    2ff0:	8a 83       	std	Y+2, r24	; 0x02

		if( pucAllocatedMemory != NULL )
    2ff2:	8a 81       	ldd	r24, Y+2	; 0x02
    2ff4:	9b 81       	ldd	r25, Y+3	; 0x03
    2ff6:	00 97       	sbiw	r24, 0x00	; 0
    2ff8:	89 f0       	breq	.+34     	; 0x301c <xStreamBufferGenericCreate+0x80>
		{
			prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory, /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
    2ffa:	6a 81       	ldd	r22, Y+2	; 0x02
    2ffc:	7b 81       	ldd	r23, Y+3	; 0x03
    2ffe:	8a 81       	ldd	r24, Y+2	; 0x02
    3000:	9b 81       	ldd	r25, Y+3	; 0x03
    3002:	9c 01       	movw	r18, r24
    3004:	21 5f       	subi	r18, 0xF1	; 241
    3006:	3f 4f       	sbci	r19, 0xFF	; 255
    3008:	4c 81       	ldd	r20, Y+4	; 0x04
    300a:	5d 81       	ldd	r21, Y+5	; 0x05
    300c:	ee 81       	ldd	r30, Y+6	; 0x06
    300e:	ff 81       	ldd	r31, Y+7	; 0x07
    3010:	cb 01       	movw	r24, r22
    3012:	b9 01       	movw	r22, r18
    3014:	9f 01       	movw	r18, r30
    3016:	09 81       	ldd	r16, Y+1	; 0x01
    3018:	0e 94 26 1f 	call	0x3e4c	; 0x3e4c <prvInitialiseNewStreamBuffer>
		else
		{
			traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
		}

		return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
    301c:	8a 81       	ldd	r24, Y+2	; 0x02
    301e:	9b 81       	ldd	r25, Y+3	; 0x03
	}
    3020:	28 96       	adiw	r28, 0x08	; 8
    3022:	0f b6       	in	r0, 0x3f	; 63
    3024:	f8 94       	cli
    3026:	de bf       	out	0x3e, r29	; 62
    3028:	0f be       	out	0x3f, r0	; 63
    302a:	cd bf       	out	0x3d, r28	; 61
    302c:	cf 91       	pop	r28
    302e:	df 91       	pop	r29
    3030:	0f 91       	pop	r16
    3032:	08 95       	ret

00003034 <vStreamBufferDelete>:

#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
    3034:	df 93       	push	r29
    3036:	cf 93       	push	r28
    3038:	00 d0       	rcall	.+0      	; 0x303a <vStreamBufferDelete+0x6>
    303a:	00 d0       	rcall	.+0      	; 0x303c <vStreamBufferDelete+0x8>
    303c:	cd b7       	in	r28, 0x3d	; 61
    303e:	de b7       	in	r29, 0x3e	; 62
    3040:	9c 83       	std	Y+4, r25	; 0x04
    3042:	8b 83       	std	Y+3, r24	; 0x03
StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
    3044:	8b 81       	ldd	r24, Y+3	; 0x03
    3046:	9c 81       	ldd	r25, Y+4	; 0x04
    3048:	9a 83       	std	Y+2, r25	; 0x02
    304a:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxStreamBuffer );

	traceSTREAM_BUFFER_DELETE( xStreamBuffer );

	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
    304c:	e9 81       	ldd	r30, Y+1	; 0x01
    304e:	fa 81       	ldd	r31, Y+2	; 0x02
    3050:	86 85       	ldd	r24, Z+14	; 0x0e
    3052:	88 2f       	mov	r24, r24
    3054:	90 e0       	ldi	r25, 0x00	; 0
    3056:	82 70       	andi	r24, 0x02	; 2
    3058:	90 70       	andi	r25, 0x00	; 0
    305a:	00 97       	sbiw	r24, 0x00	; 0
    305c:	29 f4       	brne	.+10     	; 0x3068 <vStreamBufferDelete+0x34>
	{
		#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
		{
			/* Both the structure and the buffer were allocated using a single call
			to pvPortMalloc(), hence only one call to vPortFree() is required. */
			vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
    305e:	89 81       	ldd	r24, Y+1	; 0x01
    3060:	9a 81       	ldd	r25, Y+2	; 0x02
    3062:	0e 94 6f 0c 	call	0x18de	; 0x18de <vPortFree>
    3066:	08 c0       	rjmp	.+16     	; 0x3078 <vStreamBufferDelete+0x44>
	}
	else
	{
		/* The structure and buffer were not allocated dynamically and cannot be
		freed - just scrub the structure so future use will assert. */
		( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
    3068:	89 81       	ldd	r24, Y+1	; 0x01
    306a:	9a 81       	ldd	r25, Y+2	; 0x02
    306c:	60 e0       	ldi	r22, 0x00	; 0
    306e:	70 e0       	ldi	r23, 0x00	; 0
    3070:	4f e0       	ldi	r20, 0x0F	; 15
    3072:	50 e0       	ldi	r21, 0x00	; 0
    3074:	0e 94 2c 31 	call	0x6258	; 0x6258 <memset>
	}
}
    3078:	0f 90       	pop	r0
    307a:	0f 90       	pop	r0
    307c:	0f 90       	pop	r0
    307e:	0f 90       	pop	r0
    3080:	cf 91       	pop	r28
    3082:	df 91       	pop	r29
    3084:	08 95       	ret

00003086 <xStreamBufferReset>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
    3086:	0f 93       	push	r16
    3088:	df 93       	push	r29
    308a:	cf 93       	push	r28
    308c:	00 d0       	rcall	.+0      	; 0x308e <xStreamBufferReset+0x8>
    308e:	00 d0       	rcall	.+0      	; 0x3090 <xStreamBufferReset+0xa>
    3090:	0f 92       	push	r0
    3092:	cd b7       	in	r28, 0x3d	; 61
    3094:	de b7       	in	r29, 0x3e	; 62
    3096:	9d 83       	std	Y+5, r25	; 0x05
    3098:	8c 83       	std	Y+4, r24	; 0x04
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    309a:	8c 81       	ldd	r24, Y+4	; 0x04
    309c:	9d 81       	ldd	r25, Y+5	; 0x05
    309e:	9b 83       	std	Y+3, r25	; 0x03
    30a0:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn = pdFAIL;
    30a2:	19 82       	std	Y+1, r1	; 0x01
		uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
	}
	#endif

	/* Can only reset a message buffer if there are no tasks blocked on it. */
	taskENTER_CRITICAL();
    30a4:	0f b6       	in	r0, 0x3f	; 63
    30a6:	f8 94       	cli
    30a8:	0f 92       	push	r0
	{
		if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
    30aa:	ea 81       	ldd	r30, Y+2	; 0x02
    30ac:	fb 81       	ldd	r31, Y+3	; 0x03
    30ae:	80 85       	ldd	r24, Z+8	; 0x08
    30b0:	91 85       	ldd	r25, Z+9	; 0x09
    30b2:	00 97       	sbiw	r24, 0x00	; 0
    30b4:	f1 f4       	brne	.+60     	; 0x30f2 <xStreamBufferReset+0x6c>
		{
			if( pxStreamBuffer->xTaskWaitingToSend == NULL )
    30b6:	ea 81       	ldd	r30, Y+2	; 0x02
    30b8:	fb 81       	ldd	r31, Y+3	; 0x03
    30ba:	82 85       	ldd	r24, Z+10	; 0x0a
    30bc:	93 85       	ldd	r25, Z+11	; 0x0b
    30be:	00 97       	sbiw	r24, 0x00	; 0
    30c0:	c1 f4       	brne	.+48     	; 0x30f2 <xStreamBufferReset+0x6c>
			{
				prvInitialiseNewStreamBuffer( pxStreamBuffer,
    30c2:	ea 81       	ldd	r30, Y+2	; 0x02
    30c4:	fb 81       	ldd	r31, Y+3	; 0x03
    30c6:	24 85       	ldd	r18, Z+12	; 0x0c
    30c8:	35 85       	ldd	r19, Z+13	; 0x0d
    30ca:	ea 81       	ldd	r30, Y+2	; 0x02
    30cc:	fb 81       	ldd	r31, Y+3	; 0x03
    30ce:	44 81       	ldd	r20, Z+4	; 0x04
    30d0:	55 81       	ldd	r21, Z+5	; 0x05
    30d2:	ea 81       	ldd	r30, Y+2	; 0x02
    30d4:	fb 81       	ldd	r31, Y+3	; 0x03
    30d6:	a6 81       	ldd	r26, Z+6	; 0x06
    30d8:	b7 81       	ldd	r27, Z+7	; 0x07
    30da:	ea 81       	ldd	r30, Y+2	; 0x02
    30dc:	fb 81       	ldd	r31, Y+3	; 0x03
    30de:	e6 85       	ldd	r30, Z+14	; 0x0e
    30e0:	8a 81       	ldd	r24, Y+2	; 0x02
    30e2:	9b 81       	ldd	r25, Y+3	; 0x03
    30e4:	b9 01       	movw	r22, r18
    30e6:	9d 01       	movw	r18, r26
    30e8:	0e 2f       	mov	r16, r30
    30ea:	0e 94 26 1f 	call	0x3e4c	; 0x3e4c <prvInitialiseNewStreamBuffer>
											  pxStreamBuffer->pucBuffer,
											  pxStreamBuffer->xLength,
											  pxStreamBuffer->xTriggerLevelBytes,
											  pxStreamBuffer->ucFlags );
				xReturn = pdPASS;
    30ee:	81 e0       	ldi	r24, 0x01	; 1
    30f0:	89 83       	std	Y+1, r24	; 0x01

				traceSTREAM_BUFFER_RESET( xStreamBuffer );
			}
		}
	}
	taskEXIT_CRITICAL();
    30f2:	0f 90       	pop	r0
    30f4:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    30f6:	89 81       	ldd	r24, Y+1	; 0x01
}
    30f8:	0f 90       	pop	r0
    30fa:	0f 90       	pop	r0
    30fc:	0f 90       	pop	r0
    30fe:	0f 90       	pop	r0
    3100:	0f 90       	pop	r0
    3102:	cf 91       	pop	r28
    3104:	df 91       	pop	r29
    3106:	0f 91       	pop	r16
    3108:	08 95       	ret

0000310a <xStreamBufferSetTriggerLevel>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel )
{
    310a:	df 93       	push	r29
    310c:	cf 93       	push	r28
    310e:	cd b7       	in	r28, 0x3d	; 61
    3110:	de b7       	in	r29, 0x3e	; 62
    3112:	27 97       	sbiw	r28, 0x07	; 7
    3114:	0f b6       	in	r0, 0x3f	; 63
    3116:	f8 94       	cli
    3118:	de bf       	out	0x3e, r29	; 62
    311a:	0f be       	out	0x3f, r0	; 63
    311c:	cd bf       	out	0x3d, r28	; 61
    311e:	9d 83       	std	Y+5, r25	; 0x05
    3120:	8c 83       	std	Y+4, r24	; 0x04
    3122:	7f 83       	std	Y+7, r23	; 0x07
    3124:	6e 83       	std	Y+6, r22	; 0x06
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3126:	8c 81       	ldd	r24, Y+4	; 0x04
    3128:	9d 81       	ldd	r25, Y+5	; 0x05
    312a:	9b 83       	std	Y+3, r25	; 0x03
    312c:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( pxStreamBuffer );

	/* It is not valid for the trigger level to be 0. */
	if( xTriggerLevel == ( size_t ) 0 )
    312e:	8e 81       	ldd	r24, Y+6	; 0x06
    3130:	9f 81       	ldd	r25, Y+7	; 0x07
    3132:	00 97       	sbiw	r24, 0x00	; 0
    3134:	21 f4       	brne	.+8      	; 0x313e <xStreamBufferSetTriggerLevel+0x34>
	{
		xTriggerLevel = ( size_t ) 1;
    3136:	81 e0       	ldi	r24, 0x01	; 1
    3138:	90 e0       	ldi	r25, 0x00	; 0
    313a:	9f 83       	std	Y+7, r25	; 0x07
    313c:	8e 83       	std	Y+6, r24	; 0x06
	}

	/* The trigger level is the number of bytes that must be in the stream
	buffer before a task that is waiting for data is unblocked. */
	if( xTriggerLevel <= pxStreamBuffer->xLength )
    313e:	ea 81       	ldd	r30, Y+2	; 0x02
    3140:	fb 81       	ldd	r31, Y+3	; 0x03
    3142:	24 81       	ldd	r18, Z+4	; 0x04
    3144:	35 81       	ldd	r19, Z+5	; 0x05
    3146:	8e 81       	ldd	r24, Y+6	; 0x06
    3148:	9f 81       	ldd	r25, Y+7	; 0x07
    314a:	28 17       	cp	r18, r24
    314c:	39 07       	cpc	r19, r25
    314e:	48 f0       	brcs	.+18     	; 0x3162 <xStreamBufferSetTriggerLevel+0x58>
	{
		pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
    3150:	ea 81       	ldd	r30, Y+2	; 0x02
    3152:	fb 81       	ldd	r31, Y+3	; 0x03
    3154:	8e 81       	ldd	r24, Y+6	; 0x06
    3156:	9f 81       	ldd	r25, Y+7	; 0x07
    3158:	97 83       	std	Z+7, r25	; 0x07
    315a:	86 83       	std	Z+6, r24	; 0x06
		xReturn = pdPASS;
    315c:	81 e0       	ldi	r24, 0x01	; 1
    315e:	89 83       	std	Y+1, r24	; 0x01
    3160:	01 c0       	rjmp	.+2      	; 0x3164 <xStreamBufferSetTriggerLevel+0x5a>
	}
	else
	{
		xReturn = pdFALSE;
    3162:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3164:	89 81       	ldd	r24, Y+1	; 0x01
}
    3166:	27 96       	adiw	r28, 0x07	; 7
    3168:	0f b6       	in	r0, 0x3f	; 63
    316a:	f8 94       	cli
    316c:	de bf       	out	0x3e, r29	; 62
    316e:	0f be       	out	0x3f, r0	; 63
    3170:	cd bf       	out	0x3d, r28	; 61
    3172:	cf 91       	pop	r28
    3174:	df 91       	pop	r29
    3176:	08 95       	ret

00003178 <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    3178:	df 93       	push	r29
    317a:	cf 93       	push	r28
    317c:	00 d0       	rcall	.+0      	; 0x317e <xStreamBufferSpacesAvailable+0x6>
    317e:	00 d0       	rcall	.+0      	; 0x3180 <xStreamBufferSpacesAvailable+0x8>
    3180:	00 d0       	rcall	.+0      	; 0x3182 <xStreamBufferSpacesAvailable+0xa>
    3182:	cd b7       	in	r28, 0x3d	; 61
    3184:	de b7       	in	r29, 0x3e	; 62
    3186:	9e 83       	std	Y+6, r25	; 0x06
    3188:	8d 83       	std	Y+5, r24	; 0x05
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    318a:	8d 81       	ldd	r24, Y+5	; 0x05
    318c:	9e 81       	ldd	r25, Y+6	; 0x06
    318e:	9c 83       	std	Y+4, r25	; 0x04
    3190:	8b 83       	std	Y+3, r24	; 0x03
size_t xSpace;

	configASSERT( pxStreamBuffer );

	xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    3192:	eb 81       	ldd	r30, Y+3	; 0x03
    3194:	fc 81       	ldd	r31, Y+4	; 0x04
    3196:	24 81       	ldd	r18, Z+4	; 0x04
    3198:	35 81       	ldd	r19, Z+5	; 0x05
    319a:	eb 81       	ldd	r30, Y+3	; 0x03
    319c:	fc 81       	ldd	r31, Y+4	; 0x04
    319e:	80 81       	ld	r24, Z
    31a0:	91 81       	ldd	r25, Z+1	; 0x01
    31a2:	82 0f       	add	r24, r18
    31a4:	93 1f       	adc	r25, r19
    31a6:	9a 83       	std	Y+2, r25	; 0x02
    31a8:	89 83       	std	Y+1, r24	; 0x01
	xSpace -= pxStreamBuffer->xHead;
    31aa:	eb 81       	ldd	r30, Y+3	; 0x03
    31ac:	fc 81       	ldd	r31, Y+4	; 0x04
    31ae:	22 81       	ldd	r18, Z+2	; 0x02
    31b0:	33 81       	ldd	r19, Z+3	; 0x03
    31b2:	89 81       	ldd	r24, Y+1	; 0x01
    31b4:	9a 81       	ldd	r25, Y+2	; 0x02
    31b6:	82 1b       	sub	r24, r18
    31b8:	93 0b       	sbc	r25, r19
    31ba:	9a 83       	std	Y+2, r25	; 0x02
    31bc:	89 83       	std	Y+1, r24	; 0x01
	xSpace -= ( size_t ) 1;
    31be:	89 81       	ldd	r24, Y+1	; 0x01
    31c0:	9a 81       	ldd	r25, Y+2	; 0x02
    31c2:	01 97       	sbiw	r24, 0x01	; 1
    31c4:	9a 83       	std	Y+2, r25	; 0x02
    31c6:	89 83       	std	Y+1, r24	; 0x01

	if( xSpace >= pxStreamBuffer->xLength )
    31c8:	eb 81       	ldd	r30, Y+3	; 0x03
    31ca:	fc 81       	ldd	r31, Y+4	; 0x04
    31cc:	24 81       	ldd	r18, Z+4	; 0x04
    31ce:	35 81       	ldd	r19, Z+5	; 0x05
    31d0:	89 81       	ldd	r24, Y+1	; 0x01
    31d2:	9a 81       	ldd	r25, Y+2	; 0x02
    31d4:	82 17       	cp	r24, r18
    31d6:	93 07       	cpc	r25, r19
    31d8:	50 f0       	brcs	.+20     	; 0x31ee <xStreamBufferSpacesAvailable+0x76>
	{
		xSpace -= pxStreamBuffer->xLength;
    31da:	eb 81       	ldd	r30, Y+3	; 0x03
    31dc:	fc 81       	ldd	r31, Y+4	; 0x04
    31de:	24 81       	ldd	r18, Z+4	; 0x04
    31e0:	35 81       	ldd	r19, Z+5	; 0x05
    31e2:	89 81       	ldd	r24, Y+1	; 0x01
    31e4:	9a 81       	ldd	r25, Y+2	; 0x02
    31e6:	82 1b       	sub	r24, r18
    31e8:	93 0b       	sbc	r25, r19
    31ea:	9a 83       	std	Y+2, r25	; 0x02
    31ec:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xSpace;
    31ee:	89 81       	ldd	r24, Y+1	; 0x01
    31f0:	9a 81       	ldd	r25, Y+2	; 0x02
}
    31f2:	26 96       	adiw	r28, 0x06	; 6
    31f4:	0f b6       	in	r0, 0x3f	; 63
    31f6:	f8 94       	cli
    31f8:	de bf       	out	0x3e, r29	; 62
    31fa:	0f be       	out	0x3f, r0	; 63
    31fc:	cd bf       	out	0x3d, r28	; 61
    31fe:	cf 91       	pop	r28
    3200:	df 91       	pop	r29
    3202:	08 95       	ret

00003204 <xStreamBufferBytesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    3204:	df 93       	push	r29
    3206:	cf 93       	push	r28
    3208:	00 d0       	rcall	.+0      	; 0x320a <xStreamBufferBytesAvailable+0x6>
    320a:	00 d0       	rcall	.+0      	; 0x320c <xStreamBufferBytesAvailable+0x8>
    320c:	00 d0       	rcall	.+0      	; 0x320e <xStreamBufferBytesAvailable+0xa>
    320e:	cd b7       	in	r28, 0x3d	; 61
    3210:	de b7       	in	r29, 0x3e	; 62
    3212:	9e 83       	std	Y+6, r25	; 0x06
    3214:	8d 83       	std	Y+5, r24	; 0x05
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3216:	8d 81       	ldd	r24, Y+5	; 0x05
    3218:	9e 81       	ldd	r25, Y+6	; 0x06
    321a:	9c 83       	std	Y+4, r25	; 0x04
    321c:	8b 83       	std	Y+3, r24	; 0x03
size_t xReturn;

	configASSERT( pxStreamBuffer );

	xReturn = prvBytesInBuffer( pxStreamBuffer );
    321e:	8b 81       	ldd	r24, Y+3	; 0x03
    3220:	9c 81       	ldd	r25, Y+4	; 0x04
    3222:	0e 94 ec 1e 	call	0x3dd8	; 0x3dd8 <prvBytesInBuffer>
    3226:	9a 83       	std	Y+2, r25	; 0x02
    3228:	89 83       	std	Y+1, r24	; 0x01
	return xReturn;
    322a:	89 81       	ldd	r24, Y+1	; 0x01
    322c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    322e:	26 96       	adiw	r28, 0x06	; 6
    3230:	0f b6       	in	r0, 0x3f	; 63
    3232:	f8 94       	cli
    3234:	de bf       	out	0x3e, r29	; 62
    3236:	0f be       	out	0x3f, r0	; 63
    3238:	cd bf       	out	0x3d, r28	; 61
    323a:	cf 91       	pop	r28
    323c:	df 91       	pop	r29
    323e:	08 95       	ret

00003240 <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
						  const void *pvTxData,
						  size_t xDataLengthBytes,
						  TickType_t xTicksToWait )
{
    3240:	ef 92       	push	r14
    3242:	ff 92       	push	r15
    3244:	0f 93       	push	r16
    3246:	1f 93       	push	r17
    3248:	df 93       	push	r29
    324a:	cf 93       	push	r28
    324c:	cd b7       	in	r28, 0x3d	; 61
    324e:	de b7       	in	r29, 0x3e	; 62
    3250:	63 97       	sbiw	r28, 0x13	; 19
    3252:	0f b6       	in	r0, 0x3f	; 63
    3254:	f8 94       	cli
    3256:	de bf       	out	0x3e, r29	; 62
    3258:	0f be       	out	0x3f, r0	; 63
    325a:	cd bf       	out	0x3d, r28	; 61
    325c:	9d 87       	std	Y+13, r25	; 0x0d
    325e:	8c 87       	std	Y+12, r24	; 0x0c
    3260:	7f 87       	std	Y+15, r23	; 0x0f
    3262:	6e 87       	std	Y+14, r22	; 0x0e
    3264:	59 8b       	std	Y+17, r21	; 0x11
    3266:	48 8b       	std	Y+16, r20	; 0x10
    3268:	3b 8b       	std	Y+19, r19	; 0x13
    326a:	2a 8b       	std	Y+18, r18	; 0x12
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    326c:	8c 85       	ldd	r24, Y+12	; 0x0c
    326e:	9d 85       	ldd	r25, Y+13	; 0x0d
    3270:	98 87       	std	Y+8, r25	; 0x08
    3272:	8f 83       	std	Y+7, r24	; 0x07
size_t xReturn, xSpace = 0;
    3274:	1c 82       	std	Y+4, r1	; 0x04
    3276:	1b 82       	std	Y+3, r1	; 0x03
size_t xRequiredSpace = xDataLengthBytes;
    3278:	88 89       	ldd	r24, Y+16	; 0x10
    327a:	99 89       	ldd	r25, Y+17	; 0x11
    327c:	9a 83       	std	Y+2, r25	; 0x02
    327e:	89 83       	std	Y+1, r24	; 0x01

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3280:	ef 81       	ldd	r30, Y+7	; 0x07
    3282:	f8 85       	ldd	r31, Y+8	; 0x08
    3284:	86 85       	ldd	r24, Z+14	; 0x0e
    3286:	88 2f       	mov	r24, r24
    3288:	90 e0       	ldi	r25, 0x00	; 0
    328a:	81 70       	andi	r24, 0x01	; 1
    328c:	90 70       	andi	r25, 0x00	; 0
    328e:	88 23       	and	r24, r24
    3290:	29 f0       	breq	.+10     	; 0x329c <xStreamBufferSend+0x5c>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3292:	89 81       	ldd	r24, Y+1	; 0x01
    3294:	9a 81       	ldd	r25, Y+2	; 0x02
    3296:	02 96       	adiw	r24, 0x02	; 2
    3298:	9a 83       	std	Y+2, r25	; 0x02
    329a:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    329c:	8a 89       	ldd	r24, Y+18	; 0x12
    329e:	9b 89       	ldd	r25, Y+19	; 0x13
    32a0:	00 97       	sbiw	r24, 0x00	; 0
    32a2:	09 f4       	brne	.+2      	; 0x32a6 <xStreamBufferSend+0x66>
    32a4:	40 c0       	rjmp	.+128    	; 0x3326 <xStreamBufferSend+0xe6>
	{
		vTaskSetTimeOutState( &xTimeOut );
    32a6:	ce 01       	movw	r24, r28
    32a8:	09 96       	adiw	r24, 0x09	; 9
    32aa:	0e 94 7b 26 	call	0x4cf6	; 0x4cf6 <vTaskSetTimeOutState>

		do
		{
			/* Wait until the required number of bytes are free in the message
			buffer. */
			taskENTER_CRITICAL();
    32ae:	0f b6       	in	r0, 0x3f	; 63
    32b0:	f8 94       	cli
    32b2:	0f 92       	push	r0
			{
				xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    32b4:	8f 81       	ldd	r24, Y+7	; 0x07
    32b6:	98 85       	ldd	r25, Y+8	; 0x08
    32b8:	0e 94 bc 18 	call	0x3178	; 0x3178 <xStreamBufferSpacesAvailable>
    32bc:	9c 83       	std	Y+4, r25	; 0x04
    32be:	8b 83       	std	Y+3, r24	; 0x03

				if( xSpace < xRequiredSpace )
    32c0:	2b 81       	ldd	r18, Y+3	; 0x03
    32c2:	3c 81       	ldd	r19, Y+4	; 0x04
    32c4:	89 81       	ldd	r24, Y+1	; 0x01
    32c6:	9a 81       	ldd	r25, Y+2	; 0x02
    32c8:	28 17       	cp	r18, r24
    32ca:	39 07       	cpc	r19, r25
    32cc:	50 f5       	brcc	.+84     	; 0x3322 <xStreamBufferSend+0xe2>
				{
					/* Clear notification state as going to wait for space. */
					( void ) xTaskNotifyStateClear( NULL );
    32ce:	80 e0       	ldi	r24, 0x00	; 0
    32d0:	90 e0       	ldi	r25, 0x00	; 0
    32d2:	0e 94 85 2b 	call	0x570a	; 0x570a <xTaskNotifyStateClear>

					/* Should only be one writer. */
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
    32d6:	0e 94 e6 27 	call	0x4fcc	; 0x4fcc <xTaskGetCurrentTaskHandle>
    32da:	ef 81       	ldd	r30, Y+7	; 0x07
    32dc:	f8 85       	ldd	r31, Y+8	; 0x08
    32de:	93 87       	std	Z+11, r25	; 0x0b
    32e0:	82 87       	std	Z+10, r24	; 0x0a
				{
					taskEXIT_CRITICAL();
					break;
				}
			}
			taskEXIT_CRITICAL();
    32e2:	0f 90       	pop	r0
    32e4:	0f be       	out	0x3f, r0	; 63

			traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    32e6:	ea 89       	ldd	r30, Y+18	; 0x12
    32e8:	fb 89       	ldd	r31, Y+19	; 0x13
    32ea:	60 e0       	ldi	r22, 0x00	; 0
    32ec:	70 e0       	ldi	r23, 0x00	; 0
    32ee:	80 e0       	ldi	r24, 0x00	; 0
    32f0:	90 e0       	ldi	r25, 0x00	; 0
    32f2:	20 e0       	ldi	r18, 0x00	; 0
    32f4:	30 e0       	ldi	r19, 0x00	; 0
    32f6:	40 e0       	ldi	r20, 0x00	; 0
    32f8:	50 e0       	ldi	r21, 0x00	; 0
    32fa:	00 e0       	ldi	r16, 0x00	; 0
    32fc:	10 e0       	ldi	r17, 0x00	; 0
    32fe:	7f 01       	movw	r14, r30
    3300:	0e 94 96 28 	call	0x512c	; 0x512c <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToSend = NULL;
    3304:	ef 81       	ldd	r30, Y+7	; 0x07
    3306:	f8 85       	ldd	r31, Y+8	; 0x08
    3308:	13 86       	std	Z+11, r1	; 0x0b
    330a:	12 86       	std	Z+10, r1	; 0x0a

		} while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
    330c:	ce 01       	movw	r24, r28
    330e:	09 96       	adiw	r24, 0x09	; 9
    3310:	9e 01       	movw	r18, r28
    3312:	2e 5e       	subi	r18, 0xEE	; 238
    3314:	3f 4f       	sbci	r19, 0xFF	; 255
    3316:	b9 01       	movw	r22, r18
    3318:	0e 94 b2 26 	call	0x4d64	; 0x4d64 <xTaskCheckForTimeOut>
    331c:	88 23       	and	r24, r24
    331e:	39 f2       	breq	.-114    	; 0x32ae <xStreamBufferSend+0x6e>
    3320:	02 c0       	rjmp	.+4      	; 0x3326 <xStreamBufferSend+0xe6>
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
				}
				else
				{
					taskEXIT_CRITICAL();
    3322:	0f 90       	pop	r0
    3324:	0f be       	out	0x3f, r0	; 63
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xSpace == ( size_t ) 0 )
    3326:	8b 81       	ldd	r24, Y+3	; 0x03
    3328:	9c 81       	ldd	r25, Y+4	; 0x04
    332a:	00 97       	sbiw	r24, 0x00	; 0
    332c:	31 f4       	brne	.+12     	; 0x333a <xStreamBufferSend+0xfa>
	{
		xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    332e:	8f 81       	ldd	r24, Y+7	; 0x07
    3330:	98 85       	ldd	r25, Y+8	; 0x08
    3332:	0e 94 bc 18 	call	0x3178	; 0x3178 <xStreamBufferSpacesAvailable>
    3336:	9c 83       	std	Y+4, r25	; 0x04
    3338:	8b 83       	std	Y+3, r24	; 0x03
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    333a:	8f 81       	ldd	r24, Y+7	; 0x07
    333c:	98 85       	ldd	r25, Y+8	; 0x08
    333e:	2e 85       	ldd	r18, Y+14	; 0x0e
    3340:	3f 85       	ldd	r19, Y+15	; 0x0f
    3342:	48 89       	ldd	r20, Y+16	; 0x10
    3344:	59 89       	ldd	r21, Y+17	; 0x11
    3346:	eb 81       	ldd	r30, Y+3	; 0x03
    3348:	fc 81       	ldd	r31, Y+4	; 0x04
    334a:	a9 81       	ldd	r26, Y+1	; 0x01
    334c:	ba 81       	ldd	r27, Y+2	; 0x02
    334e:	b9 01       	movw	r22, r18
    3350:	9f 01       	movw	r18, r30
    3352:	8d 01       	movw	r16, r26
    3354:	0e 94 65 1a 	call	0x34ca	; 0x34ca <prvWriteMessageToBuffer>
    3358:	9e 83       	std	Y+6, r25	; 0x06
    335a:	8d 83       	std	Y+5, r24	; 0x05

	if( xReturn > ( size_t ) 0 )
    335c:	8d 81       	ldd	r24, Y+5	; 0x05
    335e:	9e 81       	ldd	r25, Y+6	; 0x06
    3360:	00 97       	sbiw	r24, 0x00	; 0
    3362:	39 f1       	breq	.+78     	; 0x33b2 <xStreamBufferSend+0x172>
	{
		traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    3364:	8f 81       	ldd	r24, Y+7	; 0x07
    3366:	98 85       	ldd	r25, Y+8	; 0x08
    3368:	0e 94 ec 1e 	call	0x3dd8	; 0x3dd8 <prvBytesInBuffer>
    336c:	9c 01       	movw	r18, r24
    336e:	ef 81       	ldd	r30, Y+7	; 0x07
    3370:	f8 85       	ldd	r31, Y+8	; 0x08
    3372:	86 81       	ldd	r24, Z+6	; 0x06
    3374:	97 81       	ldd	r25, Z+7	; 0x07
    3376:	28 17       	cp	r18, r24
    3378:	39 07       	cpc	r19, r25
    337a:	d8 f0       	brcs	.+54     	; 0x33b2 <xStreamBufferSend+0x172>
		{
			sbSEND_COMPLETED( pxStreamBuffer );
    337c:	0e 94 43 23 	call	0x4686	; 0x4686 <vTaskSuspendAll>
    3380:	ef 81       	ldd	r30, Y+7	; 0x07
    3382:	f8 85       	ldd	r31, Y+8	; 0x08
    3384:	80 85       	ldd	r24, Z+8	; 0x08
    3386:	91 85       	ldd	r25, Z+9	; 0x09
    3388:	00 97       	sbiw	r24, 0x00	; 0
    338a:	89 f0       	breq	.+34     	; 0x33ae <xStreamBufferSend+0x16e>
    338c:	ef 81       	ldd	r30, Y+7	; 0x07
    338e:	f8 85       	ldd	r31, Y+8	; 0x08
    3390:	80 85       	ldd	r24, Z+8	; 0x08
    3392:	91 85       	ldd	r25, Z+9	; 0x09
    3394:	40 e0       	ldi	r20, 0x00	; 0
    3396:	50 e0       	ldi	r21, 0x00	; 0
    3398:	60 e0       	ldi	r22, 0x00	; 0
    339a:	70 e0       	ldi	r23, 0x00	; 0
    339c:	20 e0       	ldi	r18, 0x00	; 0
    339e:	00 e0       	ldi	r16, 0x00	; 0
    33a0:	10 e0       	ldi	r17, 0x00	; 0
    33a2:	0e 94 32 29 	call	0x5264	; 0x5264 <xTaskGenericNotify>
    33a6:	ef 81       	ldd	r30, Y+7	; 0x07
    33a8:	f8 85       	ldd	r31, Y+8	; 0x08
    33aa:	11 86       	std	Z+9, r1	; 0x09
    33ac:	10 86       	std	Z+8, r1	; 0x08
    33ae:	0e 94 4f 23 	call	0x469e	; 0x469e <xTaskResumeAll>
	{
		mtCOVERAGE_TEST_MARKER();
		traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
	}

	return xReturn;
    33b2:	8d 81       	ldd	r24, Y+5	; 0x05
    33b4:	9e 81       	ldd	r25, Y+6	; 0x06
}
    33b6:	63 96       	adiw	r28, 0x13	; 19
    33b8:	0f b6       	in	r0, 0x3f	; 63
    33ba:	f8 94       	cli
    33bc:	de bf       	out	0x3e, r29	; 62
    33be:	0f be       	out	0x3f, r0	; 63
    33c0:	cd bf       	out	0x3d, r28	; 61
    33c2:	cf 91       	pop	r28
    33c4:	df 91       	pop	r29
    33c6:	1f 91       	pop	r17
    33c8:	0f 91       	pop	r16
    33ca:	ff 90       	pop	r15
    33cc:	ef 90       	pop	r14
    33ce:	08 95       	ret

000033d0 <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
								 const void *pvTxData,
								 size_t xDataLengthBytes,
								 BaseType_t * const pxHigherPriorityTaskWoken )
{
    33d0:	ef 92       	push	r14
    33d2:	ff 92       	push	r15
    33d4:	0f 93       	push	r16
    33d6:	1f 93       	push	r17
    33d8:	df 93       	push	r29
    33da:	cf 93       	push	r28
    33dc:	cd b7       	in	r28, 0x3d	; 61
    33de:	de b7       	in	r29, 0x3e	; 62
    33e0:	61 97       	sbiw	r28, 0x11	; 17
    33e2:	0f b6       	in	r0, 0x3f	; 63
    33e4:	f8 94       	cli
    33e6:	de bf       	out	0x3e, r29	; 62
    33e8:	0f be       	out	0x3f, r0	; 63
    33ea:	cd bf       	out	0x3d, r28	; 61
    33ec:	9b 87       	std	Y+11, r25	; 0x0b
    33ee:	8a 87       	std	Y+10, r24	; 0x0a
    33f0:	7d 87       	std	Y+13, r23	; 0x0d
    33f2:	6c 87       	std	Y+12, r22	; 0x0c
    33f4:	5f 87       	std	Y+15, r21	; 0x0f
    33f6:	4e 87       	std	Y+14, r20	; 0x0e
    33f8:	39 8b       	std	Y+17, r19	; 0x11
    33fa:	28 8b       	std	Y+16, r18	; 0x10
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    33fc:	8a 85       	ldd	r24, Y+10	; 0x0a
    33fe:	9b 85       	ldd	r25, Y+11	; 0x0b
    3400:	99 87       	std	Y+9, r25	; 0x09
    3402:	88 87       	std	Y+8, r24	; 0x08
size_t xReturn, xSpace;
size_t xRequiredSpace = xDataLengthBytes;
    3404:	8e 85       	ldd	r24, Y+14	; 0x0e
    3406:	9f 85       	ldd	r25, Y+15	; 0x0f
    3408:	9b 83       	std	Y+3, r25	; 0x03
    340a:	8a 83       	std	Y+2, r24	; 0x02

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    340c:	e8 85       	ldd	r30, Y+8	; 0x08
    340e:	f9 85       	ldd	r31, Y+9	; 0x09
    3410:	86 85       	ldd	r24, Z+14	; 0x0e
    3412:	88 2f       	mov	r24, r24
    3414:	90 e0       	ldi	r25, 0x00	; 0
    3416:	81 70       	andi	r24, 0x01	; 1
    3418:	90 70       	andi	r25, 0x00	; 0
    341a:	88 23       	and	r24, r24
    341c:	29 f0       	breq	.+10     	; 0x3428 <xStreamBufferSendFromISR+0x58>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    341e:	8a 81       	ldd	r24, Y+2	; 0x02
    3420:	9b 81       	ldd	r25, Y+3	; 0x03
    3422:	02 96       	adiw	r24, 0x02	; 2
    3424:	9b 83       	std	Y+3, r25	; 0x03
    3426:	8a 83       	std	Y+2, r24	; 0x02
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    3428:	88 85       	ldd	r24, Y+8	; 0x08
    342a:	99 85       	ldd	r25, Y+9	; 0x09
    342c:	0e 94 bc 18 	call	0x3178	; 0x3178 <xStreamBufferSpacesAvailable>
    3430:	9d 83       	std	Y+5, r25	; 0x05
    3432:	8c 83       	std	Y+4, r24	; 0x04
	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    3434:	88 85       	ldd	r24, Y+8	; 0x08
    3436:	99 85       	ldd	r25, Y+9	; 0x09
    3438:	2c 85       	ldd	r18, Y+12	; 0x0c
    343a:	3d 85       	ldd	r19, Y+13	; 0x0d
    343c:	4e 85       	ldd	r20, Y+14	; 0x0e
    343e:	5f 85       	ldd	r21, Y+15	; 0x0f
    3440:	ec 81       	ldd	r30, Y+4	; 0x04
    3442:	fd 81       	ldd	r31, Y+5	; 0x05
    3444:	aa 81       	ldd	r26, Y+2	; 0x02
    3446:	bb 81       	ldd	r27, Y+3	; 0x03
    3448:	b9 01       	movw	r22, r18
    344a:	9f 01       	movw	r18, r30
    344c:	8d 01       	movw	r16, r26
    344e:	0e 94 65 1a 	call	0x34ca	; 0x34ca <prvWriteMessageToBuffer>
    3452:	9f 83       	std	Y+7, r25	; 0x07
    3454:	8e 83       	std	Y+6, r24	; 0x06

	if( xReturn > ( size_t ) 0 )
    3456:	8e 81       	ldd	r24, Y+6	; 0x06
    3458:	9f 81       	ldd	r25, Y+7	; 0x07
    345a:	00 97       	sbiw	r24, 0x00	; 0
    345c:	39 f1       	breq	.+78     	; 0x34ac <xStreamBufferSendFromISR+0xdc>
	{
		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    345e:	88 85       	ldd	r24, Y+8	; 0x08
    3460:	99 85       	ldd	r25, Y+9	; 0x09
    3462:	0e 94 ec 1e 	call	0x3dd8	; 0x3dd8 <prvBytesInBuffer>
    3466:	9c 01       	movw	r18, r24
    3468:	e8 85       	ldd	r30, Y+8	; 0x08
    346a:	f9 85       	ldd	r31, Y+9	; 0x09
    346c:	86 81       	ldd	r24, Z+6	; 0x06
    346e:	97 81       	ldd	r25, Z+7	; 0x07
    3470:	28 17       	cp	r18, r24
    3472:	39 07       	cpc	r19, r25
    3474:	d8 f0       	brcs	.+54     	; 0x34ac <xStreamBufferSendFromISR+0xdc>
		{
			sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    3476:	19 82       	std	Y+1, r1	; 0x01
    3478:	e8 85       	ldd	r30, Y+8	; 0x08
    347a:	f9 85       	ldd	r31, Y+9	; 0x09
    347c:	80 85       	ldd	r24, Z+8	; 0x08
    347e:	91 85       	ldd	r25, Z+9	; 0x09
    3480:	00 97       	sbiw	r24, 0x00	; 0
    3482:	a1 f0       	breq	.+40     	; 0x34ac <xStreamBufferSendFromISR+0xdc>
    3484:	e8 85       	ldd	r30, Y+8	; 0x08
    3486:	f9 85       	ldd	r31, Y+9	; 0x09
    3488:	80 85       	ldd	r24, Z+8	; 0x08
    348a:	91 85       	ldd	r25, Z+9	; 0x09
    348c:	e8 89       	ldd	r30, Y+16	; 0x10
    348e:	f9 89       	ldd	r31, Y+17	; 0x11
    3490:	40 e0       	ldi	r20, 0x00	; 0
    3492:	50 e0       	ldi	r21, 0x00	; 0
    3494:	60 e0       	ldi	r22, 0x00	; 0
    3496:	70 e0       	ldi	r23, 0x00	; 0
    3498:	20 e0       	ldi	r18, 0x00	; 0
    349a:	00 e0       	ldi	r16, 0x00	; 0
    349c:	10 e0       	ldi	r17, 0x00	; 0
    349e:	7f 01       	movw	r14, r30
    34a0:	0e 94 07 2a 	call	0x540e	; 0x540e <xTaskGenericNotifyFromISR>
    34a4:	e8 85       	ldd	r30, Y+8	; 0x08
    34a6:	f9 85       	ldd	r31, Y+9	; 0x09
    34a8:	11 86       	std	Z+9, r1	; 0x09
    34aa:	10 86       	std	Z+8, r1	; 0x08
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

	return xReturn;
    34ac:	8e 81       	ldd	r24, Y+6	; 0x06
    34ae:	9f 81       	ldd	r25, Y+7	; 0x07
}
    34b0:	61 96       	adiw	r28, 0x11	; 17
    34b2:	0f b6       	in	r0, 0x3f	; 63
    34b4:	f8 94       	cli
    34b6:	de bf       	out	0x3e, r29	; 62
    34b8:	0f be       	out	0x3f, r0	; 63
    34ba:	cd bf       	out	0x3d, r28	; 61
    34bc:	cf 91       	pop	r28
    34be:	df 91       	pop	r29
    34c0:	1f 91       	pop	r17
    34c2:	0f 91       	pop	r16
    34c4:	ff 90       	pop	r15
    34c6:	ef 90       	pop	r14
    34c8:	08 95       	ret

000034ca <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
									   const void * pvTxData,
									   size_t xDataLengthBytes,
									   size_t xSpace,
									   size_t xRequiredSpace )
{
    34ca:	0f 93       	push	r16
    34cc:	1f 93       	push	r17
    34ce:	df 93       	push	r29
    34d0:	cf 93       	push	r28
    34d2:	cd b7       	in	r28, 0x3d	; 61
    34d4:	de b7       	in	r29, 0x3e	; 62
    34d6:	61 97       	sbiw	r28, 0x11	; 17
    34d8:	0f b6       	in	r0, 0x3f	; 63
    34da:	f8 94       	cli
    34dc:	de bf       	out	0x3e, r29	; 62
    34de:	0f be       	out	0x3f, r0	; 63
    34e0:	cd bf       	out	0x3d, r28	; 61
    34e2:	9d 83       	std	Y+5, r25	; 0x05
    34e4:	8c 83       	std	Y+4, r24	; 0x04
    34e6:	7f 83       	std	Y+7, r23	; 0x07
    34e8:	6e 83       	std	Y+6, r22	; 0x06
    34ea:	59 87       	std	Y+9, r21	; 0x09
    34ec:	48 87       	std	Y+8, r20	; 0x08
    34ee:	3b 87       	std	Y+11, r19	; 0x0b
    34f0:	2a 87       	std	Y+10, r18	; 0x0a
    34f2:	1d 87       	std	Y+13, r17	; 0x0d
    34f4:	0c 87       	std	Y+12, r16	; 0x0c
	BaseType_t xShouldWrite;
	size_t xReturn;

	if( xSpace == ( size_t ) 0 )
    34f6:	8a 85       	ldd	r24, Y+10	; 0x0a
    34f8:	9b 85       	ldd	r25, Y+11	; 0x0b
    34fa:	00 97       	sbiw	r24, 0x00	; 0
    34fc:	11 f4       	brne	.+4      	; 0x3502 <prvWriteMessageToBuffer+0x38>
	{
		/* Doesn't matter if this is a stream buffer or a message buffer, there
		is no space to write. */
		xShouldWrite = pdFALSE;
    34fe:	1b 82       	std	Y+3, r1	; 0x03
    3500:	38 c0       	rjmp	.+112    	; 0x3572 <prvWriteMessageToBuffer+0xa8>
	}
	else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )
    3502:	ec 81       	ldd	r30, Y+4	; 0x04
    3504:	fd 81       	ldd	r31, Y+5	; 0x05
    3506:	86 85       	ldd	r24, Z+14	; 0x0e
    3508:	88 2f       	mov	r24, r24
    350a:	90 e0       	ldi	r25, 0x00	; 0
    350c:	81 70       	andi	r24, 0x01	; 1
    350e:	90 70       	andi	r25, 0x00	; 0
    3510:	00 97       	sbiw	r24, 0x00	; 0
    3512:	d1 f4       	brne	.+52     	; 0x3548 <prvWriteMessageToBuffer+0x7e>
	{
		/* This is a stream buffer, as opposed to a message buffer, so writing a
		stream of bytes rather than discrete messages.  Write as many bytes as
		possible. */
		xShouldWrite = pdTRUE;
    3514:	81 e0       	ldi	r24, 0x01	; 1
    3516:	8b 83       	std	Y+3, r24	; 0x03
		xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
    3518:	28 85       	ldd	r18, Y+8	; 0x08
    351a:	39 85       	ldd	r19, Y+9	; 0x09
    351c:	39 8b       	std	Y+17, r19	; 0x11
    351e:	28 8b       	std	Y+16, r18	; 0x10
    3520:	8a 85       	ldd	r24, Y+10	; 0x0a
    3522:	9b 85       	ldd	r25, Y+11	; 0x0b
    3524:	9f 87       	std	Y+15, r25	; 0x0f
    3526:	8e 87       	std	Y+14, r24	; 0x0e
    3528:	2e 85       	ldd	r18, Y+14	; 0x0e
    352a:	3f 85       	ldd	r19, Y+15	; 0x0f
    352c:	88 89       	ldd	r24, Y+16	; 0x10
    352e:	99 89       	ldd	r25, Y+17	; 0x11
    3530:	82 17       	cp	r24, r18
    3532:	93 07       	cpc	r25, r19
    3534:	20 f4       	brcc	.+8      	; 0x353e <prvWriteMessageToBuffer+0x74>
    3536:	28 89       	ldd	r18, Y+16	; 0x10
    3538:	39 89       	ldd	r19, Y+17	; 0x11
    353a:	3f 87       	std	Y+15, r19	; 0x0f
    353c:	2e 87       	std	Y+14, r18	; 0x0e
    353e:	8e 85       	ldd	r24, Y+14	; 0x0e
    3540:	9f 85       	ldd	r25, Y+15	; 0x0f
    3542:	99 87       	std	Y+9, r25	; 0x09
    3544:	88 87       	std	Y+8, r24	; 0x08
    3546:	15 c0       	rjmp	.+42     	; 0x3572 <prvWriteMessageToBuffer+0xa8>
	}
	else if( xSpace >= xRequiredSpace )
    3548:	2a 85       	ldd	r18, Y+10	; 0x0a
    354a:	3b 85       	ldd	r19, Y+11	; 0x0b
    354c:	8c 85       	ldd	r24, Y+12	; 0x0c
    354e:	9d 85       	ldd	r25, Y+13	; 0x0d
    3550:	28 17       	cp	r18, r24
    3552:	39 07       	cpc	r19, r25
    3554:	68 f0       	brcs	.+26     	; 0x3570 <prvWriteMessageToBuffer+0xa6>
	{
		/* This is a message buffer, as opposed to a stream buffer, and there
		is enough space to write both the message length and the message itself
		into the buffer.  Start by writing the length of the data, the data
		itself will be written later in this function. */
		xShouldWrite = pdTRUE;
    3556:	81 e0       	ldi	r24, 0x01	; 1
    3558:	8b 83       	std	Y+3, r24	; 0x03
		( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH );
    355a:	9e 01       	movw	r18, r28
    355c:	28 5f       	subi	r18, 0xF8	; 248
    355e:	3f 4f       	sbci	r19, 0xFF	; 255
    3560:	8c 81       	ldd	r24, Y+4	; 0x04
    3562:	9d 81       	ldd	r25, Y+5	; 0x05
    3564:	b9 01       	movw	r22, r18
    3566:	42 e0       	ldi	r20, 0x02	; 2
    3568:	50 e0       	ldi	r21, 0x00	; 0
    356a:	0e 94 b2 1d 	call	0x3b64	; 0x3b64 <prvWriteBytesToBuffer>
    356e:	01 c0       	rjmp	.+2      	; 0x3572 <prvWriteMessageToBuffer+0xa8>
	}
	else
	{
		/* There is space available, but not enough space. */
		xShouldWrite = pdFALSE;
    3570:	1b 82       	std	Y+3, r1	; 0x03
	}

	if( xShouldWrite != pdFALSE )
    3572:	8b 81       	ldd	r24, Y+3	; 0x03
    3574:	88 23       	and	r24, r24
    3576:	61 f0       	breq	.+24     	; 0x3590 <prvWriteMessageToBuffer+0xc6>
	{
		/* Writes the data itself. */
		xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alighment and access. */
    3578:	2e 81       	ldd	r18, Y+6	; 0x06
    357a:	3f 81       	ldd	r19, Y+7	; 0x07
    357c:	48 85       	ldd	r20, Y+8	; 0x08
    357e:	59 85       	ldd	r21, Y+9	; 0x09
    3580:	8c 81       	ldd	r24, Y+4	; 0x04
    3582:	9d 81       	ldd	r25, Y+5	; 0x05
    3584:	b9 01       	movw	r22, r18
    3586:	0e 94 b2 1d 	call	0x3b64	; 0x3b64 <prvWriteBytesToBuffer>
    358a:	9a 83       	std	Y+2, r25	; 0x02
    358c:	89 83       	std	Y+1, r24	; 0x01
    358e:	02 c0       	rjmp	.+4      	; 0x3594 <prvWriteMessageToBuffer+0xca>
	}
	else
	{
		xReturn = 0;
    3590:	1a 82       	std	Y+2, r1	; 0x02
    3592:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3594:	89 81       	ldd	r24, Y+1	; 0x01
    3596:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3598:	61 96       	adiw	r28, 0x11	; 17
    359a:	0f b6       	in	r0, 0x3f	; 63
    359c:	f8 94       	cli
    359e:	de bf       	out	0x3e, r29	; 62
    35a0:	0f be       	out	0x3f, r0	; 63
    35a2:	cd bf       	out	0x3d, r28	; 61
    35a4:	cf 91       	pop	r28
    35a6:	df 91       	pop	r29
    35a8:	1f 91       	pop	r17
    35aa:	0f 91       	pop	r16
    35ac:	08 95       	ret

000035ae <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
							 void *pvRxData,
							 size_t xBufferLengthBytes,
							 TickType_t xTicksToWait )
{
    35ae:	ef 92       	push	r14
    35b0:	ff 92       	push	r15
    35b2:	0f 93       	push	r16
    35b4:	1f 93       	push	r17
    35b6:	df 93       	push	r29
    35b8:	cf 93       	push	r28
    35ba:	cd b7       	in	r28, 0x3d	; 61
    35bc:	de b7       	in	r29, 0x3e	; 62
    35be:	60 97       	sbiw	r28, 0x10	; 16
    35c0:	0f b6       	in	r0, 0x3f	; 63
    35c2:	f8 94       	cli
    35c4:	de bf       	out	0x3e, r29	; 62
    35c6:	0f be       	out	0x3f, r0	; 63
    35c8:	cd bf       	out	0x3d, r28	; 61
    35ca:	9a 87       	std	Y+10, r25	; 0x0a
    35cc:	89 87       	std	Y+9, r24	; 0x09
    35ce:	7c 87       	std	Y+12, r23	; 0x0c
    35d0:	6b 87       	std	Y+11, r22	; 0x0b
    35d2:	5e 87       	std	Y+14, r21	; 0x0e
    35d4:	4d 87       	std	Y+13, r20	; 0x0d
    35d6:	38 8b       	std	Y+16, r19	; 0x10
    35d8:	2f 87       	std	Y+15, r18	; 0x0f
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    35da:	89 85       	ldd	r24, Y+9	; 0x09
    35dc:	9a 85       	ldd	r25, Y+10	; 0x0a
    35de:	98 87       	std	Y+8, r25	; 0x08
    35e0:	8f 83       	std	Y+7, r24	; 0x07
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    35e2:	1e 82       	std	Y+6, r1	; 0x06
    35e4:	1d 82       	std	Y+5, r1	; 0x05
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    35e6:	ef 81       	ldd	r30, Y+7	; 0x07
    35e8:	f8 85       	ldd	r31, Y+8	; 0x08
    35ea:	86 85       	ldd	r24, Z+14	; 0x0e
    35ec:	88 2f       	mov	r24, r24
    35ee:	90 e0       	ldi	r25, 0x00	; 0
    35f0:	81 70       	andi	r24, 0x01	; 1
    35f2:	90 70       	andi	r25, 0x00	; 0
    35f4:	88 23       	and	r24, r24
    35f6:	29 f0       	breq	.+10     	; 0x3602 <xStreamBufferReceive+0x54>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    35f8:	82 e0       	ldi	r24, 0x02	; 2
    35fa:	90 e0       	ldi	r25, 0x00	; 0
    35fc:	9a 83       	std	Y+2, r25	; 0x02
    35fe:	89 83       	std	Y+1, r24	; 0x01
    3600:	02 c0       	rjmp	.+4      	; 0x3606 <xStreamBufferReceive+0x58>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    3602:	1a 82       	std	Y+2, r1	; 0x02
    3604:	19 82       	std	Y+1, r1	; 0x01
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    3606:	8f 85       	ldd	r24, Y+15	; 0x0f
    3608:	98 89       	ldd	r25, Y+16	; 0x10
    360a:	00 97       	sbiw	r24, 0x00	; 0
    360c:	09 f4       	brne	.+2      	; 0x3610 <xStreamBufferReceive+0x62>
    360e:	3d c0       	rjmp	.+122    	; 0x368a <xStreamBufferReceive+0xdc>
	{
		/* Checking if there is data and clearing the notification state must be
		performed atomically. */
		taskENTER_CRITICAL();
    3610:	0f b6       	in	r0, 0x3f	; 63
    3612:	f8 94       	cli
    3614:	0f 92       	push	r0
		{
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3616:	8f 81       	ldd	r24, Y+7	; 0x07
    3618:	98 85       	ldd	r25, Y+8	; 0x08
    361a:	0e 94 ec 1e 	call	0x3dd8	; 0x3dd8 <prvBytesInBuffer>
    361e:	9c 83       	std	Y+4, r25	; 0x04
    3620:	8b 83       	std	Y+3, r24	; 0x03
			/* If this function was invoked by a message buffer read then
			xBytesToStoreMessageLength holds the number of bytes used to hold
			the length of the next discrete message.  If this function was
			invoked by a stream buffer read then xBytesToStoreMessageLength will
			be 0. */
			if( xBytesAvailable <= xBytesToStoreMessageLength )
    3622:	2b 81       	ldd	r18, Y+3	; 0x03
    3624:	3c 81       	ldd	r19, Y+4	; 0x04
    3626:	89 81       	ldd	r24, Y+1	; 0x01
    3628:	9a 81       	ldd	r25, Y+2	; 0x02
    362a:	82 17       	cp	r24, r18
    362c:	93 07       	cpc	r25, r19
    362e:	50 f0       	brcs	.+20     	; 0x3644 <xStreamBufferReceive+0x96>
			{
				/* Clear notification state as going to wait for data. */
				( void ) xTaskNotifyStateClear( NULL );
    3630:	80 e0       	ldi	r24, 0x00	; 0
    3632:	90 e0       	ldi	r25, 0x00	; 0
    3634:	0e 94 85 2b 	call	0x570a	; 0x570a <xTaskNotifyStateClear>

				/* Should only be one reader. */
				configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
				pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
    3638:	0e 94 e6 27 	call	0x4fcc	; 0x4fcc <xTaskGetCurrentTaskHandle>
    363c:	ef 81       	ldd	r30, Y+7	; 0x07
    363e:	f8 85       	ldd	r31, Y+8	; 0x08
    3640:	91 87       	std	Z+9, r25	; 0x09
    3642:	80 87       	std	Z+8, r24	; 0x08
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    3644:	0f 90       	pop	r0
    3646:	0f be       	out	0x3f, r0	; 63

		if( xBytesAvailable <= xBytesToStoreMessageLength )
    3648:	2b 81       	ldd	r18, Y+3	; 0x03
    364a:	3c 81       	ldd	r19, Y+4	; 0x04
    364c:	89 81       	ldd	r24, Y+1	; 0x01
    364e:	9a 81       	ldd	r25, Y+2	; 0x02
    3650:	82 17       	cp	r24, r18
    3652:	93 07       	cpc	r25, r19
    3654:	00 f1       	brcs	.+64     	; 0x3696 <xStreamBufferReceive+0xe8>
		{
			/* Wait for data to be available. */
			traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    3656:	ef 85       	ldd	r30, Y+15	; 0x0f
    3658:	f8 89       	ldd	r31, Y+16	; 0x10
    365a:	60 e0       	ldi	r22, 0x00	; 0
    365c:	70 e0       	ldi	r23, 0x00	; 0
    365e:	80 e0       	ldi	r24, 0x00	; 0
    3660:	90 e0       	ldi	r25, 0x00	; 0
    3662:	20 e0       	ldi	r18, 0x00	; 0
    3664:	30 e0       	ldi	r19, 0x00	; 0
    3666:	40 e0       	ldi	r20, 0x00	; 0
    3668:	50 e0       	ldi	r21, 0x00	; 0
    366a:	00 e0       	ldi	r16, 0x00	; 0
    366c:	10 e0       	ldi	r17, 0x00	; 0
    366e:	7f 01       	movw	r14, r30
    3670:	0e 94 96 28 	call	0x512c	; 0x512c <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToReceive = NULL;
    3674:	ef 81       	ldd	r30, Y+7	; 0x07
    3676:	f8 85       	ldd	r31, Y+8	; 0x08
    3678:	11 86       	std	Z+9, r1	; 0x09
    367a:	10 86       	std	Z+8, r1	; 0x08

			/* Recheck the data available after blocking. */
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    367c:	8f 81       	ldd	r24, Y+7	; 0x07
    367e:	98 85       	ldd	r25, Y+8	; 0x08
    3680:	0e 94 ec 1e 	call	0x3dd8	; 0x3dd8 <prvBytesInBuffer>
    3684:	9c 83       	std	Y+4, r25	; 0x04
    3686:	8b 83       	std	Y+3, r24	; 0x03
    3688:	06 c0       	rjmp	.+12     	; 0x3696 <xStreamBufferReceive+0xe8>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    368a:	8f 81       	ldd	r24, Y+7	; 0x07
    368c:	98 85       	ldd	r25, Y+8	; 0x08
    368e:	0e 94 ec 1e 	call	0x3dd8	; 0x3dd8 <prvBytesInBuffer>
    3692:	9c 83       	std	Y+4, r25	; 0x04
    3694:	8b 83       	std	Y+3, r24	; 0x03
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    3696:	2b 81       	ldd	r18, Y+3	; 0x03
    3698:	3c 81       	ldd	r19, Y+4	; 0x04
    369a:	89 81       	ldd	r24, Y+1	; 0x01
    369c:	9a 81       	ldd	r25, Y+2	; 0x02
    369e:	82 17       	cp	r24, r18
    36a0:	93 07       	cpc	r25, r19
    36a2:	80 f5       	brcc	.+96     	; 0x3704 <xStreamBufferReceive+0x156>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    36a4:	8f 81       	ldd	r24, Y+7	; 0x07
    36a6:	98 85       	ldd	r25, Y+8	; 0x08
    36a8:	2b 85       	ldd	r18, Y+11	; 0x0b
    36aa:	3c 85       	ldd	r19, Y+12	; 0x0c
    36ac:	4d 85       	ldd	r20, Y+13	; 0x0d
    36ae:	5e 85       	ldd	r21, Y+14	; 0x0e
    36b0:	eb 81       	ldd	r30, Y+3	; 0x03
    36b2:	fc 81       	ldd	r31, Y+4	; 0x04
    36b4:	a9 81       	ldd	r26, Y+1	; 0x01
    36b6:	ba 81       	ldd	r27, Y+2	; 0x02
    36b8:	b9 01       	movw	r22, r18
    36ba:	9f 01       	movw	r18, r30
    36bc:	8d 01       	movw	r16, r26
    36be:	0e 94 5b 1c 	call	0x38b6	; 0x38b6 <prvReadMessageFromBuffer>
    36c2:	9e 83       	std	Y+6, r25	; 0x06
    36c4:	8d 83       	std	Y+5, r24	; 0x05

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    36c6:	8d 81       	ldd	r24, Y+5	; 0x05
    36c8:	9e 81       	ldd	r25, Y+6	; 0x06
    36ca:	00 97       	sbiw	r24, 0x00	; 0
    36cc:	d9 f0       	breq	.+54     	; 0x3704 <xStreamBufferReceive+0x156>
		{
			traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
			sbRECEIVE_COMPLETED( pxStreamBuffer );
    36ce:	0e 94 43 23 	call	0x4686	; 0x4686 <vTaskSuspendAll>
    36d2:	ef 81       	ldd	r30, Y+7	; 0x07
    36d4:	f8 85       	ldd	r31, Y+8	; 0x08
    36d6:	82 85       	ldd	r24, Z+10	; 0x0a
    36d8:	93 85       	ldd	r25, Z+11	; 0x0b
    36da:	00 97       	sbiw	r24, 0x00	; 0
    36dc:	89 f0       	breq	.+34     	; 0x3700 <xStreamBufferReceive+0x152>
    36de:	ef 81       	ldd	r30, Y+7	; 0x07
    36e0:	f8 85       	ldd	r31, Y+8	; 0x08
    36e2:	82 85       	ldd	r24, Z+10	; 0x0a
    36e4:	93 85       	ldd	r25, Z+11	; 0x0b
    36e6:	40 e0       	ldi	r20, 0x00	; 0
    36e8:	50 e0       	ldi	r21, 0x00	; 0
    36ea:	60 e0       	ldi	r22, 0x00	; 0
    36ec:	70 e0       	ldi	r23, 0x00	; 0
    36ee:	20 e0       	ldi	r18, 0x00	; 0
    36f0:	00 e0       	ldi	r16, 0x00	; 0
    36f2:	10 e0       	ldi	r17, 0x00	; 0
    36f4:	0e 94 32 29 	call	0x5264	; 0x5264 <xTaskGenericNotify>
    36f8:	ef 81       	ldd	r30, Y+7	; 0x07
    36fa:	f8 85       	ldd	r31, Y+8	; 0x08
    36fc:	13 86       	std	Z+11, r1	; 0x0b
    36fe:	12 86       	std	Z+10, r1	; 0x0a
    3700:	0e 94 4f 23 	call	0x469e	; 0x469e <xTaskResumeAll>
	{
		traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
		mtCOVERAGE_TEST_MARKER();
	}

	return xReceivedLength;
    3704:	8d 81       	ldd	r24, Y+5	; 0x05
    3706:	9e 81       	ldd	r25, Y+6	; 0x06
}
    3708:	60 96       	adiw	r28, 0x10	; 16
    370a:	0f b6       	in	r0, 0x3f	; 63
    370c:	f8 94       	cli
    370e:	de bf       	out	0x3e, r29	; 62
    3710:	0f be       	out	0x3f, r0	; 63
    3712:	cd bf       	out	0x3d, r28	; 61
    3714:	cf 91       	pop	r28
    3716:	df 91       	pop	r29
    3718:	1f 91       	pop	r17
    371a:	0f 91       	pop	r16
    371c:	ff 90       	pop	r15
    371e:	ef 90       	pop	r14
    3720:	08 95       	ret

00003722 <xStreamBufferNextMessageLengthBytes>:
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
    3722:	df 93       	push	r29
    3724:	cf 93       	push	r28
    3726:	cd b7       	in	r28, 0x3d	; 61
    3728:	de b7       	in	r29, 0x3e	; 62
    372a:	2c 97       	sbiw	r28, 0x0c	; 12
    372c:	0f b6       	in	r0, 0x3f	; 63
    372e:	f8 94       	cli
    3730:	de bf       	out	0x3e, r29	; 62
    3732:	0f be       	out	0x3f, r0	; 63
    3734:	cd bf       	out	0x3d, r28	; 61
    3736:	9c 87       	std	Y+12, r25	; 0x0c
    3738:	8b 87       	std	Y+11, r24	; 0x0b
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    373a:	8b 85       	ldd	r24, Y+11	; 0x0b
    373c:	9c 85       	ldd	r25, Y+12	; 0x0c
    373e:	98 87       	std	Y+8, r25	; 0x08
    3740:	8f 83       	std	Y+7, r24	; 0x07
configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

	configASSERT( pxStreamBuffer );

	/* Ensure the stream buffer is being used as a message buffer. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3742:	ef 81       	ldd	r30, Y+7	; 0x07
    3744:	f8 85       	ldd	r31, Y+8	; 0x08
    3746:	86 85       	ldd	r24, Z+14	; 0x0e
    3748:	88 2f       	mov	r24, r24
    374a:	90 e0       	ldi	r25, 0x00	; 0
    374c:	81 70       	andi	r24, 0x01	; 1
    374e:	90 70       	andi	r25, 0x00	; 0
    3750:	88 23       	and	r24, r24
    3752:	61 f1       	breq	.+88     	; 0x37ac <xStreamBufferNextMessageLengthBytes+0x8a>
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3754:	8f 81       	ldd	r24, Y+7	; 0x07
    3756:	98 85       	ldd	r25, Y+8	; 0x08
    3758:	0e 94 ec 1e 	call	0x3dd8	; 0x3dd8 <prvBytesInBuffer>
    375c:	9c 83       	std	Y+4, r25	; 0x04
    375e:	8b 83       	std	Y+3, r24	; 0x03
		if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
    3760:	8b 81       	ldd	r24, Y+3	; 0x03
    3762:	9c 81       	ldd	r25, Y+4	; 0x04
    3764:	83 30       	cpi	r24, 0x03	; 3
    3766:	91 05       	cpc	r25, r1
    3768:	f0 f0       	brcs	.+60     	; 0x37a6 <xStreamBufferNextMessageLengthBytes+0x84>
			required to hold the length of the next message, so another message
			is available.  Return its length without removing the length bytes
			from the buffer.  A copy of the tail is stored so the buffer can be
			returned to its prior state as the message is not actually being
			removed from the buffer. */
			xOriginalTail = pxStreamBuffer->xTail;
    376a:	ef 81       	ldd	r30, Y+7	; 0x07
    376c:	f8 85       	ldd	r31, Y+8	; 0x08
    376e:	80 81       	ld	r24, Z
    3770:	91 81       	ldd	r25, Z+1	; 0x01
    3772:	9a 83       	std	Y+2, r25	; 0x02
    3774:	89 83       	std	Y+1, r24	; 0x01
			( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, xBytesAvailable );
    3776:	9e 01       	movw	r18, r28
    3778:	27 5f       	subi	r18, 0xF7	; 247
    377a:	3f 4f       	sbci	r19, 0xFF	; 255
    377c:	8f 81       	ldd	r24, Y+7	; 0x07
    377e:	98 85       	ldd	r25, Y+8	; 0x08
    3780:	eb 81       	ldd	r30, Y+3	; 0x03
    3782:	fc 81       	ldd	r31, Y+4	; 0x04
    3784:	b9 01       	movw	r22, r18
    3786:	42 e0       	ldi	r20, 0x02	; 2
    3788:	50 e0       	ldi	r21, 0x00	; 0
    378a:	9f 01       	movw	r18, r30
    378c:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <prvReadBytesFromBuffer>
			xReturn = ( size_t ) xTempReturn;
    3790:	89 85       	ldd	r24, Y+9	; 0x09
    3792:	9a 85       	ldd	r25, Y+10	; 0x0a
    3794:	9e 83       	std	Y+6, r25	; 0x06
    3796:	8d 83       	std	Y+5, r24	; 0x05
			pxStreamBuffer->xTail = xOriginalTail;
    3798:	ef 81       	ldd	r30, Y+7	; 0x07
    379a:	f8 85       	ldd	r31, Y+8	; 0x08
    379c:	89 81       	ldd	r24, Y+1	; 0x01
    379e:	9a 81       	ldd	r25, Y+2	; 0x02
    37a0:	91 83       	std	Z+1, r25	; 0x01
    37a2:	80 83       	st	Z, r24
    37a4:	05 c0       	rjmp	.+10     	; 0x37b0 <xStreamBufferNextMessageLengthBytes+0x8e>
			/* The minimum amount of bytes in a message buffer is
			( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
			less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
			value is 0. */
			configASSERT( xBytesAvailable == 0 );
			xReturn = 0;
    37a6:	1e 82       	std	Y+6, r1	; 0x06
    37a8:	1d 82       	std	Y+5, r1	; 0x05
    37aa:	02 c0       	rjmp	.+4      	; 0x37b0 <xStreamBufferNextMessageLengthBytes+0x8e>
		}
	}
	else
	{
		xReturn = 0;
    37ac:	1e 82       	std	Y+6, r1	; 0x06
    37ae:	1d 82       	std	Y+5, r1	; 0x05
	}

	return xReturn;
    37b0:	8d 81       	ldd	r24, Y+5	; 0x05
    37b2:	9e 81       	ldd	r25, Y+6	; 0x06
}
    37b4:	2c 96       	adiw	r28, 0x0c	; 12
    37b6:	0f b6       	in	r0, 0x3f	; 63
    37b8:	f8 94       	cli
    37ba:	de bf       	out	0x3e, r29	; 62
    37bc:	0f be       	out	0x3f, r0	; 63
    37be:	cd bf       	out	0x3d, r28	; 61
    37c0:	cf 91       	pop	r28
    37c2:	df 91       	pop	r29
    37c4:	08 95       	ret

000037c6 <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
									void *pvRxData,
									size_t xBufferLengthBytes,
									BaseType_t * const pxHigherPriorityTaskWoken )
{
    37c6:	ef 92       	push	r14
    37c8:	ff 92       	push	r15
    37ca:	0f 93       	push	r16
    37cc:	1f 93       	push	r17
    37ce:	df 93       	push	r29
    37d0:	cf 93       	push	r28
    37d2:	cd b7       	in	r28, 0x3d	; 61
    37d4:	de b7       	in	r29, 0x3e	; 62
    37d6:	61 97       	sbiw	r28, 0x11	; 17
    37d8:	0f b6       	in	r0, 0x3f	; 63
    37da:	f8 94       	cli
    37dc:	de bf       	out	0x3e, r29	; 62
    37de:	0f be       	out	0x3f, r0	; 63
    37e0:	cd bf       	out	0x3d, r28	; 61
    37e2:	9b 87       	std	Y+11, r25	; 0x0b
    37e4:	8a 87       	std	Y+10, r24	; 0x0a
    37e6:	7d 87       	std	Y+13, r23	; 0x0d
    37e8:	6c 87       	std	Y+12, r22	; 0x0c
    37ea:	5f 87       	std	Y+15, r21	; 0x0f
    37ec:	4e 87       	std	Y+14, r20	; 0x0e
    37ee:	39 8b       	std	Y+17, r19	; 0x11
    37f0:	28 8b       	std	Y+16, r18	; 0x10
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    37f2:	8a 85       	ldd	r24, Y+10	; 0x0a
    37f4:	9b 85       	ldd	r25, Y+11	; 0x0b
    37f6:	99 87       	std	Y+9, r25	; 0x09
    37f8:	88 87       	std	Y+8, r24	; 0x08
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    37fa:	1f 82       	std	Y+7, r1	; 0x07
    37fc:	1e 82       	std	Y+6, r1	; 0x06
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    37fe:	e8 85       	ldd	r30, Y+8	; 0x08
    3800:	f9 85       	ldd	r31, Y+9	; 0x09
    3802:	86 85       	ldd	r24, Z+14	; 0x0e
    3804:	88 2f       	mov	r24, r24
    3806:	90 e0       	ldi	r25, 0x00	; 0
    3808:	81 70       	andi	r24, 0x01	; 1
    380a:	90 70       	andi	r25, 0x00	; 0
    380c:	88 23       	and	r24, r24
    380e:	29 f0       	breq	.+10     	; 0x381a <xStreamBufferReceiveFromISR+0x54>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3810:	82 e0       	ldi	r24, 0x02	; 2
    3812:	90 e0       	ldi	r25, 0x00	; 0
    3814:	9b 83       	std	Y+3, r25	; 0x03
    3816:	8a 83       	std	Y+2, r24	; 0x02
    3818:	02 c0       	rjmp	.+4      	; 0x381e <xStreamBufferReceiveFromISR+0x58>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    381a:	1b 82       	std	Y+3, r1	; 0x03
    381c:	1a 82       	std	Y+2, r1	; 0x02
	}

	xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    381e:	88 85       	ldd	r24, Y+8	; 0x08
    3820:	99 85       	ldd	r25, Y+9	; 0x09
    3822:	0e 94 ec 1e 	call	0x3dd8	; 0x3dd8 <prvBytesInBuffer>
    3826:	9d 83       	std	Y+5, r25	; 0x05
    3828:	8c 83       	std	Y+4, r24	; 0x04
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    382a:	2c 81       	ldd	r18, Y+4	; 0x04
    382c:	3d 81       	ldd	r19, Y+5	; 0x05
    382e:	8a 81       	ldd	r24, Y+2	; 0x02
    3830:	9b 81       	ldd	r25, Y+3	; 0x03
    3832:	82 17       	cp	r24, r18
    3834:	93 07       	cpc	r25, r19
    3836:	80 f5       	brcc	.+96     	; 0x3898 <xStreamBufferReceiveFromISR+0xd2>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    3838:	88 85       	ldd	r24, Y+8	; 0x08
    383a:	99 85       	ldd	r25, Y+9	; 0x09
    383c:	2c 85       	ldd	r18, Y+12	; 0x0c
    383e:	3d 85       	ldd	r19, Y+13	; 0x0d
    3840:	4e 85       	ldd	r20, Y+14	; 0x0e
    3842:	5f 85       	ldd	r21, Y+15	; 0x0f
    3844:	ec 81       	ldd	r30, Y+4	; 0x04
    3846:	fd 81       	ldd	r31, Y+5	; 0x05
    3848:	aa 81       	ldd	r26, Y+2	; 0x02
    384a:	bb 81       	ldd	r27, Y+3	; 0x03
    384c:	b9 01       	movw	r22, r18
    384e:	9f 01       	movw	r18, r30
    3850:	8d 01       	movw	r16, r26
    3852:	0e 94 5b 1c 	call	0x38b6	; 0x38b6 <prvReadMessageFromBuffer>
    3856:	9f 83       	std	Y+7, r25	; 0x07
    3858:	8e 83       	std	Y+6, r24	; 0x06

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    385a:	8e 81       	ldd	r24, Y+6	; 0x06
    385c:	9f 81       	ldd	r25, Y+7	; 0x07
    385e:	00 97       	sbiw	r24, 0x00	; 0
    3860:	d9 f0       	breq	.+54     	; 0x3898 <xStreamBufferReceiveFromISR+0xd2>
		{
			sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    3862:	19 82       	std	Y+1, r1	; 0x01
    3864:	e8 85       	ldd	r30, Y+8	; 0x08
    3866:	f9 85       	ldd	r31, Y+9	; 0x09
    3868:	82 85       	ldd	r24, Z+10	; 0x0a
    386a:	93 85       	ldd	r25, Z+11	; 0x0b
    386c:	00 97       	sbiw	r24, 0x00	; 0
    386e:	a1 f0       	breq	.+40     	; 0x3898 <xStreamBufferReceiveFromISR+0xd2>
    3870:	e8 85       	ldd	r30, Y+8	; 0x08
    3872:	f9 85       	ldd	r31, Y+9	; 0x09
    3874:	82 85       	ldd	r24, Z+10	; 0x0a
    3876:	93 85       	ldd	r25, Z+11	; 0x0b
    3878:	e8 89       	ldd	r30, Y+16	; 0x10
    387a:	f9 89       	ldd	r31, Y+17	; 0x11
    387c:	40 e0       	ldi	r20, 0x00	; 0
    387e:	50 e0       	ldi	r21, 0x00	; 0
    3880:	60 e0       	ldi	r22, 0x00	; 0
    3882:	70 e0       	ldi	r23, 0x00	; 0
    3884:	20 e0       	ldi	r18, 0x00	; 0
    3886:	00 e0       	ldi	r16, 0x00	; 0
    3888:	10 e0       	ldi	r17, 0x00	; 0
    388a:	7f 01       	movw	r14, r30
    388c:	0e 94 07 2a 	call	0x540e	; 0x540e <xTaskGenericNotifyFromISR>
    3890:	e8 85       	ldd	r30, Y+8	; 0x08
    3892:	f9 85       	ldd	r31, Y+9	; 0x09
    3894:	13 86       	std	Z+11, r1	; 0x0b
    3896:	12 86       	std	Z+10, r1	; 0x0a
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

	return xReceivedLength;
    3898:	8e 81       	ldd	r24, Y+6	; 0x06
    389a:	9f 81       	ldd	r25, Y+7	; 0x07
}
    389c:	61 96       	adiw	r28, 0x11	; 17
    389e:	0f b6       	in	r0, 0x3f	; 63
    38a0:	f8 94       	cli
    38a2:	de bf       	out	0x3e, r29	; 62
    38a4:	0f be       	out	0x3f, r0	; 63
    38a6:	cd bf       	out	0x3d, r28	; 61
    38a8:	cf 91       	pop	r28
    38aa:	df 91       	pop	r29
    38ac:	1f 91       	pop	r17
    38ae:	0f 91       	pop	r16
    38b0:	ff 90       	pop	r15
    38b2:	ef 90       	pop	r14
    38b4:	08 95       	ret

000038b6 <prvReadMessageFromBuffer>:
static size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,
										void *pvRxData,
										size_t xBufferLengthBytes,
										size_t xBytesAvailable,
										size_t xBytesToStoreMessageLength )
{
    38b6:	0f 93       	push	r16
    38b8:	1f 93       	push	r17
    38ba:	df 93       	push	r29
    38bc:	cf 93       	push	r28
    38be:	cd b7       	in	r28, 0x3d	; 61
    38c0:	de b7       	in	r29, 0x3e	; 62
    38c2:	62 97       	sbiw	r28, 0x12	; 18
    38c4:	0f b6       	in	r0, 0x3f	; 63
    38c6:	f8 94       	cli
    38c8:	de bf       	out	0x3e, r29	; 62
    38ca:	0f be       	out	0x3f, r0	; 63
    38cc:	cd bf       	out	0x3d, r28	; 61
    38ce:	9a 87       	std	Y+10, r25	; 0x0a
    38d0:	89 87       	std	Y+9, r24	; 0x09
    38d2:	7c 87       	std	Y+12, r23	; 0x0c
    38d4:	6b 87       	std	Y+11, r22	; 0x0b
    38d6:	5e 87       	std	Y+14, r21	; 0x0e
    38d8:	4d 87       	std	Y+13, r20	; 0x0d
    38da:	38 8b       	std	Y+16, r19	; 0x10
    38dc:	2f 87       	std	Y+15, r18	; 0x0f
    38de:	1a 8b       	std	Y+18, r17	; 0x12
    38e0:	09 8b       	std	Y+17, r16	; 0x11
size_t xOriginalTail, xReceivedLength, xNextMessageLength;
configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;

	if( xBytesToStoreMessageLength != ( size_t ) 0 )
    38e2:	89 89       	ldd	r24, Y+17	; 0x11
    38e4:	9a 89       	ldd	r25, Y+18	; 0x12
    38e6:	00 97       	sbiw	r24, 0x00	; 0
    38e8:	91 f1       	breq	.+100    	; 0x394e <prvReadMessageFromBuffer+0x98>
	{
		/* A discrete message is being received.  First receive the length
		of the message.  A copy of the tail is stored so the buffer can be
		returned to its prior state if the length of the message is too
		large for the provided buffer. */
		xOriginalTail = pxStreamBuffer->xTail;
    38ea:	e9 85       	ldd	r30, Y+9	; 0x09
    38ec:	fa 85       	ldd	r31, Y+10	; 0x0a
    38ee:	80 81       	ld	r24, Z
    38f0:	91 81       	ldd	r25, Z+1	; 0x01
    38f2:	9e 83       	std	Y+6, r25	; 0x06
    38f4:	8d 83       	std	Y+5, r24	; 0x05
		( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );
    38f6:	ae 01       	movw	r20, r28
    38f8:	49 5f       	subi	r20, 0xF9	; 249
    38fa:	5f 4f       	sbci	r21, 0xFF	; 255
    38fc:	89 85       	ldd	r24, Y+9	; 0x09
    38fe:	9a 85       	ldd	r25, Y+10	; 0x0a
    3900:	29 89       	ldd	r18, Y+17	; 0x11
    3902:	3a 89       	ldd	r19, Y+18	; 0x12
    3904:	ef 85       	ldd	r30, Y+15	; 0x0f
    3906:	f8 89       	ldd	r31, Y+16	; 0x10
    3908:	ba 01       	movw	r22, r20
    390a:	a9 01       	movw	r20, r18
    390c:	9f 01       	movw	r18, r30
    390e:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <prvReadBytesFromBuffer>
		xNextMessageLength = ( size_t ) xTempNextMessageLength;
    3912:	8f 81       	ldd	r24, Y+7	; 0x07
    3914:	98 85       	ldd	r25, Y+8	; 0x08
    3916:	9a 83       	std	Y+2, r25	; 0x02
    3918:	89 83       	std	Y+1, r24	; 0x01

		/* Reduce the number of bytes available by the number of bytes just
		read out. */
		xBytesAvailable -= xBytesToStoreMessageLength;
    391a:	2f 85       	ldd	r18, Y+15	; 0x0f
    391c:	38 89       	ldd	r19, Y+16	; 0x10
    391e:	89 89       	ldd	r24, Y+17	; 0x11
    3920:	9a 89       	ldd	r25, Y+18	; 0x12
    3922:	a9 01       	movw	r20, r18
    3924:	48 1b       	sub	r20, r24
    3926:	59 0b       	sbc	r21, r25
    3928:	ca 01       	movw	r24, r20
    392a:	98 8b       	std	Y+16, r25	; 0x10
    392c:	8f 87       	std	Y+15, r24	; 0x0f

		/* Check there is enough space in the buffer provided by the
		user. */
		if( xNextMessageLength > xBufferLengthBytes )
    392e:	29 81       	ldd	r18, Y+1	; 0x01
    3930:	3a 81       	ldd	r19, Y+2	; 0x02
    3932:	8d 85       	ldd	r24, Y+13	; 0x0d
    3934:	9e 85       	ldd	r25, Y+14	; 0x0e
    3936:	82 17       	cp	r24, r18
    3938:	93 07       	cpc	r25, r19
    393a:	68 f4       	brcc	.+26     	; 0x3956 <prvReadMessageFromBuffer+0xa0>
		{
			/* The user has provided insufficient space to read the message
			so return the buffer to its previous state (so the length of
			the message is in the buffer again). */
			pxStreamBuffer->xTail = xOriginalTail;
    393c:	e9 85       	ldd	r30, Y+9	; 0x09
    393e:	fa 85       	ldd	r31, Y+10	; 0x0a
    3940:	8d 81       	ldd	r24, Y+5	; 0x05
    3942:	9e 81       	ldd	r25, Y+6	; 0x06
    3944:	91 83       	std	Z+1, r25	; 0x01
    3946:	80 83       	st	Z, r24
			xNextMessageLength = 0;
    3948:	1a 82       	std	Y+2, r1	; 0x02
    394a:	19 82       	std	Y+1, r1	; 0x01
    394c:	04 c0       	rjmp	.+8      	; 0x3956 <prvReadMessageFromBuffer+0xa0>
	}
	else
	{
		/* A stream of bytes is being received (as opposed to a discrete
		message), so read as many bytes as possible. */
		xNextMessageLength = xBufferLengthBytes;
    394e:	8d 85       	ldd	r24, Y+13	; 0x0d
    3950:	9e 85       	ldd	r25, Y+14	; 0x0e
    3952:	9a 83       	std	Y+2, r25	; 0x02
    3954:	89 83       	std	Y+1, r24	; 0x01
	}

	/* Read the actual data. */
	xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
    3956:	4b 85       	ldd	r20, Y+11	; 0x0b
    3958:	5c 85       	ldd	r21, Y+12	; 0x0c
    395a:	89 85       	ldd	r24, Y+9	; 0x09
    395c:	9a 85       	ldd	r25, Y+10	; 0x0a
    395e:	29 81       	ldd	r18, Y+1	; 0x01
    3960:	3a 81       	ldd	r19, Y+2	; 0x02
    3962:	ef 85       	ldd	r30, Y+15	; 0x0f
    3964:	f8 89       	ldd	r31, Y+16	; 0x10
    3966:	ba 01       	movw	r22, r20
    3968:	a9 01       	movw	r20, r18
    396a:	9f 01       	movw	r18, r30
    396c:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <prvReadBytesFromBuffer>
    3970:	9c 83       	std	Y+4, r25	; 0x04
    3972:	8b 83       	std	Y+3, r24	; 0x03

	return xReceivedLength;
    3974:	8b 81       	ldd	r24, Y+3	; 0x03
    3976:	9c 81       	ldd	r25, Y+4	; 0x04
}
    3978:	62 96       	adiw	r28, 0x12	; 18
    397a:	0f b6       	in	r0, 0x3f	; 63
    397c:	f8 94       	cli
    397e:	de bf       	out	0x3e, r29	; 62
    3980:	0f be       	out	0x3f, r0	; 63
    3982:	cd bf       	out	0x3d, r28	; 61
    3984:	cf 91       	pop	r28
    3986:	df 91       	pop	r29
    3988:	1f 91       	pop	r17
    398a:	0f 91       	pop	r16
    398c:	08 95       	ret

0000398e <xStreamBufferIsEmpty>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
    398e:	df 93       	push	r29
    3990:	cf 93       	push	r28
    3992:	cd b7       	in	r28, 0x3d	; 61
    3994:	de b7       	in	r29, 0x3e	; 62
    3996:	27 97       	sbiw	r28, 0x07	; 7
    3998:	0f b6       	in	r0, 0x3f	; 63
    399a:	f8 94       	cli
    399c:	de bf       	out	0x3e, r29	; 62
    399e:	0f be       	out	0x3f, r0	; 63
    39a0:	cd bf       	out	0x3d, r28	; 61
    39a2:	9f 83       	std	Y+7, r25	; 0x07
    39a4:	8e 83       	std	Y+6, r24	; 0x06
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    39a6:	8e 81       	ldd	r24, Y+6	; 0x06
    39a8:	9f 81       	ldd	r25, Y+7	; 0x07
    39aa:	9d 83       	std	Y+5, r25	; 0x05
    39ac:	8c 83       	std	Y+4, r24	; 0x04
size_t xTail;

	configASSERT( pxStreamBuffer );

	/* True if no bytes are available. */
	xTail = pxStreamBuffer->xTail;
    39ae:	ec 81       	ldd	r30, Y+4	; 0x04
    39b0:	fd 81       	ldd	r31, Y+5	; 0x05
    39b2:	80 81       	ld	r24, Z
    39b4:	91 81       	ldd	r25, Z+1	; 0x01
    39b6:	9a 83       	std	Y+2, r25	; 0x02
    39b8:	89 83       	std	Y+1, r24	; 0x01
	if( pxStreamBuffer->xHead == xTail )
    39ba:	ec 81       	ldd	r30, Y+4	; 0x04
    39bc:	fd 81       	ldd	r31, Y+5	; 0x05
    39be:	22 81       	ldd	r18, Z+2	; 0x02
    39c0:	33 81       	ldd	r19, Z+3	; 0x03
    39c2:	89 81       	ldd	r24, Y+1	; 0x01
    39c4:	9a 81       	ldd	r25, Y+2	; 0x02
    39c6:	28 17       	cp	r18, r24
    39c8:	39 07       	cpc	r19, r25
    39ca:	19 f4       	brne	.+6      	; 0x39d2 <xStreamBufferIsEmpty+0x44>
	{
		xReturn = pdTRUE;
    39cc:	81 e0       	ldi	r24, 0x01	; 1
    39ce:	8b 83       	std	Y+3, r24	; 0x03
    39d0:	01 c0       	rjmp	.+2      	; 0x39d4 <xStreamBufferIsEmpty+0x46>
	}
	else
	{
		xReturn = pdFALSE;
    39d2:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    39d4:	8b 81       	ldd	r24, Y+3	; 0x03
}
    39d6:	27 96       	adiw	r28, 0x07	; 7
    39d8:	0f b6       	in	r0, 0x3f	; 63
    39da:	f8 94       	cli
    39dc:	de bf       	out	0x3e, r29	; 62
    39de:	0f be       	out	0x3f, r0	; 63
    39e0:	cd bf       	out	0x3d, r28	; 61
    39e2:	cf 91       	pop	r28
    39e4:	df 91       	pop	r29
    39e6:	08 95       	ret

000039e8 <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
    39e8:	df 93       	push	r29
    39ea:	cf 93       	push	r28
    39ec:	cd b7       	in	r28, 0x3d	; 61
    39ee:	de b7       	in	r29, 0x3e	; 62
    39f0:	27 97       	sbiw	r28, 0x07	; 7
    39f2:	0f b6       	in	r0, 0x3f	; 63
    39f4:	f8 94       	cli
    39f6:	de bf       	out	0x3e, r29	; 62
    39f8:	0f be       	out	0x3f, r0	; 63
    39fa:	cd bf       	out	0x3d, r28	; 61
    39fc:	9f 83       	std	Y+7, r25	; 0x07
    39fe:	8e 83       	std	Y+6, r24	; 0x06
BaseType_t xReturn;
size_t xBytesToStoreMessageLength;
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3a00:	8e 81       	ldd	r24, Y+6	; 0x06
    3a02:	9f 81       	ldd	r25, Y+7	; 0x07
    3a04:	9a 83       	std	Y+2, r25	; 0x02
    3a06:	89 83       	std	Y+1, r24	; 0x01

	/* This generic version of the receive function is used by both message
	buffers, which store discrete messages, and stream buffers, which store a
	continuous stream of bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3a08:	e9 81       	ldd	r30, Y+1	; 0x01
    3a0a:	fa 81       	ldd	r31, Y+2	; 0x02
    3a0c:	86 85       	ldd	r24, Z+14	; 0x0e
    3a0e:	88 2f       	mov	r24, r24
    3a10:	90 e0       	ldi	r25, 0x00	; 0
    3a12:	81 70       	andi	r24, 0x01	; 1
    3a14:	90 70       	andi	r25, 0x00	; 0
    3a16:	88 23       	and	r24, r24
    3a18:	29 f0       	breq	.+10     	; 0x3a24 <xStreamBufferIsFull+0x3c>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3a1a:	82 e0       	ldi	r24, 0x02	; 2
    3a1c:	90 e0       	ldi	r25, 0x00	; 0
    3a1e:	9c 83       	std	Y+4, r25	; 0x04
    3a20:	8b 83       	std	Y+3, r24	; 0x03
    3a22:	02 c0       	rjmp	.+4      	; 0x3a28 <xStreamBufferIsFull+0x40>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    3a24:	1c 82       	std	Y+4, r1	; 0x04
    3a26:	1b 82       	std	Y+3, r1	; 0x03
	}

	/* True if the available space equals zero. */
	if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
    3a28:	8e 81       	ldd	r24, Y+6	; 0x06
    3a2a:	9f 81       	ldd	r25, Y+7	; 0x07
    3a2c:	0e 94 bc 18 	call	0x3178	; 0x3178 <xStreamBufferSpacesAvailable>
    3a30:	9c 01       	movw	r18, r24
    3a32:	8b 81       	ldd	r24, Y+3	; 0x03
    3a34:	9c 81       	ldd	r25, Y+4	; 0x04
    3a36:	82 17       	cp	r24, r18
    3a38:	93 07       	cpc	r25, r19
    3a3a:	18 f0       	brcs	.+6      	; 0x3a42 <xStreamBufferIsFull+0x5a>
	{
		xReturn = pdTRUE;
    3a3c:	81 e0       	ldi	r24, 0x01	; 1
    3a3e:	8d 83       	std	Y+5, r24	; 0x05
    3a40:	01 c0       	rjmp	.+2      	; 0x3a44 <xStreamBufferIsFull+0x5c>
	}
	else
	{
		xReturn = pdFALSE;
    3a42:	1d 82       	std	Y+5, r1	; 0x05
	}

	return xReturn;
    3a44:	8d 81       	ldd	r24, Y+5	; 0x05
}
    3a46:	27 96       	adiw	r28, 0x07	; 7
    3a48:	0f b6       	in	r0, 0x3f	; 63
    3a4a:	f8 94       	cli
    3a4c:	de bf       	out	0x3e, r29	; 62
    3a4e:	0f be       	out	0x3f, r0	; 63
    3a50:	cd bf       	out	0x3d, r28	; 61
    3a52:	cf 91       	pop	r28
    3a54:	df 91       	pop	r29
    3a56:	08 95       	ret

00003a58 <xStreamBufferSendCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    3a58:	ef 92       	push	r14
    3a5a:	ff 92       	push	r15
    3a5c:	0f 93       	push	r16
    3a5e:	1f 93       	push	r17
    3a60:	df 93       	push	r29
    3a62:	cf 93       	push	r28
    3a64:	cd b7       	in	r28, 0x3d	; 61
    3a66:	de b7       	in	r29, 0x3e	; 62
    3a68:	28 97       	sbiw	r28, 0x08	; 8
    3a6a:	0f b6       	in	r0, 0x3f	; 63
    3a6c:	f8 94       	cli
    3a6e:	de bf       	out	0x3e, r29	; 62
    3a70:	0f be       	out	0x3f, r0	; 63
    3a72:	cd bf       	out	0x3d, r28	; 61
    3a74:	9e 83       	std	Y+6, r25	; 0x06
    3a76:	8d 83       	std	Y+5, r24	; 0x05
    3a78:	78 87       	std	Y+8, r23	; 0x08
    3a7a:	6f 83       	std	Y+7, r22	; 0x07
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3a7c:	8d 81       	ldd	r24, Y+5	; 0x05
    3a7e:	9e 81       	ldd	r25, Y+6	; 0x06
    3a80:	9c 83       	std	Y+4, r25	; 0x04
    3a82:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    3a84:	19 82       	std	Y+1, r1	; 0x01
	{
		if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
    3a86:	eb 81       	ldd	r30, Y+3	; 0x03
    3a88:	fc 81       	ldd	r31, Y+4	; 0x04
    3a8a:	80 85       	ldd	r24, Z+8	; 0x08
    3a8c:	91 85       	ldd	r25, Z+9	; 0x09
    3a8e:	00 97       	sbiw	r24, 0x00	; 0
    3a90:	b9 f0       	breq	.+46     	; 0x3ac0 <xStreamBufferSendCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
    3a92:	eb 81       	ldd	r30, Y+3	; 0x03
    3a94:	fc 81       	ldd	r31, Y+4	; 0x04
    3a96:	80 85       	ldd	r24, Z+8	; 0x08
    3a98:	91 85       	ldd	r25, Z+9	; 0x09
    3a9a:	ef 81       	ldd	r30, Y+7	; 0x07
    3a9c:	f8 85       	ldd	r31, Y+8	; 0x08
    3a9e:	40 e0       	ldi	r20, 0x00	; 0
    3aa0:	50 e0       	ldi	r21, 0x00	; 0
    3aa2:	60 e0       	ldi	r22, 0x00	; 0
    3aa4:	70 e0       	ldi	r23, 0x00	; 0
    3aa6:	20 e0       	ldi	r18, 0x00	; 0
    3aa8:	00 e0       	ldi	r16, 0x00	; 0
    3aaa:	10 e0       	ldi	r17, 0x00	; 0
    3aac:	7f 01       	movw	r14, r30
    3aae:	0e 94 07 2a 	call	0x540e	; 0x540e <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
    3ab2:	eb 81       	ldd	r30, Y+3	; 0x03
    3ab4:	fc 81       	ldd	r31, Y+4	; 0x04
    3ab6:	11 86       	std	Z+9, r1	; 0x09
    3ab8:	10 86       	std	Z+8, r1	; 0x08
			xReturn = pdTRUE;
    3aba:	81 e0       	ldi	r24, 0x01	; 1
    3abc:	8a 83       	std	Y+2, r24	; 0x02
    3abe:	01 c0       	rjmp	.+2      	; 0x3ac2 <xStreamBufferSendCompletedFromISR+0x6a>
		}
		else
		{
			xReturn = pdFALSE;
    3ac0:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3ac2:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3ac4:	28 96       	adiw	r28, 0x08	; 8
    3ac6:	0f b6       	in	r0, 0x3f	; 63
    3ac8:	f8 94       	cli
    3aca:	de bf       	out	0x3e, r29	; 62
    3acc:	0f be       	out	0x3f, r0	; 63
    3ace:	cd bf       	out	0x3d, r28	; 61
    3ad0:	cf 91       	pop	r28
    3ad2:	df 91       	pop	r29
    3ad4:	1f 91       	pop	r17
    3ad6:	0f 91       	pop	r16
    3ad8:	ff 90       	pop	r15
    3ada:	ef 90       	pop	r14
    3adc:	08 95       	ret

00003ade <xStreamBufferReceiveCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    3ade:	ef 92       	push	r14
    3ae0:	ff 92       	push	r15
    3ae2:	0f 93       	push	r16
    3ae4:	1f 93       	push	r17
    3ae6:	df 93       	push	r29
    3ae8:	cf 93       	push	r28
    3aea:	cd b7       	in	r28, 0x3d	; 61
    3aec:	de b7       	in	r29, 0x3e	; 62
    3aee:	28 97       	sbiw	r28, 0x08	; 8
    3af0:	0f b6       	in	r0, 0x3f	; 63
    3af2:	f8 94       	cli
    3af4:	de bf       	out	0x3e, r29	; 62
    3af6:	0f be       	out	0x3f, r0	; 63
    3af8:	cd bf       	out	0x3d, r28	; 61
    3afa:	9e 83       	std	Y+6, r25	; 0x06
    3afc:	8d 83       	std	Y+5, r24	; 0x05
    3afe:	78 87       	std	Y+8, r23	; 0x08
    3b00:	6f 83       	std	Y+7, r22	; 0x07
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3b02:	8d 81       	ldd	r24, Y+5	; 0x05
    3b04:	9e 81       	ldd	r25, Y+6	; 0x06
    3b06:	9c 83       	std	Y+4, r25	; 0x04
    3b08:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    3b0a:	19 82       	std	Y+1, r1	; 0x01
	{
		if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
    3b0c:	eb 81       	ldd	r30, Y+3	; 0x03
    3b0e:	fc 81       	ldd	r31, Y+4	; 0x04
    3b10:	82 85       	ldd	r24, Z+10	; 0x0a
    3b12:	93 85       	ldd	r25, Z+11	; 0x0b
    3b14:	00 97       	sbiw	r24, 0x00	; 0
    3b16:	b9 f0       	breq	.+46     	; 0x3b46 <xStreamBufferReceiveCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
    3b18:	eb 81       	ldd	r30, Y+3	; 0x03
    3b1a:	fc 81       	ldd	r31, Y+4	; 0x04
    3b1c:	82 85       	ldd	r24, Z+10	; 0x0a
    3b1e:	93 85       	ldd	r25, Z+11	; 0x0b
    3b20:	ef 81       	ldd	r30, Y+7	; 0x07
    3b22:	f8 85       	ldd	r31, Y+8	; 0x08
    3b24:	40 e0       	ldi	r20, 0x00	; 0
    3b26:	50 e0       	ldi	r21, 0x00	; 0
    3b28:	60 e0       	ldi	r22, 0x00	; 0
    3b2a:	70 e0       	ldi	r23, 0x00	; 0
    3b2c:	20 e0       	ldi	r18, 0x00	; 0
    3b2e:	00 e0       	ldi	r16, 0x00	; 0
    3b30:	10 e0       	ldi	r17, 0x00	; 0
    3b32:	7f 01       	movw	r14, r30
    3b34:	0e 94 07 2a 	call	0x540e	; 0x540e <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToSend = NULL;
    3b38:	eb 81       	ldd	r30, Y+3	; 0x03
    3b3a:	fc 81       	ldd	r31, Y+4	; 0x04
    3b3c:	13 86       	std	Z+11, r1	; 0x0b
    3b3e:	12 86       	std	Z+10, r1	; 0x0a
			xReturn = pdTRUE;
    3b40:	81 e0       	ldi	r24, 0x01	; 1
    3b42:	8a 83       	std	Y+2, r24	; 0x02
    3b44:	01 c0       	rjmp	.+2      	; 0x3b48 <xStreamBufferReceiveCompletedFromISR+0x6a>
		}
		else
		{
			xReturn = pdFALSE;
    3b46:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3b48:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3b4a:	28 96       	adiw	r28, 0x08	; 8
    3b4c:	0f b6       	in	r0, 0x3f	; 63
    3b4e:	f8 94       	cli
    3b50:	de bf       	out	0x3e, r29	; 62
    3b52:	0f be       	out	0x3f, r0	; 63
    3b54:	cd bf       	out	0x3d, r28	; 61
    3b56:	cf 91       	pop	r28
    3b58:	df 91       	pop	r29
    3b5a:	1f 91       	pop	r17
    3b5c:	0f 91       	pop	r16
    3b5e:	ff 90       	pop	r15
    3b60:	ef 90       	pop	r14
    3b62:	08 95       	ret

00003b64 <prvWriteBytesToBuffer>:
/*-----------------------------------------------------------*/

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount )
{
    3b64:	df 93       	push	r29
    3b66:	cf 93       	push	r28
    3b68:	cd b7       	in	r28, 0x3d	; 61
    3b6a:	de b7       	in	r29, 0x3e	; 62
    3b6c:	2e 97       	sbiw	r28, 0x0e	; 14
    3b6e:	0f b6       	in	r0, 0x3f	; 63
    3b70:	f8 94       	cli
    3b72:	de bf       	out	0x3e, r29	; 62
    3b74:	0f be       	out	0x3f, r0	; 63
    3b76:	cd bf       	out	0x3d, r28	; 61
    3b78:	9e 83       	std	Y+6, r25	; 0x06
    3b7a:	8d 83       	std	Y+5, r24	; 0x05
    3b7c:	78 87       	std	Y+8, r23	; 0x08
    3b7e:	6f 83       	std	Y+7, r22	; 0x07
    3b80:	5a 87       	std	Y+10, r21	; 0x0a
    3b82:	49 87       	std	Y+9, r20	; 0x09
size_t xNextHead, xFirstLength;

	configASSERT( xCount > ( size_t ) 0 );

	xNextHead = pxStreamBuffer->xHead;
    3b84:	ed 81       	ldd	r30, Y+5	; 0x05
    3b86:	fe 81       	ldd	r31, Y+6	; 0x06
    3b88:	82 81       	ldd	r24, Z+2	; 0x02
    3b8a:	93 81       	ldd	r25, Z+3	; 0x03
    3b8c:	9c 83       	std	Y+4, r25	; 0x04
    3b8e:	8b 83       	std	Y+3, r24	; 0x03

	/* Calculate the number of bytes that can be added in the first write -
	which may be less than the total number of bytes that need to be added if
	the buffer will wrap back to the beginning. */
	xFirstLength = configMIN( pxStreamBuffer->xLength - xNextHead, xCount );
    3b90:	ed 81       	ldd	r30, Y+5	; 0x05
    3b92:	fe 81       	ldd	r31, Y+6	; 0x06
    3b94:	24 81       	ldd	r18, Z+4	; 0x04
    3b96:	35 81       	ldd	r19, Z+5	; 0x05
    3b98:	8b 81       	ldd	r24, Y+3	; 0x03
    3b9a:	9c 81       	ldd	r25, Y+4	; 0x04
    3b9c:	a9 01       	movw	r20, r18
    3b9e:	48 1b       	sub	r20, r24
    3ba0:	59 0b       	sbc	r21, r25
    3ba2:	ca 01       	movw	r24, r20
    3ba4:	29 85       	ldd	r18, Y+9	; 0x09
    3ba6:	3a 85       	ldd	r19, Y+10	; 0x0a
    3ba8:	3e 87       	std	Y+14, r19	; 0x0e
    3baa:	2d 87       	std	Y+13, r18	; 0x0d
    3bac:	9c 87       	std	Y+12, r25	; 0x0c
    3bae:	8b 87       	std	Y+11, r24	; 0x0b
    3bb0:	4b 85       	ldd	r20, Y+11	; 0x0b
    3bb2:	5c 85       	ldd	r21, Y+12	; 0x0c
    3bb4:	8d 85       	ldd	r24, Y+13	; 0x0d
    3bb6:	9e 85       	ldd	r25, Y+14	; 0x0e
    3bb8:	84 17       	cp	r24, r20
    3bba:	95 07       	cpc	r25, r21
    3bbc:	20 f4       	brcc	.+8      	; 0x3bc6 <prvWriteBytesToBuffer+0x62>
    3bbe:	2d 85       	ldd	r18, Y+13	; 0x0d
    3bc0:	3e 85       	ldd	r19, Y+14	; 0x0e
    3bc2:	3c 87       	std	Y+12, r19	; 0x0c
    3bc4:	2b 87       	std	Y+11, r18	; 0x0b
    3bc6:	4b 85       	ldd	r20, Y+11	; 0x0b
    3bc8:	5c 85       	ldd	r21, Y+12	; 0x0c
    3bca:	5a 83       	std	Y+2, r21	; 0x02
    3bcc:	49 83       	std	Y+1, r20	; 0x01

	/* Write as many bytes as can be written in the first write. */
	configASSERT( ( xNextHead + xFirstLength ) <= pxStreamBuffer->xLength );
	( void ) memcpy( ( void* ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    3bce:	ed 81       	ldd	r30, Y+5	; 0x05
    3bd0:	fe 81       	ldd	r31, Y+6	; 0x06
    3bd2:	24 85       	ldd	r18, Z+12	; 0x0c
    3bd4:	35 85       	ldd	r19, Z+13	; 0x0d
    3bd6:	8b 81       	ldd	r24, Y+3	; 0x03
    3bd8:	9c 81       	ldd	r25, Y+4	; 0x04
    3bda:	82 0f       	add	r24, r18
    3bdc:	93 1f       	adc	r25, r19
    3bde:	2f 81       	ldd	r18, Y+7	; 0x07
    3be0:	38 85       	ldd	r19, Y+8	; 0x08
    3be2:	49 81       	ldd	r20, Y+1	; 0x01
    3be4:	5a 81       	ldd	r21, Y+2	; 0x02
    3be6:	b9 01       	movw	r22, r18
    3be8:	0e 94 23 31 	call	0x6246	; 0x6246 <memcpy>

	/* If the number of bytes written was less than the number that could be
	written in the first write... */
	if( xCount > xFirstLength )
    3bec:	29 85       	ldd	r18, Y+9	; 0x09
    3bee:	3a 85       	ldd	r19, Y+10	; 0x0a
    3bf0:	89 81       	ldd	r24, Y+1	; 0x01
    3bf2:	9a 81       	ldd	r25, Y+2	; 0x02
    3bf4:	82 17       	cp	r24, r18
    3bf6:	93 07       	cpc	r25, r19
    3bf8:	b0 f4       	brcc	.+44     	; 0x3c26 <prvWriteBytesToBuffer+0xc2>
	{
		/* ...then write the remaining bytes to the start of the buffer. */
		configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    3bfa:	ed 81       	ldd	r30, Y+5	; 0x05
    3bfc:	fe 81       	ldd	r31, Y+6	; 0x06
    3bfe:	64 85       	ldd	r22, Z+12	; 0x0c
    3c00:	75 85       	ldd	r23, Z+13	; 0x0d
    3c02:	2f 81       	ldd	r18, Y+7	; 0x07
    3c04:	38 85       	ldd	r19, Y+8	; 0x08
    3c06:	89 81       	ldd	r24, Y+1	; 0x01
    3c08:	9a 81       	ldd	r25, Y+2	; 0x02
    3c0a:	a9 01       	movw	r20, r18
    3c0c:	48 0f       	add	r20, r24
    3c0e:	59 1f       	adc	r21, r25
    3c10:	29 85       	ldd	r18, Y+9	; 0x09
    3c12:	3a 85       	ldd	r19, Y+10	; 0x0a
    3c14:	89 81       	ldd	r24, Y+1	; 0x01
    3c16:	9a 81       	ldd	r25, Y+2	; 0x02
    3c18:	28 1b       	sub	r18, r24
    3c1a:	39 0b       	sbc	r19, r25
    3c1c:	cb 01       	movw	r24, r22
    3c1e:	ba 01       	movw	r22, r20
    3c20:	a9 01       	movw	r20, r18
    3c22:	0e 94 23 31 	call	0x6246	; 0x6246 <memcpy>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xNextHead += xCount;
    3c26:	2b 81       	ldd	r18, Y+3	; 0x03
    3c28:	3c 81       	ldd	r19, Y+4	; 0x04
    3c2a:	89 85       	ldd	r24, Y+9	; 0x09
    3c2c:	9a 85       	ldd	r25, Y+10	; 0x0a
    3c2e:	82 0f       	add	r24, r18
    3c30:	93 1f       	adc	r25, r19
    3c32:	9c 83       	std	Y+4, r25	; 0x04
    3c34:	8b 83       	std	Y+3, r24	; 0x03
	if( xNextHead >= pxStreamBuffer->xLength )
    3c36:	ed 81       	ldd	r30, Y+5	; 0x05
    3c38:	fe 81       	ldd	r31, Y+6	; 0x06
    3c3a:	24 81       	ldd	r18, Z+4	; 0x04
    3c3c:	35 81       	ldd	r19, Z+5	; 0x05
    3c3e:	8b 81       	ldd	r24, Y+3	; 0x03
    3c40:	9c 81       	ldd	r25, Y+4	; 0x04
    3c42:	82 17       	cp	r24, r18
    3c44:	93 07       	cpc	r25, r19
    3c46:	50 f0       	brcs	.+20     	; 0x3c5c <prvWriteBytesToBuffer+0xf8>
	{
		xNextHead -= pxStreamBuffer->xLength;
    3c48:	ed 81       	ldd	r30, Y+5	; 0x05
    3c4a:	fe 81       	ldd	r31, Y+6	; 0x06
    3c4c:	24 81       	ldd	r18, Z+4	; 0x04
    3c4e:	35 81       	ldd	r19, Z+5	; 0x05
    3c50:	8b 81       	ldd	r24, Y+3	; 0x03
    3c52:	9c 81       	ldd	r25, Y+4	; 0x04
    3c54:	82 1b       	sub	r24, r18
    3c56:	93 0b       	sbc	r25, r19
    3c58:	9c 83       	std	Y+4, r25	; 0x04
    3c5a:	8b 83       	std	Y+3, r24	; 0x03
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxStreamBuffer->xHead = xNextHead;
    3c5c:	ed 81       	ldd	r30, Y+5	; 0x05
    3c5e:	fe 81       	ldd	r31, Y+6	; 0x06
    3c60:	8b 81       	ldd	r24, Y+3	; 0x03
    3c62:	9c 81       	ldd	r25, Y+4	; 0x04
    3c64:	93 83       	std	Z+3, r25	; 0x03
    3c66:	82 83       	std	Z+2, r24	; 0x02

	return xCount;
    3c68:	89 85       	ldd	r24, Y+9	; 0x09
    3c6a:	9a 85       	ldd	r25, Y+10	; 0x0a
}
    3c6c:	2e 96       	adiw	r28, 0x0e	; 14
    3c6e:	0f b6       	in	r0, 0x3f	; 63
    3c70:	f8 94       	cli
    3c72:	de bf       	out	0x3e, r29	; 62
    3c74:	0f be       	out	0x3f, r0	; 63
    3c76:	cd bf       	out	0x3d, r28	; 61
    3c78:	cf 91       	pop	r28
    3c7a:	df 91       	pop	r29
    3c7c:	08 95       	ret

00003c7e <prvReadBytesFromBuffer>:
/*-----------------------------------------------------------*/

static size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer, uint8_t *pucData, size_t xMaxCount, size_t xBytesAvailable )
{
    3c7e:	df 93       	push	r29
    3c80:	cf 93       	push	r28
    3c82:	cd b7       	in	r28, 0x3d	; 61
    3c84:	de b7       	in	r29, 0x3e	; 62
    3c86:	66 97       	sbiw	r28, 0x16	; 22
    3c88:	0f b6       	in	r0, 0x3f	; 63
    3c8a:	f8 94       	cli
    3c8c:	de bf       	out	0x3e, r29	; 62
    3c8e:	0f be       	out	0x3f, r0	; 63
    3c90:	cd bf       	out	0x3d, r28	; 61
    3c92:	98 87       	std	Y+8, r25	; 0x08
    3c94:	8f 83       	std	Y+7, r24	; 0x07
    3c96:	7a 87       	std	Y+10, r23	; 0x0a
    3c98:	69 87       	std	Y+9, r22	; 0x09
    3c9a:	5c 87       	std	Y+12, r21	; 0x0c
    3c9c:	4b 87       	std	Y+11, r20	; 0x0b
    3c9e:	3e 87       	std	Y+14, r19	; 0x0e
    3ca0:	2d 87       	std	Y+13, r18	; 0x0d
size_t xCount, xFirstLength, xNextTail;

	/* Use the minimum of the wanted bytes and the available bytes. */
	xCount = configMIN( xBytesAvailable, xMaxCount );
    3ca2:	2d 85       	ldd	r18, Y+13	; 0x0d
    3ca4:	3e 85       	ldd	r19, Y+14	; 0x0e
    3ca6:	3a 8b       	std	Y+18, r19	; 0x12
    3ca8:	29 8b       	std	Y+17, r18	; 0x11
    3caa:	4b 85       	ldd	r20, Y+11	; 0x0b
    3cac:	5c 85       	ldd	r21, Y+12	; 0x0c
    3cae:	58 8b       	std	Y+16, r21	; 0x10
    3cb0:	4f 87       	std	Y+15, r20	; 0x0f
    3cb2:	8f 85       	ldd	r24, Y+15	; 0x0f
    3cb4:	98 89       	ldd	r25, Y+16	; 0x10
    3cb6:	29 89       	ldd	r18, Y+17	; 0x11
    3cb8:	3a 89       	ldd	r19, Y+18	; 0x12
    3cba:	28 17       	cp	r18, r24
    3cbc:	39 07       	cpc	r19, r25
    3cbe:	20 f4       	brcc	.+8      	; 0x3cc8 <prvReadBytesFromBuffer+0x4a>
    3cc0:	49 89       	ldd	r20, Y+17	; 0x11
    3cc2:	5a 89       	ldd	r21, Y+18	; 0x12
    3cc4:	58 8b       	std	Y+16, r21	; 0x10
    3cc6:	4f 87       	std	Y+15, r20	; 0x0f
    3cc8:	8f 85       	ldd	r24, Y+15	; 0x0f
    3cca:	98 89       	ldd	r25, Y+16	; 0x10
    3ccc:	9e 83       	std	Y+6, r25	; 0x06
    3cce:	8d 83       	std	Y+5, r24	; 0x05

	if( xCount > ( size_t ) 0 )
    3cd0:	8d 81       	ldd	r24, Y+5	; 0x05
    3cd2:	9e 81       	ldd	r25, Y+6	; 0x06
    3cd4:	00 97       	sbiw	r24, 0x00	; 0
    3cd6:	09 f4       	brne	.+2      	; 0x3cda <prvReadBytesFromBuffer+0x5c>
    3cd8:	74 c0       	rjmp	.+232    	; 0x3dc2 <prvReadBytesFromBuffer+0x144>
	{
		xNextTail = pxStreamBuffer->xTail;
    3cda:	ef 81       	ldd	r30, Y+7	; 0x07
    3cdc:	f8 85       	ldd	r31, Y+8	; 0x08
    3cde:	80 81       	ld	r24, Z
    3ce0:	91 81       	ldd	r25, Z+1	; 0x01
    3ce2:	9a 83       	std	Y+2, r25	; 0x02
    3ce4:	89 83       	std	Y+1, r24	; 0x01

		/* Calculate the number of bytes that can be read - which may be
		less than the number wanted if the data wraps around to the start of
		the buffer. */
		xFirstLength = configMIN( pxStreamBuffer->xLength - xNextTail, xCount );
    3ce6:	ef 81       	ldd	r30, Y+7	; 0x07
    3ce8:	f8 85       	ldd	r31, Y+8	; 0x08
    3cea:	24 81       	ldd	r18, Z+4	; 0x04
    3cec:	35 81       	ldd	r19, Z+5	; 0x05
    3cee:	89 81       	ldd	r24, Y+1	; 0x01
    3cf0:	9a 81       	ldd	r25, Y+2	; 0x02
    3cf2:	a9 01       	movw	r20, r18
    3cf4:	48 1b       	sub	r20, r24
    3cf6:	59 0b       	sbc	r21, r25
    3cf8:	ca 01       	movw	r24, r20
    3cfa:	2d 81       	ldd	r18, Y+5	; 0x05
    3cfc:	3e 81       	ldd	r19, Y+6	; 0x06
    3cfe:	3e 8b       	std	Y+22, r19	; 0x16
    3d00:	2d 8b       	std	Y+21, r18	; 0x15
    3d02:	9c 8b       	std	Y+20, r25	; 0x14
    3d04:	8b 8b       	std	Y+19, r24	; 0x13
    3d06:	4b 89       	ldd	r20, Y+19	; 0x13
    3d08:	5c 89       	ldd	r21, Y+20	; 0x14
    3d0a:	8d 89       	ldd	r24, Y+21	; 0x15
    3d0c:	9e 89       	ldd	r25, Y+22	; 0x16
    3d0e:	84 17       	cp	r24, r20
    3d10:	95 07       	cpc	r25, r21
    3d12:	20 f4       	brcc	.+8      	; 0x3d1c <prvReadBytesFromBuffer+0x9e>
    3d14:	2d 89       	ldd	r18, Y+21	; 0x15
    3d16:	3e 89       	ldd	r19, Y+22	; 0x16
    3d18:	3c 8b       	std	Y+20, r19	; 0x14
    3d1a:	2b 8b       	std	Y+19, r18	; 0x13
    3d1c:	4b 89       	ldd	r20, Y+19	; 0x13
    3d1e:	5c 89       	ldd	r21, Y+20	; 0x14
    3d20:	5c 83       	std	Y+4, r21	; 0x04
    3d22:	4b 83       	std	Y+3, r20	; 0x03

		/* Obtain the number of bytes it is possible to obtain in the first
		read.  Asserts check bounds of read and write. */
		configASSERT( xFirstLength <= xMaxCount );
		configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    3d24:	ef 81       	ldd	r30, Y+7	; 0x07
    3d26:	f8 85       	ldd	r31, Y+8	; 0x08
    3d28:	24 85       	ldd	r18, Z+12	; 0x0c
    3d2a:	35 85       	ldd	r19, Z+13	; 0x0d
    3d2c:	89 81       	ldd	r24, Y+1	; 0x01
    3d2e:	9a 81       	ldd	r25, Y+2	; 0x02
    3d30:	a9 01       	movw	r20, r18
    3d32:	48 0f       	add	r20, r24
    3d34:	59 1f       	adc	r21, r25
    3d36:	89 85       	ldd	r24, Y+9	; 0x09
    3d38:	9a 85       	ldd	r25, Y+10	; 0x0a
    3d3a:	2b 81       	ldd	r18, Y+3	; 0x03
    3d3c:	3c 81       	ldd	r19, Y+4	; 0x04
    3d3e:	ba 01       	movw	r22, r20
    3d40:	a9 01       	movw	r20, r18
    3d42:	0e 94 23 31 	call	0x6246	; 0x6246 <memcpy>

		/* If the total number of wanted bytes is greater than the number
		that could be read in the first read... */
		if( xCount > xFirstLength )
    3d46:	2d 81       	ldd	r18, Y+5	; 0x05
    3d48:	3e 81       	ldd	r19, Y+6	; 0x06
    3d4a:	8b 81       	ldd	r24, Y+3	; 0x03
    3d4c:	9c 81       	ldd	r25, Y+4	; 0x04
    3d4e:	82 17       	cp	r24, r18
    3d50:	93 07       	cpc	r25, r19
    3d52:	b0 f4       	brcc	.+44     	; 0x3d80 <prvReadBytesFromBuffer+0x102>
		{
			/*...then read the remaining bytes from the start of the buffer. */
			configASSERT( xCount <= xMaxCount );
			( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    3d54:	29 85       	ldd	r18, Y+9	; 0x09
    3d56:	3a 85       	ldd	r19, Y+10	; 0x0a
    3d58:	8b 81       	ldd	r24, Y+3	; 0x03
    3d5a:	9c 81       	ldd	r25, Y+4	; 0x04
    3d5c:	b9 01       	movw	r22, r18
    3d5e:	68 0f       	add	r22, r24
    3d60:	79 1f       	adc	r23, r25
    3d62:	ef 81       	ldd	r30, Y+7	; 0x07
    3d64:	f8 85       	ldd	r31, Y+8	; 0x08
    3d66:	44 85       	ldd	r20, Z+12	; 0x0c
    3d68:	55 85       	ldd	r21, Z+13	; 0x0d
    3d6a:	2d 81       	ldd	r18, Y+5	; 0x05
    3d6c:	3e 81       	ldd	r19, Y+6	; 0x06
    3d6e:	8b 81       	ldd	r24, Y+3	; 0x03
    3d70:	9c 81       	ldd	r25, Y+4	; 0x04
    3d72:	28 1b       	sub	r18, r24
    3d74:	39 0b       	sbc	r19, r25
    3d76:	cb 01       	movw	r24, r22
    3d78:	ba 01       	movw	r22, r20
    3d7a:	a9 01       	movw	r20, r18
    3d7c:	0e 94 23 31 	call	0x6246	; 0x6246 <memcpy>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Move the tail pointer to effectively remove the data read from
		the buffer. */
		xNextTail += xCount;
    3d80:	29 81       	ldd	r18, Y+1	; 0x01
    3d82:	3a 81       	ldd	r19, Y+2	; 0x02
    3d84:	8d 81       	ldd	r24, Y+5	; 0x05
    3d86:	9e 81       	ldd	r25, Y+6	; 0x06
    3d88:	82 0f       	add	r24, r18
    3d8a:	93 1f       	adc	r25, r19
    3d8c:	9a 83       	std	Y+2, r25	; 0x02
    3d8e:	89 83       	std	Y+1, r24	; 0x01

		if( xNextTail >= pxStreamBuffer->xLength )
    3d90:	ef 81       	ldd	r30, Y+7	; 0x07
    3d92:	f8 85       	ldd	r31, Y+8	; 0x08
    3d94:	24 81       	ldd	r18, Z+4	; 0x04
    3d96:	35 81       	ldd	r19, Z+5	; 0x05
    3d98:	89 81       	ldd	r24, Y+1	; 0x01
    3d9a:	9a 81       	ldd	r25, Y+2	; 0x02
    3d9c:	82 17       	cp	r24, r18
    3d9e:	93 07       	cpc	r25, r19
    3da0:	50 f0       	brcs	.+20     	; 0x3db6 <prvReadBytesFromBuffer+0x138>
		{
			xNextTail -= pxStreamBuffer->xLength;
    3da2:	ef 81       	ldd	r30, Y+7	; 0x07
    3da4:	f8 85       	ldd	r31, Y+8	; 0x08
    3da6:	24 81       	ldd	r18, Z+4	; 0x04
    3da8:	35 81       	ldd	r19, Z+5	; 0x05
    3daa:	89 81       	ldd	r24, Y+1	; 0x01
    3dac:	9a 81       	ldd	r25, Y+2	; 0x02
    3dae:	82 1b       	sub	r24, r18
    3db0:	93 0b       	sbc	r25, r19
    3db2:	9a 83       	std	Y+2, r25	; 0x02
    3db4:	89 83       	std	Y+1, r24	; 0x01
		}

		pxStreamBuffer->xTail = xNextTail;
    3db6:	ef 81       	ldd	r30, Y+7	; 0x07
    3db8:	f8 85       	ldd	r31, Y+8	; 0x08
    3dba:	89 81       	ldd	r24, Y+1	; 0x01
    3dbc:	9a 81       	ldd	r25, Y+2	; 0x02
    3dbe:	91 83       	std	Z+1, r25	; 0x01
    3dc0:	80 83       	st	Z, r24
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
    3dc2:	8d 81       	ldd	r24, Y+5	; 0x05
    3dc4:	9e 81       	ldd	r25, Y+6	; 0x06
}
    3dc6:	66 96       	adiw	r28, 0x16	; 22
    3dc8:	0f b6       	in	r0, 0x3f	; 63
    3dca:	f8 94       	cli
    3dcc:	de bf       	out	0x3e, r29	; 62
    3dce:	0f be       	out	0x3f, r0	; 63
    3dd0:	cd bf       	out	0x3d, r28	; 61
    3dd2:	cf 91       	pop	r28
    3dd4:	df 91       	pop	r29
    3dd6:	08 95       	ret

00003dd8 <prvBytesInBuffer>:
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
    3dd8:	df 93       	push	r29
    3dda:	cf 93       	push	r28
    3ddc:	00 d0       	rcall	.+0      	; 0x3dde <prvBytesInBuffer+0x6>
    3dde:	00 d0       	rcall	.+0      	; 0x3de0 <prvBytesInBuffer+0x8>
    3de0:	cd b7       	in	r28, 0x3d	; 61
    3de2:	de b7       	in	r29, 0x3e	; 62
    3de4:	9c 83       	std	Y+4, r25	; 0x04
    3de6:	8b 83       	std	Y+3, r24	; 0x03
/* Returns the distance between xTail and xHead. */
size_t xCount;

	xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    3de8:	eb 81       	ldd	r30, Y+3	; 0x03
    3dea:	fc 81       	ldd	r31, Y+4	; 0x04
    3dec:	24 81       	ldd	r18, Z+4	; 0x04
    3dee:	35 81       	ldd	r19, Z+5	; 0x05
    3df0:	eb 81       	ldd	r30, Y+3	; 0x03
    3df2:	fc 81       	ldd	r31, Y+4	; 0x04
    3df4:	82 81       	ldd	r24, Z+2	; 0x02
    3df6:	93 81       	ldd	r25, Z+3	; 0x03
    3df8:	82 0f       	add	r24, r18
    3dfa:	93 1f       	adc	r25, r19
    3dfc:	9a 83       	std	Y+2, r25	; 0x02
    3dfe:	89 83       	std	Y+1, r24	; 0x01
	xCount -= pxStreamBuffer->xTail;
    3e00:	eb 81       	ldd	r30, Y+3	; 0x03
    3e02:	fc 81       	ldd	r31, Y+4	; 0x04
    3e04:	20 81       	ld	r18, Z
    3e06:	31 81       	ldd	r19, Z+1	; 0x01
    3e08:	89 81       	ldd	r24, Y+1	; 0x01
    3e0a:	9a 81       	ldd	r25, Y+2	; 0x02
    3e0c:	82 1b       	sub	r24, r18
    3e0e:	93 0b       	sbc	r25, r19
    3e10:	9a 83       	std	Y+2, r25	; 0x02
    3e12:	89 83       	std	Y+1, r24	; 0x01
	if ( xCount >= pxStreamBuffer->xLength )
    3e14:	eb 81       	ldd	r30, Y+3	; 0x03
    3e16:	fc 81       	ldd	r31, Y+4	; 0x04
    3e18:	24 81       	ldd	r18, Z+4	; 0x04
    3e1a:	35 81       	ldd	r19, Z+5	; 0x05
    3e1c:	89 81       	ldd	r24, Y+1	; 0x01
    3e1e:	9a 81       	ldd	r25, Y+2	; 0x02
    3e20:	82 17       	cp	r24, r18
    3e22:	93 07       	cpc	r25, r19
    3e24:	50 f0       	brcs	.+20     	; 0x3e3a <prvBytesInBuffer+0x62>
	{
		xCount -= pxStreamBuffer->xLength;
    3e26:	eb 81       	ldd	r30, Y+3	; 0x03
    3e28:	fc 81       	ldd	r31, Y+4	; 0x04
    3e2a:	24 81       	ldd	r18, Z+4	; 0x04
    3e2c:	35 81       	ldd	r19, Z+5	; 0x05
    3e2e:	89 81       	ldd	r24, Y+1	; 0x01
    3e30:	9a 81       	ldd	r25, Y+2	; 0x02
    3e32:	82 1b       	sub	r24, r18
    3e34:	93 0b       	sbc	r25, r19
    3e36:	9a 83       	std	Y+2, r25	; 0x02
    3e38:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
    3e3a:	89 81       	ldd	r24, Y+1	; 0x01
    3e3c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3e3e:	0f 90       	pop	r0
    3e40:	0f 90       	pop	r0
    3e42:	0f 90       	pop	r0
    3e44:	0f 90       	pop	r0
    3e46:	cf 91       	pop	r28
    3e48:	df 91       	pop	r29
    3e4a:	08 95       	ret

00003e4c <prvInitialiseNewStreamBuffer>:
static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
										  uint8_t * const pucBuffer,
										  size_t xBufferSizeBytes,
										  size_t xTriggerLevelBytes,
										  uint8_t ucFlags )
{
    3e4c:	0f 93       	push	r16
    3e4e:	df 93       	push	r29
    3e50:	cf 93       	push	r28
    3e52:	cd b7       	in	r28, 0x3d	; 61
    3e54:	de b7       	in	r29, 0x3e	; 62
    3e56:	29 97       	sbiw	r28, 0x09	; 9
    3e58:	0f b6       	in	r0, 0x3f	; 63
    3e5a:	f8 94       	cli
    3e5c:	de bf       	out	0x3e, r29	; 62
    3e5e:	0f be       	out	0x3f, r0	; 63
    3e60:	cd bf       	out	0x3d, r28	; 61
    3e62:	9a 83       	std	Y+2, r25	; 0x02
    3e64:	89 83       	std	Y+1, r24	; 0x01
    3e66:	7c 83       	std	Y+4, r23	; 0x04
    3e68:	6b 83       	std	Y+3, r22	; 0x03
    3e6a:	5e 83       	std	Y+6, r21	; 0x06
    3e6c:	4d 83       	std	Y+5, r20	; 0x05
    3e6e:	38 87       	std	Y+8, r19	; 0x08
    3e70:	2f 83       	std	Y+7, r18	; 0x07
    3e72:	09 87       	std	Y+9, r16	; 0x09
		const BaseType_t xWriteValue = 0x55;
		configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
	} /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
	#endif

	( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
    3e74:	89 81       	ldd	r24, Y+1	; 0x01
    3e76:	9a 81       	ldd	r25, Y+2	; 0x02
    3e78:	60 e0       	ldi	r22, 0x00	; 0
    3e7a:	70 e0       	ldi	r23, 0x00	; 0
    3e7c:	4f e0       	ldi	r20, 0x0F	; 15
    3e7e:	50 e0       	ldi	r21, 0x00	; 0
    3e80:	0e 94 2c 31 	call	0x6258	; 0x6258 <memset>
	pxStreamBuffer->pucBuffer = pucBuffer;
    3e84:	e9 81       	ldd	r30, Y+1	; 0x01
    3e86:	fa 81       	ldd	r31, Y+2	; 0x02
    3e88:	8b 81       	ldd	r24, Y+3	; 0x03
    3e8a:	9c 81       	ldd	r25, Y+4	; 0x04
    3e8c:	95 87       	std	Z+13, r25	; 0x0d
    3e8e:	84 87       	std	Z+12, r24	; 0x0c
	pxStreamBuffer->xLength = xBufferSizeBytes;
    3e90:	e9 81       	ldd	r30, Y+1	; 0x01
    3e92:	fa 81       	ldd	r31, Y+2	; 0x02
    3e94:	8d 81       	ldd	r24, Y+5	; 0x05
    3e96:	9e 81       	ldd	r25, Y+6	; 0x06
    3e98:	95 83       	std	Z+5, r25	; 0x05
    3e9a:	84 83       	std	Z+4, r24	; 0x04
	pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
    3e9c:	e9 81       	ldd	r30, Y+1	; 0x01
    3e9e:	fa 81       	ldd	r31, Y+2	; 0x02
    3ea0:	8f 81       	ldd	r24, Y+7	; 0x07
    3ea2:	98 85       	ldd	r25, Y+8	; 0x08
    3ea4:	97 83       	std	Z+7, r25	; 0x07
    3ea6:	86 83       	std	Z+6, r24	; 0x06
	pxStreamBuffer->ucFlags = ucFlags;
    3ea8:	e9 81       	ldd	r30, Y+1	; 0x01
    3eaa:	fa 81       	ldd	r31, Y+2	; 0x02
    3eac:	89 85       	ldd	r24, Y+9	; 0x09
    3eae:	86 87       	std	Z+14, r24	; 0x0e
}
    3eb0:	29 96       	adiw	r28, 0x09	; 9
    3eb2:	0f b6       	in	r0, 0x3f	; 63
    3eb4:	f8 94       	cli
    3eb6:	de bf       	out	0x3e, r29	; 62
    3eb8:	0f be       	out	0x3f, r0	; 63
    3eba:	cd bf       	out	0x3d, r28	; 61
    3ebc:	cf 91       	pop	r28
    3ebe:	df 91       	pop	r29
    3ec0:	0f 91       	pop	r16
    3ec2:	08 95       	ret

00003ec4 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    3ec4:	8f 92       	push	r8
    3ec6:	9f 92       	push	r9
    3ec8:	af 92       	push	r10
    3eca:	bf 92       	push	r11
    3ecc:	cf 92       	push	r12
    3ece:	df 92       	push	r13
    3ed0:	ef 92       	push	r14
    3ed2:	ff 92       	push	r15
    3ed4:	0f 93       	push	r16
    3ed6:	1f 93       	push	r17
    3ed8:	df 93       	push	r29
    3eda:	cf 93       	push	r28
    3edc:	cd b7       	in	r28, 0x3d	; 61
    3ede:	de b7       	in	r29, 0x3e	; 62
    3ee0:	60 97       	sbiw	r28, 0x10	; 16
    3ee2:	0f b6       	in	r0, 0x3f	; 63
    3ee4:	f8 94       	cli
    3ee6:	de bf       	out	0x3e, r29	; 62
    3ee8:	0f be       	out	0x3f, r0	; 63
    3eea:	cd bf       	out	0x3d, r28	; 61
    3eec:	9f 83       	std	Y+7, r25	; 0x07
    3eee:	8e 83       	std	Y+6, r24	; 0x06
    3ef0:	79 87       	std	Y+9, r23	; 0x09
    3ef2:	68 87       	std	Y+8, r22	; 0x08
    3ef4:	5b 87       	std	Y+11, r21	; 0x0b
    3ef6:	4a 87       	std	Y+10, r20	; 0x0a
    3ef8:	3d 87       	std	Y+13, r19	; 0x0d
    3efa:	2c 87       	std	Y+12, r18	; 0x0c
    3efc:	0e 87       	std	Y+14, r16	; 0x0e
    3efe:	f8 8a       	std	Y+16, r15	; 0x10
    3f00:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    3f02:	8a 85       	ldd	r24, Y+10	; 0x0a
    3f04:	9b 85       	ldd	r25, Y+11	; 0x0b
    3f06:	0e 94 19 0c 	call	0x1832	; 0x1832 <pvPortMalloc>
    3f0a:	9a 83       	std	Y+2, r25	; 0x02
    3f0c:	89 83       	std	Y+1, r24	; 0x01

			if( pxStack != NULL )
    3f0e:	89 81       	ldd	r24, Y+1	; 0x01
    3f10:	9a 81       	ldd	r25, Y+2	; 0x02
    3f12:	00 97       	sbiw	r24, 0x00	; 0
    3f14:	b1 f0       	breq	.+44     	; 0x3f42 <xTaskCreate+0x7e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    3f16:	8e e2       	ldi	r24, 0x2E	; 46
    3f18:	90 e0       	ldi	r25, 0x00	; 0
    3f1a:	0e 94 19 0c 	call	0x1832	; 0x1832 <pvPortMalloc>
    3f1e:	9d 83       	std	Y+5, r25	; 0x05
    3f20:	8c 83       	std	Y+4, r24	; 0x04

				if( pxNewTCB != NULL )
    3f22:	8c 81       	ldd	r24, Y+4	; 0x04
    3f24:	9d 81       	ldd	r25, Y+5	; 0x05
    3f26:	00 97       	sbiw	r24, 0x00	; 0
    3f28:	39 f0       	breq	.+14     	; 0x3f38 <xTaskCreate+0x74>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    3f2a:	ec 81       	ldd	r30, Y+4	; 0x04
    3f2c:	fd 81       	ldd	r31, Y+5	; 0x05
    3f2e:	89 81       	ldd	r24, Y+1	; 0x01
    3f30:	9a 81       	ldd	r25, Y+2	; 0x02
    3f32:	90 8f       	std	Z+24, r25	; 0x18
    3f34:	87 8b       	std	Z+23, r24	; 0x17
    3f36:	07 c0       	rjmp	.+14     	; 0x3f46 <xTaskCreate+0x82>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    3f38:	89 81       	ldd	r24, Y+1	; 0x01
    3f3a:	9a 81       	ldd	r25, Y+2	; 0x02
    3f3c:	0e 94 6f 0c 	call	0x18de	; 0x18de <vPortFree>
    3f40:	02 c0       	rjmp	.+4      	; 0x3f46 <xTaskCreate+0x82>
				}
			}
			else
			{
				pxNewTCB = NULL;
    3f42:	1d 82       	std	Y+5, r1	; 0x05
    3f44:	1c 82       	std	Y+4, r1	; 0x04
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    3f46:	8c 81       	ldd	r24, Y+4	; 0x04
    3f48:	9d 81       	ldd	r25, Y+5	; 0x05
    3f4a:	00 97       	sbiw	r24, 0x00	; 0
    3f4c:	e9 f0       	breq	.+58     	; 0x3f88 <xTaskCreate+0xc4>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    3f4e:	8a 85       	ldd	r24, Y+10	; 0x0a
    3f50:	9b 85       	ldd	r25, Y+11	; 0x0b
    3f52:	9c 01       	movw	r18, r24
    3f54:	40 e0       	ldi	r20, 0x00	; 0
    3f56:	50 e0       	ldi	r21, 0x00	; 0
    3f58:	8e 81       	ldd	r24, Y+6	; 0x06
    3f5a:	9f 81       	ldd	r25, Y+7	; 0x07
    3f5c:	68 85       	ldd	r22, Y+8	; 0x08
    3f5e:	79 85       	ldd	r23, Y+9	; 0x09
    3f60:	ec 85       	ldd	r30, Y+12	; 0x0c
    3f62:	fd 85       	ldd	r31, Y+13	; 0x0d
    3f64:	af 85       	ldd	r26, Y+15	; 0x0f
    3f66:	b8 89       	ldd	r27, Y+16	; 0x10
    3f68:	ac 80       	ldd	r10, Y+4	; 0x04
    3f6a:	bd 80       	ldd	r11, Y+5	; 0x05
    3f6c:	8f 01       	movw	r16, r30
    3f6e:	ee 84       	ldd	r14, Y+14	; 0x0e
    3f70:	6d 01       	movw	r12, r26
    3f72:	88 24       	eor	r8, r8
    3f74:	99 24       	eor	r9, r9
    3f76:	0e 94 da 1f 	call	0x3fb4	; 0x3fb4 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    3f7a:	8c 81       	ldd	r24, Y+4	; 0x04
    3f7c:	9d 81       	ldd	r25, Y+5	; 0x05
    3f7e:	0e 94 96 20 	call	0x412c	; 0x412c <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    3f82:	81 e0       	ldi	r24, 0x01	; 1
    3f84:	8b 83       	std	Y+3, r24	; 0x03
    3f86:	02 c0       	rjmp	.+4      	; 0x3f8c <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    3f88:	8f ef       	ldi	r24, 0xFF	; 255
    3f8a:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    3f8c:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    3f8e:	60 96       	adiw	r28, 0x10	; 16
    3f90:	0f b6       	in	r0, 0x3f	; 63
    3f92:	f8 94       	cli
    3f94:	de bf       	out	0x3e, r29	; 62
    3f96:	0f be       	out	0x3f, r0	; 63
    3f98:	cd bf       	out	0x3d, r28	; 61
    3f9a:	cf 91       	pop	r28
    3f9c:	df 91       	pop	r29
    3f9e:	1f 91       	pop	r17
    3fa0:	0f 91       	pop	r16
    3fa2:	ff 90       	pop	r15
    3fa4:	ef 90       	pop	r14
    3fa6:	df 90       	pop	r13
    3fa8:	cf 90       	pop	r12
    3faa:	bf 90       	pop	r11
    3fac:	af 90       	pop	r10
    3fae:	9f 90       	pop	r9
    3fb0:	8f 90       	pop	r8
    3fb2:	08 95       	ret

00003fb4 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
    3fb4:	8f 92       	push	r8
    3fb6:	9f 92       	push	r9
    3fb8:	af 92       	push	r10
    3fba:	bf 92       	push	r11
    3fbc:	cf 92       	push	r12
    3fbe:	df 92       	push	r13
    3fc0:	ef 92       	push	r14
    3fc2:	0f 93       	push	r16
    3fc4:	1f 93       	push	r17
    3fc6:	df 93       	push	r29
    3fc8:	cf 93       	push	r28
    3fca:	cd b7       	in	r28, 0x3d	; 61
    3fcc:	de b7       	in	r29, 0x3e	; 62
    3fce:	64 97       	sbiw	r28, 0x14	; 20
    3fd0:	0f b6       	in	r0, 0x3f	; 63
    3fd2:	f8 94       	cli
    3fd4:	de bf       	out	0x3e, r29	; 62
    3fd6:	0f be       	out	0x3f, r0	; 63
    3fd8:	cd bf       	out	0x3d, r28	; 61
    3fda:	9d 83       	std	Y+5, r25	; 0x05
    3fdc:	8c 83       	std	Y+4, r24	; 0x04
    3fde:	7f 83       	std	Y+7, r23	; 0x07
    3fe0:	6e 83       	std	Y+6, r22	; 0x06
    3fe2:	28 87       	std	Y+8, r18	; 0x08
    3fe4:	39 87       	std	Y+9, r19	; 0x09
    3fe6:	4a 87       	std	Y+10, r20	; 0x0a
    3fe8:	5b 87       	std	Y+11, r21	; 0x0b
    3fea:	1d 87       	std	Y+13, r17	; 0x0d
    3fec:	0c 87       	std	Y+12, r16	; 0x0c
    3fee:	ee 86       	std	Y+14, r14	; 0x0e
    3ff0:	d8 8a       	std	Y+16, r13	; 0x10
    3ff2:	cf 86       	std	Y+15, r12	; 0x0f
    3ff4:	ba 8a       	std	Y+18, r11	; 0x12
    3ff6:	a9 8a       	std	Y+17, r10	; 0x11
    3ff8:	9c 8a       	std	Y+20, r9	; 0x14
    3ffa:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    3ffc:	e9 89       	ldd	r30, Y+17	; 0x11
    3ffe:	fa 89       	ldd	r31, Y+18	; 0x12
    4000:	27 89       	ldd	r18, Z+23	; 0x17
    4002:	30 8d       	ldd	r19, Z+24	; 0x18
    4004:	88 85       	ldd	r24, Y+8	; 0x08
    4006:	99 85       	ldd	r25, Y+9	; 0x09
    4008:	01 97       	sbiw	r24, 0x01	; 1
    400a:	82 0f       	add	r24, r18
    400c:	93 1f       	adc	r25, r19
    400e:	9b 83       	std	Y+3, r25	; 0x03
    4010:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    4012:	8e 81       	ldd	r24, Y+6	; 0x06
    4014:	9f 81       	ldd	r25, Y+7	; 0x07
    4016:	00 97       	sbiw	r24, 0x00	; 0
    4018:	51 f1       	breq	.+84     	; 0x406e <prvInitialiseNewTask+0xba>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    401a:	19 82       	std	Y+1, r1	; 0x01
    401c:	21 c0       	rjmp	.+66     	; 0x4060 <prvInitialiseNewTask+0xac>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    401e:	89 81       	ldd	r24, Y+1	; 0x01
    4020:	48 2f       	mov	r20, r24
    4022:	50 e0       	ldi	r21, 0x00	; 0
    4024:	89 81       	ldd	r24, Y+1	; 0x01
    4026:	28 2f       	mov	r18, r24
    4028:	30 e0       	ldi	r19, 0x00	; 0
    402a:	8e 81       	ldd	r24, Y+6	; 0x06
    402c:	9f 81       	ldd	r25, Y+7	; 0x07
    402e:	fc 01       	movw	r30, r24
    4030:	e2 0f       	add	r30, r18
    4032:	f3 1f       	adc	r31, r19
    4034:	20 81       	ld	r18, Z
    4036:	89 89       	ldd	r24, Y+17	; 0x11
    4038:	9a 89       	ldd	r25, Y+18	; 0x12
    403a:	84 0f       	add	r24, r20
    403c:	95 1f       	adc	r25, r21
    403e:	fc 01       	movw	r30, r24
    4040:	79 96       	adiw	r30, 0x19	; 25
    4042:	20 83       	st	Z, r18

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    4044:	89 81       	ldd	r24, Y+1	; 0x01
    4046:	28 2f       	mov	r18, r24
    4048:	30 e0       	ldi	r19, 0x00	; 0
    404a:	8e 81       	ldd	r24, Y+6	; 0x06
    404c:	9f 81       	ldd	r25, Y+7	; 0x07
    404e:	fc 01       	movw	r30, r24
    4050:	e2 0f       	add	r30, r18
    4052:	f3 1f       	adc	r31, r19
    4054:	80 81       	ld	r24, Z
    4056:	88 23       	and	r24, r24
    4058:	31 f0       	breq	.+12     	; 0x4066 <prvInitialiseNewTask+0xb2>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    405a:	89 81       	ldd	r24, Y+1	; 0x01
    405c:	8f 5f       	subi	r24, 0xFF	; 255
    405e:	89 83       	std	Y+1, r24	; 0x01
    4060:	89 81       	ldd	r24, Y+1	; 0x01
    4062:	80 31       	cpi	r24, 0x10	; 16
    4064:	e0 f2       	brcs	.-72     	; 0x401e <prvInitialiseNewTask+0x6a>
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    4066:	e9 89       	ldd	r30, Y+17	; 0x11
    4068:	fa 89       	ldd	r31, Y+18	; 0x12
    406a:	10 a6       	std	Z+40, r1	; 0x28
    406c:	03 c0       	rjmp	.+6      	; 0x4074 <prvInitialiseNewTask+0xc0>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    406e:	e9 89       	ldd	r30, Y+17	; 0x11
    4070:	fa 89       	ldd	r31, Y+18	; 0x12
    4072:	11 8e       	std	Z+25, r1	; 0x19
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    4074:	8e 85       	ldd	r24, Y+14	; 0x0e
    4076:	84 30       	cpi	r24, 0x04	; 4
    4078:	10 f0       	brcs	.+4      	; 0x407e <prvInitialiseNewTask+0xca>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    407a:	83 e0       	ldi	r24, 0x03	; 3
    407c:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    407e:	e9 89       	ldd	r30, Y+17	; 0x11
    4080:	fa 89       	ldd	r31, Y+18	; 0x12
    4082:	8e 85       	ldd	r24, Y+14	; 0x0e
    4084:	86 8b       	std	Z+22, r24	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    4086:	89 89       	ldd	r24, Y+17	; 0x11
    4088:	9a 89       	ldd	r25, Y+18	; 0x12
    408a:	02 96       	adiw	r24, 0x02	; 2
    408c:	0e 94 bf 0c 	call	0x197e	; 0x197e <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    4090:	89 89       	ldd	r24, Y+17	; 0x11
    4092:	9a 89       	ldd	r25, Y+18	; 0x12
    4094:	0c 96       	adiw	r24, 0x0c	; 12
    4096:	0e 94 bf 0c 	call	0x197e	; 0x197e <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    409a:	e9 89       	ldd	r30, Y+17	; 0x11
    409c:	fa 89       	ldd	r31, Y+18	; 0x12
    409e:	89 89       	ldd	r24, Y+17	; 0x11
    40a0:	9a 89       	ldd	r25, Y+18	; 0x12
    40a2:	91 87       	std	Z+9, r25	; 0x09
    40a4:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    40a6:	8e 85       	ldd	r24, Y+14	; 0x0e
    40a8:	28 2f       	mov	r18, r24
    40aa:	30 e0       	ldi	r19, 0x00	; 0
    40ac:	84 e0       	ldi	r24, 0x04	; 4
    40ae:	90 e0       	ldi	r25, 0x00	; 0
    40b0:	82 1b       	sub	r24, r18
    40b2:	93 0b       	sbc	r25, r19
    40b4:	e9 89       	ldd	r30, Y+17	; 0x11
    40b6:	fa 89       	ldd	r31, Y+18	; 0x12
    40b8:	95 87       	std	Z+13, r25	; 0x0d
    40ba:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    40bc:	e9 89       	ldd	r30, Y+17	; 0x11
    40be:	fa 89       	ldd	r31, Y+18	; 0x12
    40c0:	89 89       	ldd	r24, Y+17	; 0x11
    40c2:	9a 89       	ldd	r25, Y+18	; 0x12
    40c4:	93 8b       	std	Z+19, r25	; 0x13
    40c6:	82 8b       	std	Z+18, r24	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    40c8:	e9 89       	ldd	r30, Y+17	; 0x11
    40ca:	fa 89       	ldd	r31, Y+18	; 0x12
    40cc:	11 a6       	std	Z+41, r1	; 0x29
    40ce:	12 a6       	std	Z+42, r1	; 0x2a
    40d0:	13 a6       	std	Z+43, r1	; 0x2b
    40d2:	14 a6       	std	Z+44, r1	; 0x2c
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    40d4:	e9 89       	ldd	r30, Y+17	; 0x11
    40d6:	fa 89       	ldd	r31, Y+18	; 0x12
    40d8:	15 a6       	std	Z+45, r1	; 0x2d
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    40da:	8a 81       	ldd	r24, Y+2	; 0x02
    40dc:	9b 81       	ldd	r25, Y+3	; 0x03
    40de:	2c 81       	ldd	r18, Y+4	; 0x04
    40e0:	3d 81       	ldd	r19, Y+5	; 0x05
    40e2:	4c 85       	ldd	r20, Y+12	; 0x0c
    40e4:	5d 85       	ldd	r21, Y+13	; 0x0d
    40e6:	b9 01       	movw	r22, r18
    40e8:	0e 94 cb 0d 	call	0x1b96	; 0x1b96 <pxPortInitialiseStack>
    40ec:	e9 89       	ldd	r30, Y+17	; 0x11
    40ee:	fa 89       	ldd	r31, Y+18	; 0x12
    40f0:	91 83       	std	Z+1, r25	; 0x01
    40f2:	80 83       	st	Z, r24
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    40f4:	8f 85       	ldd	r24, Y+15	; 0x0f
    40f6:	98 89       	ldd	r25, Y+16	; 0x10
    40f8:	00 97       	sbiw	r24, 0x00	; 0
    40fa:	31 f0       	breq	.+12     	; 0x4108 <prvInitialiseNewTask+0x154>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    40fc:	ef 85       	ldd	r30, Y+15	; 0x0f
    40fe:	f8 89       	ldd	r31, Y+16	; 0x10
    4100:	89 89       	ldd	r24, Y+17	; 0x11
    4102:	9a 89       	ldd	r25, Y+18	; 0x12
    4104:	91 83       	std	Z+1, r25	; 0x01
    4106:	80 83       	st	Z, r24
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    4108:	64 96       	adiw	r28, 0x14	; 20
    410a:	0f b6       	in	r0, 0x3f	; 63
    410c:	f8 94       	cli
    410e:	de bf       	out	0x3e, r29	; 62
    4110:	0f be       	out	0x3f, r0	; 63
    4112:	cd bf       	out	0x3d, r28	; 61
    4114:	cf 91       	pop	r28
    4116:	df 91       	pop	r29
    4118:	1f 91       	pop	r17
    411a:	0f 91       	pop	r16
    411c:	ef 90       	pop	r14
    411e:	df 90       	pop	r13
    4120:	cf 90       	pop	r12
    4122:	bf 90       	pop	r11
    4124:	af 90       	pop	r10
    4126:	9f 90       	pop	r9
    4128:	8f 90       	pop	r8
    412a:	08 95       	ret

0000412c <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    412c:	df 93       	push	r29
    412e:	cf 93       	push	r28
    4130:	00 d0       	rcall	.+0      	; 0x4132 <prvAddNewTaskToReadyList+0x6>
    4132:	00 d0       	rcall	.+0      	; 0x4134 <prvAddNewTaskToReadyList+0x8>
    4134:	cd b7       	in	r28, 0x3d	; 61
    4136:	de b7       	in	r29, 0x3e	; 62
    4138:	9a 83       	std	Y+2, r25	; 0x02
    413a:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    413c:	0f b6       	in	r0, 0x3f	; 63
    413e:	f8 94       	cli
    4140:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    4142:	80 91 a3 06 	lds	r24, 0x06A3
    4146:	8f 5f       	subi	r24, 0xFF	; 255
    4148:	80 93 a3 06 	sts	0x06A3, r24
		if( pxCurrentTCB == NULL )
    414c:	80 91 a0 06 	lds	r24, 0x06A0
    4150:	90 91 a1 06 	lds	r25, 0x06A1
    4154:	00 97       	sbiw	r24, 0x00	; 0
    4156:	69 f4       	brne	.+26     	; 0x4172 <prvAddNewTaskToReadyList+0x46>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    4158:	89 81       	ldd	r24, Y+1	; 0x01
    415a:	9a 81       	ldd	r25, Y+2	; 0x02
    415c:	90 93 a1 06 	sts	0x06A1, r25
    4160:	80 93 a0 06 	sts	0x06A0, r24

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    4164:	80 91 a3 06 	lds	r24, 0x06A3
    4168:	81 30       	cpi	r24, 0x01	; 1
    416a:	b9 f4       	brne	.+46     	; 0x419a <prvAddNewTaskToReadyList+0x6e>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    416c:	0e 94 35 27 	call	0x4e6a	; 0x4e6a <prvInitialiseTaskLists>
    4170:	14 c0       	rjmp	.+40     	; 0x419a <prvAddNewTaskToReadyList+0x6e>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    4172:	80 91 a7 06 	lds	r24, 0x06A7
    4176:	88 23       	and	r24, r24
    4178:	81 f4       	brne	.+32     	; 0x419a <prvAddNewTaskToReadyList+0x6e>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    417a:	e0 91 a0 06 	lds	r30, 0x06A0
    417e:	f0 91 a1 06 	lds	r31, 0x06A1
    4182:	96 89       	ldd	r25, Z+22	; 0x16
    4184:	e9 81       	ldd	r30, Y+1	; 0x01
    4186:	fa 81       	ldd	r31, Y+2	; 0x02
    4188:	86 89       	ldd	r24, Z+22	; 0x16
    418a:	89 17       	cp	r24, r25
    418c:	30 f0       	brcs	.+12     	; 0x419a <prvAddNewTaskToReadyList+0x6e>
				{
					pxCurrentTCB = pxNewTCB;
    418e:	89 81       	ldd	r24, Y+1	; 0x01
    4190:	9a 81       	ldd	r25, Y+2	; 0x02
    4192:	90 93 a1 06 	sts	0x06A1, r25
    4196:	80 93 a0 06 	sts	0x06A0, r24
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    419a:	80 91 ab 06 	lds	r24, 0x06AB
    419e:	8f 5f       	subi	r24, 0xFF	; 255
    41a0:	80 93 ab 06 	sts	0x06AB, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    41a4:	e9 81       	ldd	r30, Y+1	; 0x01
    41a6:	fa 81       	ldd	r31, Y+2	; 0x02
    41a8:	96 89       	ldd	r25, Z+22	; 0x16
    41aa:	80 91 a6 06 	lds	r24, 0x06A6
    41ae:	89 17       	cp	r24, r25
    41b0:	28 f4       	brcc	.+10     	; 0x41bc <prvAddNewTaskToReadyList+0x90>
    41b2:	e9 81       	ldd	r30, Y+1	; 0x01
    41b4:	fa 81       	ldd	r31, Y+2	; 0x02
    41b6:	86 89       	ldd	r24, Z+22	; 0x16
    41b8:	80 93 a6 06 	sts	0x06A6, r24
    41bc:	e9 81       	ldd	r30, Y+1	; 0x01
    41be:	fa 81       	ldd	r31, Y+2	; 0x02
    41c0:	86 89       	ldd	r24, Z+22	; 0x16
    41c2:	28 2f       	mov	r18, r24
    41c4:	30 e0       	ldi	r19, 0x00	; 0
    41c6:	c9 01       	movw	r24, r18
    41c8:	88 0f       	add	r24, r24
    41ca:	99 1f       	adc	r25, r25
    41cc:	88 0f       	add	r24, r24
    41ce:	99 1f       	adc	r25, r25
    41d0:	88 0f       	add	r24, r24
    41d2:	99 1f       	adc	r25, r25
    41d4:	82 0f       	add	r24, r18
    41d6:	93 1f       	adc	r25, r19
    41d8:	ac 01       	movw	r20, r24
    41da:	4f 54       	subi	r20, 0x4F	; 79
    41dc:	59 4f       	sbci	r21, 0xF9	; 249
    41de:	89 81       	ldd	r24, Y+1	; 0x01
    41e0:	9a 81       	ldd	r25, Y+2	; 0x02
    41e2:	9c 01       	movw	r18, r24
    41e4:	2e 5f       	subi	r18, 0xFE	; 254
    41e6:	3f 4f       	sbci	r19, 0xFF	; 255
    41e8:	ca 01       	movw	r24, r20
    41ea:	b9 01       	movw	r22, r18
    41ec:	0e 94 cf 0c 	call	0x199e	; 0x199e <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    41f0:	0f 90       	pop	r0
    41f2:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    41f4:	80 91 a7 06 	lds	r24, 0x06A7
    41f8:	88 23       	and	r24, r24
    41fa:	21 f0       	breq	.+8      	; 0x4204 <prvAddNewTaskToReadyList+0xd8>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    41fc:	80 91 a0 06 	lds	r24, 0x06A0
    4200:	90 91 a1 06 	lds	r25, 0x06A1
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    4204:	0f 90       	pop	r0
    4206:	0f 90       	pop	r0
    4208:	0f 90       	pop	r0
    420a:	0f 90       	pop	r0
    420c:	cf 91       	pop	r28
    420e:	df 91       	pop	r29
    4210:	08 95       	ret

00004212 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    4212:	df 93       	push	r29
    4214:	cf 93       	push	r28
    4216:	00 d0       	rcall	.+0      	; 0x4218 <vTaskDelete+0x6>
    4218:	00 d0       	rcall	.+0      	; 0x421a <vTaskDelete+0x8>
    421a:	00 d0       	rcall	.+0      	; 0x421c <vTaskDelete+0xa>
    421c:	cd b7       	in	r28, 0x3d	; 61
    421e:	de b7       	in	r29, 0x3e	; 62
    4220:	9c 83       	std	Y+4, r25	; 0x04
    4222:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    4224:	0f b6       	in	r0, 0x3f	; 63
    4226:	f8 94       	cli
    4228:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    422a:	8b 81       	ldd	r24, Y+3	; 0x03
    422c:	9c 81       	ldd	r25, Y+4	; 0x04
    422e:	00 97       	sbiw	r24, 0x00	; 0
    4230:	39 f4       	brne	.+14     	; 0x4240 <vTaskDelete+0x2e>
    4232:	80 91 a0 06 	lds	r24, 0x06A0
    4236:	90 91 a1 06 	lds	r25, 0x06A1
    423a:	9e 83       	std	Y+6, r25	; 0x06
    423c:	8d 83       	std	Y+5, r24	; 0x05
    423e:	04 c0       	rjmp	.+8      	; 0x4248 <vTaskDelete+0x36>
    4240:	8b 81       	ldd	r24, Y+3	; 0x03
    4242:	9c 81       	ldd	r25, Y+4	; 0x04
    4244:	9e 83       	std	Y+6, r25	; 0x06
    4246:	8d 83       	std	Y+5, r24	; 0x05
    4248:	8d 81       	ldd	r24, Y+5	; 0x05
    424a:	9e 81       	ldd	r25, Y+6	; 0x06
    424c:	9a 83       	std	Y+2, r25	; 0x02
    424e:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    4250:	89 81       	ldd	r24, Y+1	; 0x01
    4252:	9a 81       	ldd	r25, Y+2	; 0x02
    4254:	02 96       	adiw	r24, 0x02	; 2
    4256:	0e 94 7f 0d 	call	0x1afe	; 0x1afe <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    425a:	e9 81       	ldd	r30, Y+1	; 0x01
    425c:	fa 81       	ldd	r31, Y+2	; 0x02
    425e:	84 89       	ldd	r24, Z+20	; 0x14
    4260:	95 89       	ldd	r25, Z+21	; 0x15
    4262:	00 97       	sbiw	r24, 0x00	; 0
    4264:	29 f0       	breq	.+10     	; 0x4270 <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4266:	89 81       	ldd	r24, Y+1	; 0x01
    4268:	9a 81       	ldd	r25, Y+2	; 0x02
    426a:	0c 96       	adiw	r24, 0x0c	; 12
    426c:	0e 94 7f 0d 	call	0x1afe	; 0x1afe <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    4270:	80 91 ab 06 	lds	r24, 0x06AB
    4274:	8f 5f       	subi	r24, 0xFF	; 255
    4276:	80 93 ab 06 	sts	0x06AB, r24

			if( pxTCB == pxCurrentTCB )
    427a:	20 91 a0 06 	lds	r18, 0x06A0
    427e:	30 91 a1 06 	lds	r19, 0x06A1
    4282:	89 81       	ldd	r24, Y+1	; 0x01
    4284:	9a 81       	ldd	r25, Y+2	; 0x02
    4286:	82 17       	cp	r24, r18
    4288:	93 07       	cpc	r25, r19
    428a:	81 f4       	brne	.+32     	; 0x42ac <vTaskDelete+0x9a>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    428c:	89 81       	ldd	r24, Y+1	; 0x01
    428e:	9a 81       	ldd	r25, Y+2	; 0x02
    4290:	9c 01       	movw	r18, r24
    4292:	2e 5f       	subi	r18, 0xFE	; 254
    4294:	3f 4f       	sbci	r19, 0xFF	; 255
    4296:	84 ef       	ldi	r24, 0xF4	; 244
    4298:	96 e0       	ldi	r25, 0x06	; 6
    429a:	b9 01       	movw	r22, r18
    429c:	0e 94 cf 0c 	call	0x199e	; 0x199e <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    42a0:	80 91 a2 06 	lds	r24, 0x06A2
    42a4:	8f 5f       	subi	r24, 0xFF	; 255
    42a6:	80 93 a2 06 	sts	0x06A2, r24
    42aa:	0b c0       	rjmp	.+22     	; 0x42c2 <vTaskDelete+0xb0>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    42ac:	80 91 a3 06 	lds	r24, 0x06A3
    42b0:	81 50       	subi	r24, 0x01	; 1
    42b2:	80 93 a3 06 	sts	0x06A3, r24
				prvDeleteTCB( pxTCB );
    42b6:	89 81       	ldd	r24, Y+1	; 0x01
    42b8:	9a 81       	ldd	r25, Y+2	; 0x02
    42ba:	0e 94 a5 27 	call	0x4f4a	; 0x4f4a <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    42be:	0e 94 bb 27 	call	0x4f76	; 0x4f76 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    42c2:	0f 90       	pop	r0
    42c4:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    42c6:	80 91 a7 06 	lds	r24, 0x06A7
    42ca:	88 23       	and	r24, r24
    42cc:	59 f0       	breq	.+22     	; 0x42e4 <vTaskDelete+0xd2>
		{
			if( pxTCB == pxCurrentTCB )
    42ce:	20 91 a0 06 	lds	r18, 0x06A0
    42d2:	30 91 a1 06 	lds	r19, 0x06A1
    42d6:	89 81       	ldd	r24, Y+1	; 0x01
    42d8:	9a 81       	ldd	r25, Y+2	; 0x02
    42da:	82 17       	cp	r24, r18
    42dc:	93 07       	cpc	r25, r19
    42de:	11 f4       	brne	.+4      	; 0x42e4 <vTaskDelete+0xd2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    42e0:	0e 94 8a 0f 	call	0x1f14	; 0x1f14 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    42e4:	26 96       	adiw	r28, 0x06	; 6
    42e6:	0f b6       	in	r0, 0x3f	; 63
    42e8:	f8 94       	cli
    42ea:	de bf       	out	0x3e, r29	; 62
    42ec:	0f be       	out	0x3f, r0	; 63
    42ee:	cd bf       	out	0x3d, r28	; 61
    42f0:	cf 91       	pop	r28
    42f2:	df 91       	pop	r29
    42f4:	08 95       	ret

000042f6 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    42f6:	df 93       	push	r29
    42f8:	cf 93       	push	r28
    42fa:	00 d0       	rcall	.+0      	; 0x42fc <vTaskDelay+0x6>
    42fc:	0f 92       	push	r0
    42fe:	cd b7       	in	r28, 0x3d	; 61
    4300:	de b7       	in	r29, 0x3e	; 62
    4302:	9b 83       	std	Y+3, r25	; 0x03
    4304:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    4306:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    4308:	8a 81       	ldd	r24, Y+2	; 0x02
    430a:	9b 81       	ldd	r25, Y+3	; 0x03
    430c:	00 97       	sbiw	r24, 0x00	; 0
    430e:	51 f0       	breq	.+20     	; 0x4324 <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    4310:	0e 94 43 23 	call	0x4686	; 0x4686 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    4314:	8a 81       	ldd	r24, Y+2	; 0x02
    4316:	9b 81       	ldd	r25, Y+3	; 0x03
    4318:	60 e0       	ldi	r22, 0x00	; 0
    431a:	0e 94 bf 2b 	call	0x577e	; 0x577e <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    431e:	0e 94 4f 23 	call	0x469e	; 0x469e <xTaskResumeAll>
    4322:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    4324:	89 81       	ldd	r24, Y+1	; 0x01
    4326:	88 23       	and	r24, r24
    4328:	11 f4       	brne	.+4      	; 0x432e <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    432a:	0e 94 8a 0f 	call	0x1f14	; 0x1f14 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    432e:	0f 90       	pop	r0
    4330:	0f 90       	pop	r0
    4332:	0f 90       	pop	r0
    4334:	cf 91       	pop	r28
    4336:	df 91       	pop	r29
    4338:	08 95       	ret

0000433a <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    433a:	df 93       	push	r29
    433c:	cf 93       	push	r28
    433e:	00 d0       	rcall	.+0      	; 0x4340 <vTaskSuspend+0x6>
    4340:	00 d0       	rcall	.+0      	; 0x4342 <vTaskSuspend+0x8>
    4342:	00 d0       	rcall	.+0      	; 0x4344 <vTaskSuspend+0xa>
    4344:	cd b7       	in	r28, 0x3d	; 61
    4346:	de b7       	in	r29, 0x3e	; 62
    4348:	9c 83       	std	Y+4, r25	; 0x04
    434a:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    434c:	0f b6       	in	r0, 0x3f	; 63
    434e:	f8 94       	cli
    4350:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    4352:	8b 81       	ldd	r24, Y+3	; 0x03
    4354:	9c 81       	ldd	r25, Y+4	; 0x04
    4356:	00 97       	sbiw	r24, 0x00	; 0
    4358:	39 f4       	brne	.+14     	; 0x4368 <vTaskSuspend+0x2e>
    435a:	80 91 a0 06 	lds	r24, 0x06A0
    435e:	90 91 a1 06 	lds	r25, 0x06A1
    4362:	9e 83       	std	Y+6, r25	; 0x06
    4364:	8d 83       	std	Y+5, r24	; 0x05
    4366:	04 c0       	rjmp	.+8      	; 0x4370 <vTaskSuspend+0x36>
    4368:	8b 81       	ldd	r24, Y+3	; 0x03
    436a:	9c 81       	ldd	r25, Y+4	; 0x04
    436c:	9e 83       	std	Y+6, r25	; 0x06
    436e:	8d 83       	std	Y+5, r24	; 0x05
    4370:	8d 81       	ldd	r24, Y+5	; 0x05
    4372:	9e 81       	ldd	r25, Y+6	; 0x06
    4374:	9a 83       	std	Y+2, r25	; 0x02
    4376:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    4378:	89 81       	ldd	r24, Y+1	; 0x01
    437a:	9a 81       	ldd	r25, Y+2	; 0x02
    437c:	02 96       	adiw	r24, 0x02	; 2
    437e:	0e 94 7f 0d 	call	0x1afe	; 0x1afe <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    4382:	e9 81       	ldd	r30, Y+1	; 0x01
    4384:	fa 81       	ldd	r31, Y+2	; 0x02
    4386:	84 89       	ldd	r24, Z+20	; 0x14
    4388:	95 89       	ldd	r25, Z+21	; 0x15
    438a:	00 97       	sbiw	r24, 0x00	; 0
    438c:	29 f0       	breq	.+10     	; 0x4398 <vTaskSuspend+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    438e:	89 81       	ldd	r24, Y+1	; 0x01
    4390:	9a 81       	ldd	r25, Y+2	; 0x02
    4392:	0c 96       	adiw	r24, 0x0c	; 12
    4394:	0e 94 7f 0d 	call	0x1afe	; 0x1afe <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    4398:	89 81       	ldd	r24, Y+1	; 0x01
    439a:	9a 81       	ldd	r25, Y+2	; 0x02
    439c:	9c 01       	movw	r18, r24
    439e:	2e 5f       	subi	r18, 0xFE	; 254
    43a0:	3f 4f       	sbci	r19, 0xFF	; 255
    43a2:	8d ef       	ldi	r24, 0xFD	; 253
    43a4:	96 e0       	ldi	r25, 0x06	; 6
    43a6:	b9 01       	movw	r22, r18
    43a8:	0e 94 cf 0c 	call	0x199e	; 0x199e <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    43ac:	e9 81       	ldd	r30, Y+1	; 0x01
    43ae:	fa 81       	ldd	r31, Y+2	; 0x02
    43b0:	85 a5       	ldd	r24, Z+45	; 0x2d
    43b2:	81 30       	cpi	r24, 0x01	; 1
    43b4:	19 f4       	brne	.+6      	; 0x43bc <vTaskSuspend+0x82>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    43b6:	e9 81       	ldd	r30, Y+1	; 0x01
    43b8:	fa 81       	ldd	r31, Y+2	; 0x02
    43ba:	15 a6       	std	Z+45, r1	; 0x2d
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
    43bc:	0f 90       	pop	r0
    43be:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    43c0:	80 91 a7 06 	lds	r24, 0x06A7
    43c4:	88 23       	and	r24, r24
    43c6:	39 f0       	breq	.+14     	; 0x43d6 <vTaskSuspend+0x9c>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    43c8:	0f b6       	in	r0, 0x3f	; 63
    43ca:	f8 94       	cli
    43cc:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    43ce:	0e 94 bb 27 	call	0x4f76	; 0x4f76 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    43d2:	0f 90       	pop	r0
    43d4:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    43d6:	20 91 a0 06 	lds	r18, 0x06A0
    43da:	30 91 a1 06 	lds	r19, 0x06A1
    43de:	89 81       	ldd	r24, Y+1	; 0x01
    43e0:	9a 81       	ldd	r25, Y+2	; 0x02
    43e2:	82 17       	cp	r24, r18
    43e4:	93 07       	cpc	r25, r19
    43e6:	a1 f4       	brne	.+40     	; 0x4410 <vTaskSuspend+0xd6>
		{
			if( xSchedulerRunning != pdFALSE )
    43e8:	80 91 a7 06 	lds	r24, 0x06A7
    43ec:	88 23       	and	r24, r24
    43ee:	19 f0       	breq	.+6      	; 0x43f6 <vTaskSuspend+0xbc>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    43f0:	0e 94 8a 0f 	call	0x1f14	; 0x1f14 <vPortYield>
    43f4:	0d c0       	rjmp	.+26     	; 0x4410 <vTaskSuspend+0xd6>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    43f6:	90 91 fd 06 	lds	r25, 0x06FD
    43fa:	80 91 a3 06 	lds	r24, 0x06A3
    43fe:	98 17       	cp	r25, r24
    4400:	29 f4       	brne	.+10     	; 0x440c <vTaskSuspend+0xd2>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    4402:	10 92 a1 06 	sts	0x06A1, r1
    4406:	10 92 a0 06 	sts	0x06A0, r1
    440a:	02 c0       	rjmp	.+4      	; 0x4410 <vTaskSuspend+0xd6>
				}
				else
				{
					vTaskSwitchContext();
    440c:	0e 94 f4 24 	call	0x49e8	; 0x49e8 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    4410:	26 96       	adiw	r28, 0x06	; 6
    4412:	0f b6       	in	r0, 0x3f	; 63
    4414:	f8 94       	cli
    4416:	de bf       	out	0x3e, r29	; 62
    4418:	0f be       	out	0x3f, r0	; 63
    441a:	cd bf       	out	0x3d, r28	; 61
    441c:	cf 91       	pop	r28
    441e:	df 91       	pop	r29
    4420:	08 95       	ret

00004422 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    4422:	df 93       	push	r29
    4424:	cf 93       	push	r28
    4426:	00 d0       	rcall	.+0      	; 0x4428 <prvTaskIsTaskSuspended+0x6>
    4428:	00 d0       	rcall	.+0      	; 0x442a <prvTaskIsTaskSuspended+0x8>
    442a:	0f 92       	push	r0
    442c:	cd b7       	in	r28, 0x3d	; 61
    442e:	de b7       	in	r29, 0x3e	; 62
    4430:	9d 83       	std	Y+5, r25	; 0x05
    4432:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn = pdFALSE;
    4434:	1b 82       	std	Y+3, r1	; 0x03
	const TCB_t * const pxTCB = xTask;
    4436:	8c 81       	ldd	r24, Y+4	; 0x04
    4438:	9d 81       	ldd	r25, Y+5	; 0x05
    443a:	9a 83       	std	Y+2, r25	; 0x02
    443c:	89 83       	std	Y+1, r24	; 0x01

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    443e:	e9 81       	ldd	r30, Y+1	; 0x01
    4440:	fa 81       	ldd	r31, Y+2	; 0x02
    4442:	82 85       	ldd	r24, Z+10	; 0x0a
    4444:	93 85       	ldd	r25, Z+11	; 0x0b
    4446:	26 e0       	ldi	r18, 0x06	; 6
    4448:	8d 3f       	cpi	r24, 0xFD	; 253
    444a:	92 07       	cpc	r25, r18
    444c:	81 f4       	brne	.+32     	; 0x446e <prvTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    444e:	e9 81       	ldd	r30, Y+1	; 0x01
    4450:	fa 81       	ldd	r31, Y+2	; 0x02
    4452:	84 89       	ldd	r24, Z+20	; 0x14
    4454:	95 89       	ldd	r25, Z+21	; 0x15
    4456:	26 e0       	ldi	r18, 0x06	; 6
    4458:	8b 3e       	cpi	r24, 0xEB	; 235
    445a:	92 07       	cpc	r25, r18
    445c:	41 f0       	breq	.+16     	; 0x446e <prvTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
    445e:	e9 81       	ldd	r30, Y+1	; 0x01
    4460:	fa 81       	ldd	r31, Y+2	; 0x02
    4462:	84 89       	ldd	r24, Z+20	; 0x14
    4464:	95 89       	ldd	r25, Z+21	; 0x15
    4466:	00 97       	sbiw	r24, 0x00	; 0
    4468:	11 f4       	brne	.+4      	; 0x446e <prvTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
    446a:	81 e0       	ldi	r24, 0x01	; 1
    446c:	8b 83       	std	Y+3, r24	; 0x03
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    446e:	8b 81       	ldd	r24, Y+3	; 0x03
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    4470:	0f 90       	pop	r0
    4472:	0f 90       	pop	r0
    4474:	0f 90       	pop	r0
    4476:	0f 90       	pop	r0
    4478:	0f 90       	pop	r0
    447a:	cf 91       	pop	r28
    447c:	df 91       	pop	r29
    447e:	08 95       	ret

00004480 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    4480:	df 93       	push	r29
    4482:	cf 93       	push	r28
    4484:	00 d0       	rcall	.+0      	; 0x4486 <vTaskResume+0x6>
    4486:	00 d0       	rcall	.+0      	; 0x4488 <vTaskResume+0x8>
    4488:	00 d0       	rcall	.+0      	; 0x448a <vTaskResume+0xa>
    448a:	cd b7       	in	r28, 0x3d	; 61
    448c:	de b7       	in	r29, 0x3e	; 62
    448e:	9c 83       	std	Y+4, r25	; 0x04
    4490:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = xTaskToResume;
    4492:	8b 81       	ldd	r24, Y+3	; 0x03
    4494:	9c 81       	ldd	r25, Y+4	; 0x04
    4496:	9a 83       	std	Y+2, r25	; 0x02
    4498:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
    449a:	20 91 a0 06 	lds	r18, 0x06A0
    449e:	30 91 a1 06 	lds	r19, 0x06A1
    44a2:	89 81       	ldd	r24, Y+1	; 0x01
    44a4:	9a 81       	ldd	r25, Y+2	; 0x02
    44a6:	82 17       	cp	r24, r18
    44a8:	93 07       	cpc	r25, r19
    44aa:	09 f4       	brne	.+2      	; 0x44ae <vTaskResume+0x2e>
    44ac:	3f c0       	rjmp	.+126    	; 0x452c <vTaskResume+0xac>
    44ae:	89 81       	ldd	r24, Y+1	; 0x01
    44b0:	9a 81       	ldd	r25, Y+2	; 0x02
    44b2:	00 97       	sbiw	r24, 0x00	; 0
    44b4:	09 f4       	brne	.+2      	; 0x44b8 <vTaskResume+0x38>
    44b6:	3a c0       	rjmp	.+116    	; 0x452c <vTaskResume+0xac>
		{
			taskENTER_CRITICAL();
    44b8:	0f b6       	in	r0, 0x3f	; 63
    44ba:	f8 94       	cli
    44bc:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    44be:	89 81       	ldd	r24, Y+1	; 0x01
    44c0:	9a 81       	ldd	r25, Y+2	; 0x02
    44c2:	0e 94 11 22 	call	0x4422	; 0x4422 <prvTaskIsTaskSuspended>
    44c6:	88 23       	and	r24, r24
    44c8:	79 f1       	breq	.+94     	; 0x4528 <vTaskResume+0xa8>
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    44ca:	89 81       	ldd	r24, Y+1	; 0x01
    44cc:	9a 81       	ldd	r25, Y+2	; 0x02
    44ce:	02 96       	adiw	r24, 0x02	; 2
    44d0:	0e 94 7f 0d 	call	0x1afe	; 0x1afe <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    44d4:	e9 81       	ldd	r30, Y+1	; 0x01
    44d6:	fa 81       	ldd	r31, Y+2	; 0x02
    44d8:	96 89       	ldd	r25, Z+22	; 0x16
    44da:	80 91 a6 06 	lds	r24, 0x06A6
    44de:	89 17       	cp	r24, r25
    44e0:	28 f4       	brcc	.+10     	; 0x44ec <vTaskResume+0x6c>
    44e2:	e9 81       	ldd	r30, Y+1	; 0x01
    44e4:	fa 81       	ldd	r31, Y+2	; 0x02
    44e6:	86 89       	ldd	r24, Z+22	; 0x16
    44e8:	80 93 a6 06 	sts	0x06A6, r24
    44ec:	e9 81       	ldd	r30, Y+1	; 0x01
    44ee:	fa 81       	ldd	r31, Y+2	; 0x02
    44f0:	86 89       	ldd	r24, Z+22	; 0x16
    44f2:	28 2f       	mov	r18, r24
    44f4:	30 e0       	ldi	r19, 0x00	; 0
    44f6:	c9 01       	movw	r24, r18
    44f8:	88 0f       	add	r24, r24
    44fa:	99 1f       	adc	r25, r25
    44fc:	88 0f       	add	r24, r24
    44fe:	99 1f       	adc	r25, r25
    4500:	88 0f       	add	r24, r24
    4502:	99 1f       	adc	r25, r25
    4504:	82 0f       	add	r24, r18
    4506:	93 1f       	adc	r25, r19
    4508:	ac 01       	movw	r20, r24
    450a:	4f 54       	subi	r20, 0x4F	; 79
    450c:	59 4f       	sbci	r21, 0xF9	; 249
    450e:	89 81       	ldd	r24, Y+1	; 0x01
    4510:	9a 81       	ldd	r25, Y+2	; 0x02
    4512:	9c 01       	movw	r18, r24
    4514:	2e 5f       	subi	r18, 0xFE	; 254
    4516:	3f 4f       	sbci	r19, 0xFF	; 255
    4518:	ca 01       	movw	r24, r20
    451a:	b9 01       	movw	r22, r18
    451c:	0e 94 cf 0c 	call	0x199e	; 0x199e <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4520:	80 91 a0 06 	lds	r24, 0x06A0
    4524:	90 91 a1 06 	lds	r25, 0x06A1
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    4528:	0f 90       	pop	r0
    452a:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    452c:	26 96       	adiw	r28, 0x06	; 6
    452e:	0f b6       	in	r0, 0x3f	; 63
    4530:	f8 94       	cli
    4532:	de bf       	out	0x3e, r29	; 62
    4534:	0f be       	out	0x3f, r0	; 63
    4536:	cd bf       	out	0x3d, r28	; 61
    4538:	cf 91       	pop	r28
    453a:	df 91       	pop	r29
    453c:	08 95       	ret

0000453e <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    453e:	df 93       	push	r29
    4540:	cf 93       	push	r28
    4542:	00 d0       	rcall	.+0      	; 0x4544 <xTaskResumeFromISR+0x6>
    4544:	00 d0       	rcall	.+0      	; 0x4546 <xTaskResumeFromISR+0x8>
    4546:	00 d0       	rcall	.+0      	; 0x4548 <xTaskResumeFromISR+0xa>
    4548:	cd b7       	in	r28, 0x3d	; 61
    454a:	de b7       	in	r29, 0x3e	; 62
    454c:	9e 83       	std	Y+6, r25	; 0x06
    454e:	8d 83       	std	Y+5, r24	; 0x05
	BaseType_t xYieldRequired = pdFALSE;
    4550:	1c 82       	std	Y+4, r1	; 0x04
	TCB_t * const pxTCB = xTaskToResume;
    4552:	8d 81       	ldd	r24, Y+5	; 0x05
    4554:	9e 81       	ldd	r25, Y+6	; 0x06
    4556:	9b 83       	std	Y+3, r25	; 0x03
    4558:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    455a:	19 82       	std	Y+1, r1	; 0x01
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    455c:	8a 81       	ldd	r24, Y+2	; 0x02
    455e:	9b 81       	ldd	r25, Y+3	; 0x03
    4560:	0e 94 11 22 	call	0x4422	; 0x4422 <prvTaskIsTaskSuspended>
    4564:	88 23       	and	r24, r24
    4566:	09 f4       	brne	.+2      	; 0x456a <xTaskResumeFromISR+0x2c>
    4568:	46 c0       	rjmp	.+140    	; 0x45f6 <xTaskResumeFromISR+0xb8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    456a:	80 91 b0 06 	lds	r24, 0x06B0
    456e:	88 23       	and	r24, r24
    4570:	c1 f5       	brne	.+112    	; 0x45e2 <xTaskResumeFromISR+0xa4>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4572:	ea 81       	ldd	r30, Y+2	; 0x02
    4574:	fb 81       	ldd	r31, Y+3	; 0x03
    4576:	96 89       	ldd	r25, Z+22	; 0x16
    4578:	e0 91 a0 06 	lds	r30, 0x06A0
    457c:	f0 91 a1 06 	lds	r31, 0x06A1
    4580:	86 89       	ldd	r24, Z+22	; 0x16
    4582:	98 17       	cp	r25, r24
    4584:	10 f0       	brcs	.+4      	; 0x458a <xTaskResumeFromISR+0x4c>
					{
						xYieldRequired = pdTRUE;
    4586:	81 e0       	ldi	r24, 0x01	; 1
    4588:	8c 83       	std	Y+4, r24	; 0x04
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    458a:	8a 81       	ldd	r24, Y+2	; 0x02
    458c:	9b 81       	ldd	r25, Y+3	; 0x03
    458e:	02 96       	adiw	r24, 0x02	; 2
    4590:	0e 94 7f 0d 	call	0x1afe	; 0x1afe <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4594:	ea 81       	ldd	r30, Y+2	; 0x02
    4596:	fb 81       	ldd	r31, Y+3	; 0x03
    4598:	96 89       	ldd	r25, Z+22	; 0x16
    459a:	80 91 a6 06 	lds	r24, 0x06A6
    459e:	89 17       	cp	r24, r25
    45a0:	28 f4       	brcc	.+10     	; 0x45ac <xTaskResumeFromISR+0x6e>
    45a2:	ea 81       	ldd	r30, Y+2	; 0x02
    45a4:	fb 81       	ldd	r31, Y+3	; 0x03
    45a6:	86 89       	ldd	r24, Z+22	; 0x16
    45a8:	80 93 a6 06 	sts	0x06A6, r24
    45ac:	ea 81       	ldd	r30, Y+2	; 0x02
    45ae:	fb 81       	ldd	r31, Y+3	; 0x03
    45b0:	86 89       	ldd	r24, Z+22	; 0x16
    45b2:	28 2f       	mov	r18, r24
    45b4:	30 e0       	ldi	r19, 0x00	; 0
    45b6:	c9 01       	movw	r24, r18
    45b8:	88 0f       	add	r24, r24
    45ba:	99 1f       	adc	r25, r25
    45bc:	88 0f       	add	r24, r24
    45be:	99 1f       	adc	r25, r25
    45c0:	88 0f       	add	r24, r24
    45c2:	99 1f       	adc	r25, r25
    45c4:	82 0f       	add	r24, r18
    45c6:	93 1f       	adc	r25, r19
    45c8:	ac 01       	movw	r20, r24
    45ca:	4f 54       	subi	r20, 0x4F	; 79
    45cc:	59 4f       	sbci	r21, 0xF9	; 249
    45ce:	8a 81       	ldd	r24, Y+2	; 0x02
    45d0:	9b 81       	ldd	r25, Y+3	; 0x03
    45d2:	9c 01       	movw	r18, r24
    45d4:	2e 5f       	subi	r18, 0xFE	; 254
    45d6:	3f 4f       	sbci	r19, 0xFF	; 255
    45d8:	ca 01       	movw	r24, r20
    45da:	b9 01       	movw	r22, r18
    45dc:	0e 94 cf 0c 	call	0x199e	; 0x199e <vListInsertEnd>
    45e0:	0a c0       	rjmp	.+20     	; 0x45f6 <xTaskResumeFromISR+0xb8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    45e2:	8a 81       	ldd	r24, Y+2	; 0x02
    45e4:	9b 81       	ldd	r25, Y+3	; 0x03
    45e6:	9c 01       	movw	r18, r24
    45e8:	24 5f       	subi	r18, 0xF4	; 244
    45ea:	3f 4f       	sbci	r19, 0xFF	; 255
    45ec:	8b ee       	ldi	r24, 0xEB	; 235
    45ee:	96 e0       	ldi	r25, 0x06	; 6
    45f0:	b9 01       	movw	r22, r18
    45f2:	0e 94 cf 0c 	call	0x199e	; 0x199e <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    45f6:	8c 81       	ldd	r24, Y+4	; 0x04
	}
    45f8:	26 96       	adiw	r28, 0x06	; 6
    45fa:	0f b6       	in	r0, 0x3f	; 63
    45fc:	f8 94       	cli
    45fe:	de bf       	out	0x3e, r29	; 62
    4600:	0f be       	out	0x3f, r0	; 63
    4602:	cd bf       	out	0x3d, r28	; 61
    4604:	cf 91       	pop	r28
    4606:	df 91       	pop	r29
    4608:	08 95       	ret

0000460a <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    460a:	ef 92       	push	r14
    460c:	ff 92       	push	r15
    460e:	0f 93       	push	r16
    4610:	df 93       	push	r29
    4612:	cf 93       	push	r28
    4614:	0f 92       	push	r0
    4616:	cd b7       	in	r28, 0x3d	; 61
    4618:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    461a:	89 e2       	ldi	r24, 0x29	; 41
    461c:	97 e2       	ldi	r25, 0x27	; 39
    461e:	20 e6       	ldi	r18, 0x60	; 96
    4620:	30 e0       	ldi	r19, 0x00	; 0
    4622:	ee ea       	ldi	r30, 0xAE	; 174
    4624:	f6 e0       	ldi	r31, 0x06	; 6
    4626:	b9 01       	movw	r22, r18
    4628:	45 e5       	ldi	r20, 0x55	; 85
    462a:	50 e0       	ldi	r21, 0x00	; 0
    462c:	20 e0       	ldi	r18, 0x00	; 0
    462e:	30 e0       	ldi	r19, 0x00	; 0
    4630:	00 e0       	ldi	r16, 0x00	; 0
    4632:	7f 01       	movw	r14, r30
    4634:	0e 94 62 1f 	call	0x3ec4	; 0x3ec4 <xTaskCreate>
    4638:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    463a:	89 81       	ldd	r24, Y+1	; 0x01
    463c:	81 30       	cpi	r24, 0x01	; 1
    463e:	81 f4       	brne	.+32     	; 0x4660 <vTaskStartScheduler+0x56>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    4640:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    4642:	8f ef       	ldi	r24, 0xFF	; 255
    4644:	9f ef       	ldi	r25, 0xFF	; 255
    4646:	90 93 ad 06 	sts	0x06AD, r25
    464a:	80 93 ac 06 	sts	0x06AC, r24
		xSchedulerRunning = pdTRUE;
    464e:	81 e0       	ldi	r24, 0x01	; 1
    4650:	80 93 a7 06 	sts	0x06A7, r24
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    4654:	10 92 a5 06 	sts	0x06A5, r1
    4658:	10 92 a4 06 	sts	0x06A4, r1

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    465c:	0e 94 4e 0f 	call	0x1e9c	; 0x1e9c <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    4660:	0f 90       	pop	r0
    4662:	cf 91       	pop	r28
    4664:	df 91       	pop	r29
    4666:	0f 91       	pop	r16
    4668:	ff 90       	pop	r15
    466a:	ef 90       	pop	r14
    466c:	08 95       	ret

0000466e <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    466e:	df 93       	push	r29
    4670:	cf 93       	push	r28
    4672:	cd b7       	in	r28, 0x3d	; 61
    4674:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    4676:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    4678:	10 92 a7 06 	sts	0x06A7, r1
	vPortEndScheduler();
    467c:	0e 94 83 0f 	call	0x1f06	; 0x1f06 <vPortEndScheduler>
}
    4680:	cf 91       	pop	r28
    4682:	df 91       	pop	r29
    4684:	08 95       	ret

00004686 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    4686:	df 93       	push	r29
    4688:	cf 93       	push	r28
    468a:	cd b7       	in	r28, 0x3d	; 61
    468c:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    468e:	80 91 b0 06 	lds	r24, 0x06B0
    4692:	8f 5f       	subi	r24, 0xFF	; 255
    4694:	80 93 b0 06 	sts	0x06B0, r24
}
    4698:	cf 91       	pop	r28
    469a:	df 91       	pop	r29
    469c:	08 95       	ret

0000469e <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    469e:	df 93       	push	r29
    46a0:	cf 93       	push	r28
    46a2:	00 d0       	rcall	.+0      	; 0x46a4 <xTaskResumeAll+0x6>
    46a4:	00 d0       	rcall	.+0      	; 0x46a6 <xTaskResumeAll+0x8>
    46a6:	0f 92       	push	r0
    46a8:	cd b7       	in	r28, 0x3d	; 61
    46aa:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    46ac:	1c 82       	std	Y+4, r1	; 0x04
    46ae:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xAlreadyYielded = pdFALSE;
    46b0:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    46b2:	0f b6       	in	r0, 0x3f	; 63
    46b4:	f8 94       	cli
    46b6:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    46b8:	80 91 b0 06 	lds	r24, 0x06B0
    46bc:	81 50       	subi	r24, 0x01	; 1
    46be:	80 93 b0 06 	sts	0x06B0, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    46c2:	80 91 b0 06 	lds	r24, 0x06B0
    46c6:	88 23       	and	r24, r24
    46c8:	09 f0       	breq	.+2      	; 0x46cc <xTaskResumeAll+0x2e>
    46ca:	6d c0       	rjmp	.+218    	; 0x47a6 <xTaskResumeAll+0x108>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    46cc:	80 91 a3 06 	lds	r24, 0x06A3
    46d0:	88 23       	and	r24, r24
    46d2:	09 f4       	brne	.+2      	; 0x46d6 <xTaskResumeAll+0x38>
    46d4:	68 c0       	rjmp	.+208    	; 0x47a6 <xTaskResumeAll+0x108>
    46d6:	45 c0       	rjmp	.+138    	; 0x4762 <xTaskResumeAll+0xc4>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    46d8:	e0 91 f0 06 	lds	r30, 0x06F0
    46dc:	f0 91 f1 06 	lds	r31, 0x06F1
    46e0:	86 81       	ldd	r24, Z+6	; 0x06
    46e2:	97 81       	ldd	r25, Z+7	; 0x07
    46e4:	9c 83       	std	Y+4, r25	; 0x04
    46e6:	8b 83       	std	Y+3, r24	; 0x03
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    46e8:	8b 81       	ldd	r24, Y+3	; 0x03
    46ea:	9c 81       	ldd	r25, Y+4	; 0x04
    46ec:	0c 96       	adiw	r24, 0x0c	; 12
    46ee:	0e 94 7f 0d 	call	0x1afe	; 0x1afe <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    46f2:	8b 81       	ldd	r24, Y+3	; 0x03
    46f4:	9c 81       	ldd	r25, Y+4	; 0x04
    46f6:	02 96       	adiw	r24, 0x02	; 2
    46f8:	0e 94 7f 0d 	call	0x1afe	; 0x1afe <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    46fc:	eb 81       	ldd	r30, Y+3	; 0x03
    46fe:	fc 81       	ldd	r31, Y+4	; 0x04
    4700:	96 89       	ldd	r25, Z+22	; 0x16
    4702:	80 91 a6 06 	lds	r24, 0x06A6
    4706:	89 17       	cp	r24, r25
    4708:	28 f4       	brcc	.+10     	; 0x4714 <xTaskResumeAll+0x76>
    470a:	eb 81       	ldd	r30, Y+3	; 0x03
    470c:	fc 81       	ldd	r31, Y+4	; 0x04
    470e:	86 89       	ldd	r24, Z+22	; 0x16
    4710:	80 93 a6 06 	sts	0x06A6, r24
    4714:	eb 81       	ldd	r30, Y+3	; 0x03
    4716:	fc 81       	ldd	r31, Y+4	; 0x04
    4718:	86 89       	ldd	r24, Z+22	; 0x16
    471a:	28 2f       	mov	r18, r24
    471c:	30 e0       	ldi	r19, 0x00	; 0
    471e:	c9 01       	movw	r24, r18
    4720:	88 0f       	add	r24, r24
    4722:	99 1f       	adc	r25, r25
    4724:	88 0f       	add	r24, r24
    4726:	99 1f       	adc	r25, r25
    4728:	88 0f       	add	r24, r24
    472a:	99 1f       	adc	r25, r25
    472c:	82 0f       	add	r24, r18
    472e:	93 1f       	adc	r25, r19
    4730:	ac 01       	movw	r20, r24
    4732:	4f 54       	subi	r20, 0x4F	; 79
    4734:	59 4f       	sbci	r21, 0xF9	; 249
    4736:	8b 81       	ldd	r24, Y+3	; 0x03
    4738:	9c 81       	ldd	r25, Y+4	; 0x04
    473a:	9c 01       	movw	r18, r24
    473c:	2e 5f       	subi	r18, 0xFE	; 254
    473e:	3f 4f       	sbci	r19, 0xFF	; 255
    4740:	ca 01       	movw	r24, r20
    4742:	b9 01       	movw	r22, r18
    4744:	0e 94 cf 0c 	call	0x199e	; 0x199e <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4748:	eb 81       	ldd	r30, Y+3	; 0x03
    474a:	fc 81       	ldd	r31, Y+4	; 0x04
    474c:	96 89       	ldd	r25, Z+22	; 0x16
    474e:	e0 91 a0 06 	lds	r30, 0x06A0
    4752:	f0 91 a1 06 	lds	r31, 0x06A1
    4756:	86 89       	ldd	r24, Z+22	; 0x16
    4758:	98 17       	cp	r25, r24
    475a:	18 f0       	brcs	.+6      	; 0x4762 <xTaskResumeAll+0xc4>
					{
						xYieldPending = pdTRUE;
    475c:	81 e0       	ldi	r24, 0x01	; 1
    475e:	80 93 a9 06 	sts	0x06A9, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    4762:	80 91 eb 06 	lds	r24, 0x06EB
    4766:	88 23       	and	r24, r24
    4768:	09 f0       	breq	.+2      	; 0x476c <xTaskResumeAll+0xce>
    476a:	b6 cf       	rjmp	.-148    	; 0x46d8 <xTaskResumeAll+0x3a>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    476c:	8b 81       	ldd	r24, Y+3	; 0x03
    476e:	9c 81       	ldd	r25, Y+4	; 0x04
    4770:	00 97       	sbiw	r24, 0x00	; 0
    4772:	11 f0       	breq	.+4      	; 0x4778 <xTaskResumeAll+0xda>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    4774:	0e 94 bb 27 	call	0x4f76	; 0x4f76 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    4778:	80 91 a8 06 	lds	r24, 0x06A8
    477c:	89 83       	std	Y+1, r24	; 0x01

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    477e:	89 81       	ldd	r24, Y+1	; 0x01
    4780:	88 23       	and	r24, r24
    4782:	79 f0       	breq	.+30     	; 0x47a2 <xTaskResumeAll+0x104>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    4784:	0e 94 3b 24 	call	0x4876	; 0x4876 <xTaskIncrementTick>
    4788:	88 23       	and	r24, r24
    478a:	19 f0       	breq	.+6      	; 0x4792 <xTaskResumeAll+0xf4>
							{
								xYieldPending = pdTRUE;
    478c:	81 e0       	ldi	r24, 0x01	; 1
    478e:	80 93 a9 06 	sts	0x06A9, r24
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    4792:	89 81       	ldd	r24, Y+1	; 0x01
    4794:	81 50       	subi	r24, 0x01	; 1
    4796:	89 83       	std	Y+1, r24	; 0x01
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    4798:	89 81       	ldd	r24, Y+1	; 0x01
    479a:	88 23       	and	r24, r24
    479c:	99 f7       	brne	.-26     	; 0x4784 <xTaskResumeAll+0xe6>

						uxPendedTicks = 0;
    479e:	10 92 a8 06 	sts	0x06A8, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    47a2:	80 91 a9 06 	lds	r24, 0x06A9
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    47a6:	0f 90       	pop	r0
    47a8:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    47aa:	8a 81       	ldd	r24, Y+2	; 0x02
}
    47ac:	0f 90       	pop	r0
    47ae:	0f 90       	pop	r0
    47b0:	0f 90       	pop	r0
    47b2:	0f 90       	pop	r0
    47b4:	0f 90       	pop	r0
    47b6:	cf 91       	pop	r28
    47b8:	df 91       	pop	r29
    47ba:	08 95       	ret

000047bc <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    47bc:	df 93       	push	r29
    47be:	cf 93       	push	r28
    47c0:	00 d0       	rcall	.+0      	; 0x47c2 <xTaskGetTickCount+0x6>
    47c2:	cd b7       	in	r28, 0x3d	; 61
    47c4:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    47c6:	0f b6       	in	r0, 0x3f	; 63
    47c8:	f8 94       	cli
    47ca:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    47cc:	80 91 a4 06 	lds	r24, 0x06A4
    47d0:	90 91 a5 06 	lds	r25, 0x06A5
    47d4:	9a 83       	std	Y+2, r25	; 0x02
    47d6:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    47d8:	0f 90       	pop	r0
    47da:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    47dc:	89 81       	ldd	r24, Y+1	; 0x01
    47de:	9a 81       	ldd	r25, Y+2	; 0x02
}
    47e0:	0f 90       	pop	r0
    47e2:	0f 90       	pop	r0
    47e4:	cf 91       	pop	r28
    47e6:	df 91       	pop	r29
    47e8:	08 95       	ret

000047ea <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    47ea:	df 93       	push	r29
    47ec:	cf 93       	push	r28
    47ee:	00 d0       	rcall	.+0      	; 0x47f0 <xTaskGetTickCountFromISR+0x6>
    47f0:	0f 92       	push	r0
    47f2:	cd b7       	in	r28, 0x3d	; 61
    47f4:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    47f6:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    47f8:	80 91 a4 06 	lds	r24, 0x06A4
    47fc:	90 91 a5 06 	lds	r25, 0x06A5
    4800:	9b 83       	std	Y+3, r25	; 0x03
    4802:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4804:	8a 81       	ldd	r24, Y+2	; 0x02
    4806:	9b 81       	ldd	r25, Y+3	; 0x03
}
    4808:	0f 90       	pop	r0
    480a:	0f 90       	pop	r0
    480c:	0f 90       	pop	r0
    480e:	cf 91       	pop	r28
    4810:	df 91       	pop	r29
    4812:	08 95       	ret

00004814 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    4814:	df 93       	push	r29
    4816:	cf 93       	push	r28
    4818:	cd b7       	in	r28, 0x3d	; 61
    481a:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    481c:	80 91 a3 06 	lds	r24, 0x06A3
}
    4820:	cf 91       	pop	r28
    4822:	df 91       	pop	r29
    4824:	08 95       	ret

00004826 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    4826:	df 93       	push	r29
    4828:	cf 93       	push	r28
    482a:	00 d0       	rcall	.+0      	; 0x482c <pcTaskGetName+0x6>
    482c:	00 d0       	rcall	.+0      	; 0x482e <pcTaskGetName+0x8>
    482e:	00 d0       	rcall	.+0      	; 0x4830 <pcTaskGetName+0xa>
    4830:	cd b7       	in	r28, 0x3d	; 61
    4832:	de b7       	in	r29, 0x3e	; 62
    4834:	9c 83       	std	Y+4, r25	; 0x04
    4836:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    4838:	8b 81       	ldd	r24, Y+3	; 0x03
    483a:	9c 81       	ldd	r25, Y+4	; 0x04
    483c:	00 97       	sbiw	r24, 0x00	; 0
    483e:	39 f4       	brne	.+14     	; 0x484e <pcTaskGetName+0x28>
    4840:	80 91 a0 06 	lds	r24, 0x06A0
    4844:	90 91 a1 06 	lds	r25, 0x06A1
    4848:	9e 83       	std	Y+6, r25	; 0x06
    484a:	8d 83       	std	Y+5, r24	; 0x05
    484c:	04 c0       	rjmp	.+8      	; 0x4856 <pcTaskGetName+0x30>
    484e:	8b 81       	ldd	r24, Y+3	; 0x03
    4850:	9c 81       	ldd	r25, Y+4	; 0x04
    4852:	9e 83       	std	Y+6, r25	; 0x06
    4854:	8d 83       	std	Y+5, r24	; 0x05
    4856:	8d 81       	ldd	r24, Y+5	; 0x05
    4858:	9e 81       	ldd	r25, Y+6	; 0x06
    485a:	9a 83       	std	Y+2, r25	; 0x02
    485c:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    485e:	89 81       	ldd	r24, Y+1	; 0x01
    4860:	9a 81       	ldd	r25, Y+2	; 0x02
    4862:	49 96       	adiw	r24, 0x19	; 25
}
    4864:	26 96       	adiw	r28, 0x06	; 6
    4866:	0f b6       	in	r0, 0x3f	; 63
    4868:	f8 94       	cli
    486a:	de bf       	out	0x3e, r29	; 62
    486c:	0f be       	out	0x3f, r0	; 63
    486e:	cd bf       	out	0x3d, r28	; 61
    4870:	cf 91       	pop	r28
    4872:	df 91       	pop	r29
    4874:	08 95       	ret

00004876 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    4876:	df 93       	push	r29
    4878:	cf 93       	push	r28
    487a:	cd b7       	in	r28, 0x3d	; 61
    487c:	de b7       	in	r29, 0x3e	; 62
    487e:	29 97       	sbiw	r28, 0x09	; 9
    4880:	0f b6       	in	r0, 0x3f	; 63
    4882:	f8 94       	cli
    4884:	de bf       	out	0x3e, r29	; 62
    4886:	0f be       	out	0x3f, r0	; 63
    4888:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    488a:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    488c:	80 91 b0 06 	lds	r24, 0x06B0
    4890:	88 23       	and	r24, r24
    4892:	09 f0       	breq	.+2      	; 0x4896 <xTaskIncrementTick+0x20>
    4894:	9a c0       	rjmp	.+308    	; 0x49ca <xTaskIncrementTick+0x154>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    4896:	80 91 a4 06 	lds	r24, 0x06A4
    489a:	90 91 a5 06 	lds	r25, 0x06A5
    489e:	01 96       	adiw	r24, 0x01	; 1
    48a0:	9c 83       	std	Y+4, r25	; 0x04
    48a2:	8b 83       	std	Y+3, r24	; 0x03

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    48a4:	8b 81       	ldd	r24, Y+3	; 0x03
    48a6:	9c 81       	ldd	r25, Y+4	; 0x04
    48a8:	90 93 a5 06 	sts	0x06A5, r25
    48ac:	80 93 a4 06 	sts	0x06A4, r24

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    48b0:	8b 81       	ldd	r24, Y+3	; 0x03
    48b2:	9c 81       	ldd	r25, Y+4	; 0x04
    48b4:	00 97       	sbiw	r24, 0x00	; 0
    48b6:	d9 f4       	brne	.+54     	; 0x48ee <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    48b8:	80 91 e7 06 	lds	r24, 0x06E7
    48bc:	90 91 e8 06 	lds	r25, 0x06E8
    48c0:	9a 83       	std	Y+2, r25	; 0x02
    48c2:	89 83       	std	Y+1, r24	; 0x01
    48c4:	80 91 e9 06 	lds	r24, 0x06E9
    48c8:	90 91 ea 06 	lds	r25, 0x06EA
    48cc:	90 93 e8 06 	sts	0x06E8, r25
    48d0:	80 93 e7 06 	sts	0x06E7, r24
    48d4:	89 81       	ldd	r24, Y+1	; 0x01
    48d6:	9a 81       	ldd	r25, Y+2	; 0x02
    48d8:	90 93 ea 06 	sts	0x06EA, r25
    48dc:	80 93 e9 06 	sts	0x06E9, r24
    48e0:	80 91 aa 06 	lds	r24, 0x06AA
    48e4:	8f 5f       	subi	r24, 0xFF	; 255
    48e6:	80 93 aa 06 	sts	0x06AA, r24
    48ea:	0e 94 bb 27 	call	0x4f76	; 0x4f76 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    48ee:	20 91 ac 06 	lds	r18, 0x06AC
    48f2:	30 91 ad 06 	lds	r19, 0x06AD
    48f6:	8b 81       	ldd	r24, Y+3	; 0x03
    48f8:	9c 81       	ldd	r25, Y+4	; 0x04
    48fa:	82 17       	cp	r24, r18
    48fc:	93 07       	cpc	r25, r19
    48fe:	08 f4       	brcc	.+2      	; 0x4902 <xTaskIncrementTick+0x8c>
    4900:	69 c0       	rjmp	.+210    	; 0x49d4 <xTaskIncrementTick+0x15e>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4902:	e0 91 e7 06 	lds	r30, 0x06E7
    4906:	f0 91 e8 06 	lds	r31, 0x06E8
    490a:	80 81       	ld	r24, Z
    490c:	88 23       	and	r24, r24
    490e:	39 f4       	brne	.+14     	; 0x491e <xTaskIncrementTick+0xa8>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4910:	8f ef       	ldi	r24, 0xFF	; 255
    4912:	9f ef       	ldi	r25, 0xFF	; 255
    4914:	90 93 ad 06 	sts	0x06AD, r25
    4918:	80 93 ac 06 	sts	0x06AC, r24
    491c:	5b c0       	rjmp	.+182    	; 0x49d4 <xTaskIncrementTick+0x15e>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    491e:	e0 91 e7 06 	lds	r30, 0x06E7
    4922:	f0 91 e8 06 	lds	r31, 0x06E8
    4926:	05 80       	ldd	r0, Z+5	; 0x05
    4928:	f6 81       	ldd	r31, Z+6	; 0x06
    492a:	e0 2d       	mov	r30, r0
    492c:	86 81       	ldd	r24, Z+6	; 0x06
    492e:	97 81       	ldd	r25, Z+7	; 0x07
    4930:	99 87       	std	Y+9, r25	; 0x09
    4932:	88 87       	std	Y+8, r24	; 0x08
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    4934:	e8 85       	ldd	r30, Y+8	; 0x08
    4936:	f9 85       	ldd	r31, Y+9	; 0x09
    4938:	82 81       	ldd	r24, Z+2	; 0x02
    493a:	93 81       	ldd	r25, Z+3	; 0x03
    493c:	9f 83       	std	Y+7, r25	; 0x07
    493e:	8e 83       	std	Y+6, r24	; 0x06

					if( xConstTickCount < xItemValue )
    4940:	2b 81       	ldd	r18, Y+3	; 0x03
    4942:	3c 81       	ldd	r19, Y+4	; 0x04
    4944:	8e 81       	ldd	r24, Y+6	; 0x06
    4946:	9f 81       	ldd	r25, Y+7	; 0x07
    4948:	28 17       	cp	r18, r24
    494a:	39 07       	cpc	r19, r25
    494c:	38 f4       	brcc	.+14     	; 0x495c <xTaskIncrementTick+0xe6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    494e:	8e 81       	ldd	r24, Y+6	; 0x06
    4950:	9f 81       	ldd	r25, Y+7	; 0x07
    4952:	90 93 ad 06 	sts	0x06AD, r25
    4956:	80 93 ac 06 	sts	0x06AC, r24
    495a:	3c c0       	rjmp	.+120    	; 0x49d4 <xTaskIncrementTick+0x15e>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    495c:	88 85       	ldd	r24, Y+8	; 0x08
    495e:	99 85       	ldd	r25, Y+9	; 0x09
    4960:	02 96       	adiw	r24, 0x02	; 2
    4962:	0e 94 7f 0d 	call	0x1afe	; 0x1afe <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    4966:	e8 85       	ldd	r30, Y+8	; 0x08
    4968:	f9 85       	ldd	r31, Y+9	; 0x09
    496a:	84 89       	ldd	r24, Z+20	; 0x14
    496c:	95 89       	ldd	r25, Z+21	; 0x15
    496e:	00 97       	sbiw	r24, 0x00	; 0
    4970:	29 f0       	breq	.+10     	; 0x497c <xTaskIncrementTick+0x106>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4972:	88 85       	ldd	r24, Y+8	; 0x08
    4974:	99 85       	ldd	r25, Y+9	; 0x09
    4976:	0c 96       	adiw	r24, 0x0c	; 12
    4978:	0e 94 7f 0d 	call	0x1afe	; 0x1afe <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    497c:	e8 85       	ldd	r30, Y+8	; 0x08
    497e:	f9 85       	ldd	r31, Y+9	; 0x09
    4980:	96 89       	ldd	r25, Z+22	; 0x16
    4982:	80 91 a6 06 	lds	r24, 0x06A6
    4986:	89 17       	cp	r24, r25
    4988:	28 f4       	brcc	.+10     	; 0x4994 <xTaskIncrementTick+0x11e>
    498a:	e8 85       	ldd	r30, Y+8	; 0x08
    498c:	f9 85       	ldd	r31, Y+9	; 0x09
    498e:	86 89       	ldd	r24, Z+22	; 0x16
    4990:	80 93 a6 06 	sts	0x06A6, r24
    4994:	e8 85       	ldd	r30, Y+8	; 0x08
    4996:	f9 85       	ldd	r31, Y+9	; 0x09
    4998:	86 89       	ldd	r24, Z+22	; 0x16
    499a:	28 2f       	mov	r18, r24
    499c:	30 e0       	ldi	r19, 0x00	; 0
    499e:	c9 01       	movw	r24, r18
    49a0:	88 0f       	add	r24, r24
    49a2:	99 1f       	adc	r25, r25
    49a4:	88 0f       	add	r24, r24
    49a6:	99 1f       	adc	r25, r25
    49a8:	88 0f       	add	r24, r24
    49aa:	99 1f       	adc	r25, r25
    49ac:	82 0f       	add	r24, r18
    49ae:	93 1f       	adc	r25, r19
    49b0:	ac 01       	movw	r20, r24
    49b2:	4f 54       	subi	r20, 0x4F	; 79
    49b4:	59 4f       	sbci	r21, 0xF9	; 249
    49b6:	88 85       	ldd	r24, Y+8	; 0x08
    49b8:	99 85       	ldd	r25, Y+9	; 0x09
    49ba:	9c 01       	movw	r18, r24
    49bc:	2e 5f       	subi	r18, 0xFE	; 254
    49be:	3f 4f       	sbci	r19, 0xFF	; 255
    49c0:	ca 01       	movw	r24, r20
    49c2:	b9 01       	movw	r22, r18
    49c4:	0e 94 cf 0c 	call	0x199e	; 0x199e <vListInsertEnd>
    49c8:	9c cf       	rjmp	.-200    	; 0x4902 <xTaskIncrementTick+0x8c>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    49ca:	80 91 a8 06 	lds	r24, 0x06A8
    49ce:	8f 5f       	subi	r24, 0xFF	; 255
    49d0:	80 93 a8 06 	sts	0x06A8, r24
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    49d4:	8d 81       	ldd	r24, Y+5	; 0x05
}
    49d6:	29 96       	adiw	r28, 0x09	; 9
    49d8:	0f b6       	in	r0, 0x3f	; 63
    49da:	f8 94       	cli
    49dc:	de bf       	out	0x3e, r29	; 62
    49de:	0f be       	out	0x3f, r0	; 63
    49e0:	cd bf       	out	0x3d, r28	; 61
    49e2:	cf 91       	pop	r28
    49e4:	df 91       	pop	r29
    49e6:	08 95       	ret

000049e8 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    49e8:	df 93       	push	r29
    49ea:	cf 93       	push	r28
    49ec:	00 d0       	rcall	.+0      	; 0x49ee <vTaskSwitchContext+0x6>
    49ee:	0f 92       	push	r0
    49f0:	cd b7       	in	r28, 0x3d	; 61
    49f2:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    49f4:	80 91 b0 06 	lds	r24, 0x06B0
    49f8:	88 23       	and	r24, r24
    49fa:	21 f0       	breq	.+8      	; 0x4a04 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    49fc:	81 e0       	ldi	r24, 0x01	; 1
    49fe:	80 93 a9 06 	sts	0x06A9, r24
    4a02:	59 c0       	rjmp	.+178    	; 0x4ab6 <vTaskSwitchContext+0xce>
	}
	else
	{
		xYieldPending = pdFALSE;
    4a04:	10 92 a9 06 	sts	0x06A9, r1
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4a08:	80 91 a6 06 	lds	r24, 0x06A6
    4a0c:	8b 83       	std	Y+3, r24	; 0x03
    4a0e:	03 c0       	rjmp	.+6      	; 0x4a16 <vTaskSwitchContext+0x2e>
    4a10:	8b 81       	ldd	r24, Y+3	; 0x03
    4a12:	81 50       	subi	r24, 0x01	; 1
    4a14:	8b 83       	std	Y+3, r24	; 0x03
    4a16:	8b 81       	ldd	r24, Y+3	; 0x03
    4a18:	28 2f       	mov	r18, r24
    4a1a:	30 e0       	ldi	r19, 0x00	; 0
    4a1c:	c9 01       	movw	r24, r18
    4a1e:	88 0f       	add	r24, r24
    4a20:	99 1f       	adc	r25, r25
    4a22:	88 0f       	add	r24, r24
    4a24:	99 1f       	adc	r25, r25
    4a26:	88 0f       	add	r24, r24
    4a28:	99 1f       	adc	r25, r25
    4a2a:	82 0f       	add	r24, r18
    4a2c:	93 1f       	adc	r25, r19
    4a2e:	fc 01       	movw	r30, r24
    4a30:	ef 54       	subi	r30, 0x4F	; 79
    4a32:	f9 4f       	sbci	r31, 0xF9	; 249
    4a34:	80 81       	ld	r24, Z
    4a36:	88 23       	and	r24, r24
    4a38:	59 f3       	breq	.-42     	; 0x4a10 <vTaskSwitchContext+0x28>
    4a3a:	8b 81       	ldd	r24, Y+3	; 0x03
    4a3c:	28 2f       	mov	r18, r24
    4a3e:	30 e0       	ldi	r19, 0x00	; 0
    4a40:	c9 01       	movw	r24, r18
    4a42:	88 0f       	add	r24, r24
    4a44:	99 1f       	adc	r25, r25
    4a46:	88 0f       	add	r24, r24
    4a48:	99 1f       	adc	r25, r25
    4a4a:	88 0f       	add	r24, r24
    4a4c:	99 1f       	adc	r25, r25
    4a4e:	82 0f       	add	r24, r18
    4a50:	93 1f       	adc	r25, r19
    4a52:	8f 54       	subi	r24, 0x4F	; 79
    4a54:	99 4f       	sbci	r25, 0xF9	; 249
    4a56:	9a 83       	std	Y+2, r25	; 0x02
    4a58:	89 83       	std	Y+1, r24	; 0x01
    4a5a:	e9 81       	ldd	r30, Y+1	; 0x01
    4a5c:	fa 81       	ldd	r31, Y+2	; 0x02
    4a5e:	01 80       	ldd	r0, Z+1	; 0x01
    4a60:	f2 81       	ldd	r31, Z+2	; 0x02
    4a62:	e0 2d       	mov	r30, r0
    4a64:	82 81       	ldd	r24, Z+2	; 0x02
    4a66:	93 81       	ldd	r25, Z+3	; 0x03
    4a68:	e9 81       	ldd	r30, Y+1	; 0x01
    4a6a:	fa 81       	ldd	r31, Y+2	; 0x02
    4a6c:	92 83       	std	Z+2, r25	; 0x02
    4a6e:	81 83       	std	Z+1, r24	; 0x01
    4a70:	e9 81       	ldd	r30, Y+1	; 0x01
    4a72:	fa 81       	ldd	r31, Y+2	; 0x02
    4a74:	21 81       	ldd	r18, Z+1	; 0x01
    4a76:	32 81       	ldd	r19, Z+2	; 0x02
    4a78:	89 81       	ldd	r24, Y+1	; 0x01
    4a7a:	9a 81       	ldd	r25, Y+2	; 0x02
    4a7c:	03 96       	adiw	r24, 0x03	; 3
    4a7e:	28 17       	cp	r18, r24
    4a80:	39 07       	cpc	r19, r25
    4a82:	59 f4       	brne	.+22     	; 0x4a9a <vTaskSwitchContext+0xb2>
    4a84:	e9 81       	ldd	r30, Y+1	; 0x01
    4a86:	fa 81       	ldd	r31, Y+2	; 0x02
    4a88:	01 80       	ldd	r0, Z+1	; 0x01
    4a8a:	f2 81       	ldd	r31, Z+2	; 0x02
    4a8c:	e0 2d       	mov	r30, r0
    4a8e:	82 81       	ldd	r24, Z+2	; 0x02
    4a90:	93 81       	ldd	r25, Z+3	; 0x03
    4a92:	e9 81       	ldd	r30, Y+1	; 0x01
    4a94:	fa 81       	ldd	r31, Y+2	; 0x02
    4a96:	92 83       	std	Z+2, r25	; 0x02
    4a98:	81 83       	std	Z+1, r24	; 0x01
    4a9a:	e9 81       	ldd	r30, Y+1	; 0x01
    4a9c:	fa 81       	ldd	r31, Y+2	; 0x02
    4a9e:	01 80       	ldd	r0, Z+1	; 0x01
    4aa0:	f2 81       	ldd	r31, Z+2	; 0x02
    4aa2:	e0 2d       	mov	r30, r0
    4aa4:	86 81       	ldd	r24, Z+6	; 0x06
    4aa6:	97 81       	ldd	r25, Z+7	; 0x07
    4aa8:	90 93 a1 06 	sts	0x06A1, r25
    4aac:	80 93 a0 06 	sts	0x06A0, r24
    4ab0:	8b 81       	ldd	r24, Y+3	; 0x03
    4ab2:	80 93 a6 06 	sts	0x06A6, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    4ab6:	0f 90       	pop	r0
    4ab8:	0f 90       	pop	r0
    4aba:	0f 90       	pop	r0
    4abc:	cf 91       	pop	r28
    4abe:	df 91       	pop	r29
    4ac0:	08 95       	ret

00004ac2 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    4ac2:	df 93       	push	r29
    4ac4:	cf 93       	push	r28
    4ac6:	00 d0       	rcall	.+0      	; 0x4ac8 <vTaskPlaceOnEventList+0x6>
    4ac8:	00 d0       	rcall	.+0      	; 0x4aca <vTaskPlaceOnEventList+0x8>
    4aca:	cd b7       	in	r28, 0x3d	; 61
    4acc:	de b7       	in	r29, 0x3e	; 62
    4ace:	9a 83       	std	Y+2, r25	; 0x02
    4ad0:	89 83       	std	Y+1, r24	; 0x01
    4ad2:	7c 83       	std	Y+4, r23	; 0x04
    4ad4:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    4ad6:	80 91 a0 06 	lds	r24, 0x06A0
    4ada:	90 91 a1 06 	lds	r25, 0x06A1
    4ade:	9c 01       	movw	r18, r24
    4ae0:	24 5f       	subi	r18, 0xF4	; 244
    4ae2:	3f 4f       	sbci	r19, 0xFF	; 255
    4ae4:	89 81       	ldd	r24, Y+1	; 0x01
    4ae6:	9a 81       	ldd	r25, Y+2	; 0x02
    4ae8:	b9 01       	movw	r22, r18
    4aea:	0e 94 13 0d 	call	0x1a26	; 0x1a26 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4aee:	8b 81       	ldd	r24, Y+3	; 0x03
    4af0:	9c 81       	ldd	r25, Y+4	; 0x04
    4af2:	61 e0       	ldi	r22, 0x01	; 1
    4af4:	0e 94 bf 2b 	call	0x577e	; 0x577e <prvAddCurrentTaskToDelayedList>
}
    4af8:	0f 90       	pop	r0
    4afa:	0f 90       	pop	r0
    4afc:	0f 90       	pop	r0
    4afe:	0f 90       	pop	r0
    4b00:	cf 91       	pop	r28
    4b02:	df 91       	pop	r29
    4b04:	08 95       	ret

00004b06 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    4b06:	df 93       	push	r29
    4b08:	cf 93       	push	r28
    4b0a:	00 d0       	rcall	.+0      	; 0x4b0c <vTaskPlaceOnUnorderedEventList+0x6>
    4b0c:	00 d0       	rcall	.+0      	; 0x4b0e <vTaskPlaceOnUnorderedEventList+0x8>
    4b0e:	00 d0       	rcall	.+0      	; 0x4b10 <vTaskPlaceOnUnorderedEventList+0xa>
    4b10:	cd b7       	in	r28, 0x3d	; 61
    4b12:	de b7       	in	r29, 0x3e	; 62
    4b14:	9a 83       	std	Y+2, r25	; 0x02
    4b16:	89 83       	std	Y+1, r24	; 0x01
    4b18:	7c 83       	std	Y+4, r23	; 0x04
    4b1a:	6b 83       	std	Y+3, r22	; 0x03
    4b1c:	5e 83       	std	Y+6, r21	; 0x06
    4b1e:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    4b20:	e0 91 a0 06 	lds	r30, 0x06A0
    4b24:	f0 91 a1 06 	lds	r31, 0x06A1
    4b28:	8b 81       	ldd	r24, Y+3	; 0x03
    4b2a:	9c 81       	ldd	r25, Y+4	; 0x04
    4b2c:	90 68       	ori	r25, 0x80	; 128
    4b2e:	95 87       	std	Z+13, r25	; 0x0d
    4b30:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    4b32:	80 91 a0 06 	lds	r24, 0x06A0
    4b36:	90 91 a1 06 	lds	r25, 0x06A1
    4b3a:	9c 01       	movw	r18, r24
    4b3c:	24 5f       	subi	r18, 0xF4	; 244
    4b3e:	3f 4f       	sbci	r19, 0xFF	; 255
    4b40:	89 81       	ldd	r24, Y+1	; 0x01
    4b42:	9a 81       	ldd	r25, Y+2	; 0x02
    4b44:	b9 01       	movw	r22, r18
    4b46:	0e 94 cf 0c 	call	0x199e	; 0x199e <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4b4a:	8d 81       	ldd	r24, Y+5	; 0x05
    4b4c:	9e 81       	ldd	r25, Y+6	; 0x06
    4b4e:	61 e0       	ldi	r22, 0x01	; 1
    4b50:	0e 94 bf 2b 	call	0x577e	; 0x577e <prvAddCurrentTaskToDelayedList>
}
    4b54:	26 96       	adiw	r28, 0x06	; 6
    4b56:	0f b6       	in	r0, 0x3f	; 63
    4b58:	f8 94       	cli
    4b5a:	de bf       	out	0x3e, r29	; 62
    4b5c:	0f be       	out	0x3f, r0	; 63
    4b5e:	cd bf       	out	0x3d, r28	; 61
    4b60:	cf 91       	pop	r28
    4b62:	df 91       	pop	r29
    4b64:	08 95       	ret

00004b66 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    4b66:	df 93       	push	r29
    4b68:	cf 93       	push	r28
    4b6a:	00 d0       	rcall	.+0      	; 0x4b6c <xTaskRemoveFromEventList+0x6>
    4b6c:	00 d0       	rcall	.+0      	; 0x4b6e <xTaskRemoveFromEventList+0x8>
    4b6e:	0f 92       	push	r0
    4b70:	cd b7       	in	r28, 0x3d	; 61
    4b72:	de b7       	in	r29, 0x3e	; 62
    4b74:	9d 83       	std	Y+5, r25	; 0x05
    4b76:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4b78:	ec 81       	ldd	r30, Y+4	; 0x04
    4b7a:	fd 81       	ldd	r31, Y+5	; 0x05
    4b7c:	05 80       	ldd	r0, Z+5	; 0x05
    4b7e:	f6 81       	ldd	r31, Z+6	; 0x06
    4b80:	e0 2d       	mov	r30, r0
    4b82:	86 81       	ldd	r24, Z+6	; 0x06
    4b84:	97 81       	ldd	r25, Z+7	; 0x07
    4b86:	9b 83       	std	Y+3, r25	; 0x03
    4b88:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    4b8a:	8a 81       	ldd	r24, Y+2	; 0x02
    4b8c:	9b 81       	ldd	r25, Y+3	; 0x03
    4b8e:	0c 96       	adiw	r24, 0x0c	; 12
    4b90:	0e 94 7f 0d 	call	0x1afe	; 0x1afe <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4b94:	80 91 b0 06 	lds	r24, 0x06B0
    4b98:	88 23       	and	r24, r24
    4b9a:	61 f5       	brne	.+88     	; 0x4bf4 <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    4b9c:	8a 81       	ldd	r24, Y+2	; 0x02
    4b9e:	9b 81       	ldd	r25, Y+3	; 0x03
    4ba0:	02 96       	adiw	r24, 0x02	; 2
    4ba2:	0e 94 7f 0d 	call	0x1afe	; 0x1afe <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    4ba6:	ea 81       	ldd	r30, Y+2	; 0x02
    4ba8:	fb 81       	ldd	r31, Y+3	; 0x03
    4baa:	96 89       	ldd	r25, Z+22	; 0x16
    4bac:	80 91 a6 06 	lds	r24, 0x06A6
    4bb0:	89 17       	cp	r24, r25
    4bb2:	28 f4       	brcc	.+10     	; 0x4bbe <xTaskRemoveFromEventList+0x58>
    4bb4:	ea 81       	ldd	r30, Y+2	; 0x02
    4bb6:	fb 81       	ldd	r31, Y+3	; 0x03
    4bb8:	86 89       	ldd	r24, Z+22	; 0x16
    4bba:	80 93 a6 06 	sts	0x06A6, r24
    4bbe:	ea 81       	ldd	r30, Y+2	; 0x02
    4bc0:	fb 81       	ldd	r31, Y+3	; 0x03
    4bc2:	86 89       	ldd	r24, Z+22	; 0x16
    4bc4:	28 2f       	mov	r18, r24
    4bc6:	30 e0       	ldi	r19, 0x00	; 0
    4bc8:	c9 01       	movw	r24, r18
    4bca:	88 0f       	add	r24, r24
    4bcc:	99 1f       	adc	r25, r25
    4bce:	88 0f       	add	r24, r24
    4bd0:	99 1f       	adc	r25, r25
    4bd2:	88 0f       	add	r24, r24
    4bd4:	99 1f       	adc	r25, r25
    4bd6:	82 0f       	add	r24, r18
    4bd8:	93 1f       	adc	r25, r19
    4bda:	ac 01       	movw	r20, r24
    4bdc:	4f 54       	subi	r20, 0x4F	; 79
    4bde:	59 4f       	sbci	r21, 0xF9	; 249
    4be0:	8a 81       	ldd	r24, Y+2	; 0x02
    4be2:	9b 81       	ldd	r25, Y+3	; 0x03
    4be4:	9c 01       	movw	r18, r24
    4be6:	2e 5f       	subi	r18, 0xFE	; 254
    4be8:	3f 4f       	sbci	r19, 0xFF	; 255
    4bea:	ca 01       	movw	r24, r20
    4bec:	b9 01       	movw	r22, r18
    4bee:	0e 94 cf 0c 	call	0x199e	; 0x199e <vListInsertEnd>
    4bf2:	0a c0       	rjmp	.+20     	; 0x4c08 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    4bf4:	8a 81       	ldd	r24, Y+2	; 0x02
    4bf6:	9b 81       	ldd	r25, Y+3	; 0x03
    4bf8:	9c 01       	movw	r18, r24
    4bfa:	24 5f       	subi	r18, 0xF4	; 244
    4bfc:	3f 4f       	sbci	r19, 0xFF	; 255
    4bfe:	8b ee       	ldi	r24, 0xEB	; 235
    4c00:	96 e0       	ldi	r25, 0x06	; 6
    4c02:	b9 01       	movw	r22, r18
    4c04:	0e 94 cf 0c 	call	0x199e	; 0x199e <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4c08:	ea 81       	ldd	r30, Y+2	; 0x02
    4c0a:	fb 81       	ldd	r31, Y+3	; 0x03
    4c0c:	96 89       	ldd	r25, Z+22	; 0x16
    4c0e:	e0 91 a0 06 	lds	r30, 0x06A0
    4c12:	f0 91 a1 06 	lds	r31, 0x06A1
    4c16:	86 89       	ldd	r24, Z+22	; 0x16
    4c18:	89 17       	cp	r24, r25
    4c1a:	30 f4       	brcc	.+12     	; 0x4c28 <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    4c1c:	81 e0       	ldi	r24, 0x01	; 1
    4c1e:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    4c20:	81 e0       	ldi	r24, 0x01	; 1
    4c22:	80 93 a9 06 	sts	0x06A9, r24
    4c26:	01 c0       	rjmp	.+2      	; 0x4c2a <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    4c28:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    4c2a:	89 81       	ldd	r24, Y+1	; 0x01
}
    4c2c:	0f 90       	pop	r0
    4c2e:	0f 90       	pop	r0
    4c30:	0f 90       	pop	r0
    4c32:	0f 90       	pop	r0
    4c34:	0f 90       	pop	r0
    4c36:	cf 91       	pop	r28
    4c38:	df 91       	pop	r29
    4c3a:	08 95       	ret

00004c3c <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    4c3c:	df 93       	push	r29
    4c3e:	cf 93       	push	r28
    4c40:	00 d0       	rcall	.+0      	; 0x4c42 <vTaskRemoveFromUnorderedEventList+0x6>
    4c42:	00 d0       	rcall	.+0      	; 0x4c44 <vTaskRemoveFromUnorderedEventList+0x8>
    4c44:	00 d0       	rcall	.+0      	; 0x4c46 <vTaskRemoveFromUnorderedEventList+0xa>
    4c46:	cd b7       	in	r28, 0x3d	; 61
    4c48:	de b7       	in	r29, 0x3e	; 62
    4c4a:	9c 83       	std	Y+4, r25	; 0x04
    4c4c:	8b 83       	std	Y+3, r24	; 0x03
    4c4e:	7e 83       	std	Y+6, r23	; 0x06
    4c50:	6d 83       	std	Y+5, r22	; 0x05
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    4c52:	8d 81       	ldd	r24, Y+5	; 0x05
    4c54:	9e 81       	ldd	r25, Y+6	; 0x06
    4c56:	90 68       	ori	r25, 0x80	; 128
    4c58:	eb 81       	ldd	r30, Y+3	; 0x03
    4c5a:	fc 81       	ldd	r31, Y+4	; 0x04
    4c5c:	91 83       	std	Z+1, r25	; 0x01
    4c5e:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4c60:	eb 81       	ldd	r30, Y+3	; 0x03
    4c62:	fc 81       	ldd	r31, Y+4	; 0x04
    4c64:	86 81       	ldd	r24, Z+6	; 0x06
    4c66:	97 81       	ldd	r25, Z+7	; 0x07
    4c68:	9a 83       	std	Y+2, r25	; 0x02
    4c6a:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    4c6c:	8b 81       	ldd	r24, Y+3	; 0x03
    4c6e:	9c 81       	ldd	r25, Y+4	; 0x04
    4c70:	0e 94 7f 0d 	call	0x1afe	; 0x1afe <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    4c74:	89 81       	ldd	r24, Y+1	; 0x01
    4c76:	9a 81       	ldd	r25, Y+2	; 0x02
    4c78:	02 96       	adiw	r24, 0x02	; 2
    4c7a:	0e 94 7f 0d 	call	0x1afe	; 0x1afe <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    4c7e:	e9 81       	ldd	r30, Y+1	; 0x01
    4c80:	fa 81       	ldd	r31, Y+2	; 0x02
    4c82:	96 89       	ldd	r25, Z+22	; 0x16
    4c84:	80 91 a6 06 	lds	r24, 0x06A6
    4c88:	89 17       	cp	r24, r25
    4c8a:	28 f4       	brcc	.+10     	; 0x4c96 <vTaskRemoveFromUnorderedEventList+0x5a>
    4c8c:	e9 81       	ldd	r30, Y+1	; 0x01
    4c8e:	fa 81       	ldd	r31, Y+2	; 0x02
    4c90:	86 89       	ldd	r24, Z+22	; 0x16
    4c92:	80 93 a6 06 	sts	0x06A6, r24
    4c96:	e9 81       	ldd	r30, Y+1	; 0x01
    4c98:	fa 81       	ldd	r31, Y+2	; 0x02
    4c9a:	86 89       	ldd	r24, Z+22	; 0x16
    4c9c:	28 2f       	mov	r18, r24
    4c9e:	30 e0       	ldi	r19, 0x00	; 0
    4ca0:	c9 01       	movw	r24, r18
    4ca2:	88 0f       	add	r24, r24
    4ca4:	99 1f       	adc	r25, r25
    4ca6:	88 0f       	add	r24, r24
    4ca8:	99 1f       	adc	r25, r25
    4caa:	88 0f       	add	r24, r24
    4cac:	99 1f       	adc	r25, r25
    4cae:	82 0f       	add	r24, r18
    4cb0:	93 1f       	adc	r25, r19
    4cb2:	ac 01       	movw	r20, r24
    4cb4:	4f 54       	subi	r20, 0x4F	; 79
    4cb6:	59 4f       	sbci	r21, 0xF9	; 249
    4cb8:	89 81       	ldd	r24, Y+1	; 0x01
    4cba:	9a 81       	ldd	r25, Y+2	; 0x02
    4cbc:	9c 01       	movw	r18, r24
    4cbe:	2e 5f       	subi	r18, 0xFE	; 254
    4cc0:	3f 4f       	sbci	r19, 0xFF	; 255
    4cc2:	ca 01       	movw	r24, r20
    4cc4:	b9 01       	movw	r22, r18
    4cc6:	0e 94 cf 0c 	call	0x199e	; 0x199e <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4cca:	e9 81       	ldd	r30, Y+1	; 0x01
    4ccc:	fa 81       	ldd	r31, Y+2	; 0x02
    4cce:	96 89       	ldd	r25, Z+22	; 0x16
    4cd0:	e0 91 a0 06 	lds	r30, 0x06A0
    4cd4:	f0 91 a1 06 	lds	r31, 0x06A1
    4cd8:	86 89       	ldd	r24, Z+22	; 0x16
    4cda:	89 17       	cp	r24, r25
    4cdc:	18 f4       	brcc	.+6      	; 0x4ce4 <vTaskRemoveFromUnorderedEventList+0xa8>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    4cde:	81 e0       	ldi	r24, 0x01	; 1
    4ce0:	80 93 a9 06 	sts	0x06A9, r24
	}
}
    4ce4:	26 96       	adiw	r28, 0x06	; 6
    4ce6:	0f b6       	in	r0, 0x3f	; 63
    4ce8:	f8 94       	cli
    4cea:	de bf       	out	0x3e, r29	; 62
    4cec:	0f be       	out	0x3f, r0	; 63
    4cee:	cd bf       	out	0x3d, r28	; 61
    4cf0:	cf 91       	pop	r28
    4cf2:	df 91       	pop	r29
    4cf4:	08 95       	ret

00004cf6 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4cf6:	df 93       	push	r29
    4cf8:	cf 93       	push	r28
    4cfa:	00 d0       	rcall	.+0      	; 0x4cfc <vTaskSetTimeOutState+0x6>
    4cfc:	cd b7       	in	r28, 0x3d	; 61
    4cfe:	de b7       	in	r29, 0x3e	; 62
    4d00:	9a 83       	std	Y+2, r25	; 0x02
    4d02:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    4d04:	0f b6       	in	r0, 0x3f	; 63
    4d06:	f8 94       	cli
    4d08:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    4d0a:	80 91 aa 06 	lds	r24, 0x06AA
    4d0e:	e9 81       	ldd	r30, Y+1	; 0x01
    4d10:	fa 81       	ldd	r31, Y+2	; 0x02
    4d12:	80 83       	st	Z, r24
		pxTimeOut->xTimeOnEntering = xTickCount;
    4d14:	80 91 a4 06 	lds	r24, 0x06A4
    4d18:	90 91 a5 06 	lds	r25, 0x06A5
    4d1c:	e9 81       	ldd	r30, Y+1	; 0x01
    4d1e:	fa 81       	ldd	r31, Y+2	; 0x02
    4d20:	92 83       	std	Z+2, r25	; 0x02
    4d22:	81 83       	std	Z+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    4d24:	0f 90       	pop	r0
    4d26:	0f be       	out	0x3f, r0	; 63
}
    4d28:	0f 90       	pop	r0
    4d2a:	0f 90       	pop	r0
    4d2c:	cf 91       	pop	r28
    4d2e:	df 91       	pop	r29
    4d30:	08 95       	ret

00004d32 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4d32:	df 93       	push	r29
    4d34:	cf 93       	push	r28
    4d36:	00 d0       	rcall	.+0      	; 0x4d38 <vTaskInternalSetTimeOutState+0x6>
    4d38:	cd b7       	in	r28, 0x3d	; 61
    4d3a:	de b7       	in	r29, 0x3e	; 62
    4d3c:	9a 83       	std	Y+2, r25	; 0x02
    4d3e:	89 83       	std	Y+1, r24	; 0x01
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    4d40:	80 91 aa 06 	lds	r24, 0x06AA
    4d44:	e9 81       	ldd	r30, Y+1	; 0x01
    4d46:	fa 81       	ldd	r31, Y+2	; 0x02
    4d48:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    4d4a:	80 91 a4 06 	lds	r24, 0x06A4
    4d4e:	90 91 a5 06 	lds	r25, 0x06A5
    4d52:	e9 81       	ldd	r30, Y+1	; 0x01
    4d54:	fa 81       	ldd	r31, Y+2	; 0x02
    4d56:	92 83       	std	Z+2, r25	; 0x02
    4d58:	81 83       	std	Z+1, r24	; 0x01
}
    4d5a:	0f 90       	pop	r0
    4d5c:	0f 90       	pop	r0
    4d5e:	cf 91       	pop	r28
    4d60:	df 91       	pop	r29
    4d62:	08 95       	ret

00004d64 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    4d64:	df 93       	push	r29
    4d66:	cf 93       	push	r28
    4d68:	cd b7       	in	r28, 0x3d	; 61
    4d6a:	de b7       	in	r29, 0x3e	; 62
    4d6c:	29 97       	sbiw	r28, 0x09	; 9
    4d6e:	0f b6       	in	r0, 0x3f	; 63
    4d70:	f8 94       	cli
    4d72:	de bf       	out	0x3e, r29	; 62
    4d74:	0f be       	out	0x3f, r0	; 63
    4d76:	cd bf       	out	0x3d, r28	; 61
    4d78:	9f 83       	std	Y+7, r25	; 0x07
    4d7a:	8e 83       	std	Y+6, r24	; 0x06
    4d7c:	79 87       	std	Y+9, r23	; 0x09
    4d7e:	68 87       	std	Y+8, r22	; 0x08
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    4d80:	0f b6       	in	r0, 0x3f	; 63
    4d82:	f8 94       	cli
    4d84:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    4d86:	80 91 a4 06 	lds	r24, 0x06A4
    4d8a:	90 91 a5 06 	lds	r25, 0x06A5
    4d8e:	9c 83       	std	Y+4, r25	; 0x04
    4d90:	8b 83       	std	Y+3, r24	; 0x03
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    4d92:	ee 81       	ldd	r30, Y+6	; 0x06
    4d94:	ff 81       	ldd	r31, Y+7	; 0x07
    4d96:	21 81       	ldd	r18, Z+1	; 0x01
    4d98:	32 81       	ldd	r19, Z+2	; 0x02
    4d9a:	8b 81       	ldd	r24, Y+3	; 0x03
    4d9c:	9c 81       	ldd	r25, Y+4	; 0x04
    4d9e:	82 1b       	sub	r24, r18
    4da0:	93 0b       	sbc	r25, r19
    4da2:	9a 83       	std	Y+2, r25	; 0x02
    4da4:	89 83       	std	Y+1, r24	; 0x01
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    4da6:	e8 85       	ldd	r30, Y+8	; 0x08
    4da8:	f9 85       	ldd	r31, Y+9	; 0x09
    4daa:	80 81       	ld	r24, Z
    4dac:	91 81       	ldd	r25, Z+1	; 0x01
    4dae:	2f ef       	ldi	r18, 0xFF	; 255
    4db0:	8f 3f       	cpi	r24, 0xFF	; 255
    4db2:	92 07       	cpc	r25, r18
    4db4:	11 f4       	brne	.+4      	; 0x4dba <xTaskCheckForTimeOut+0x56>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    4db6:	1d 82       	std	Y+5, r1	; 0x05
    4db8:	36 c0       	rjmp	.+108    	; 0x4e26 <xTaskCheckForTimeOut+0xc2>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    4dba:	ee 81       	ldd	r30, Y+6	; 0x06
    4dbc:	ff 81       	ldd	r31, Y+7	; 0x07
    4dbe:	90 81       	ld	r25, Z
    4dc0:	80 91 aa 06 	lds	r24, 0x06AA
    4dc4:	98 17       	cp	r25, r24
    4dc6:	61 f0       	breq	.+24     	; 0x4de0 <xTaskCheckForTimeOut+0x7c>
    4dc8:	ee 81       	ldd	r30, Y+6	; 0x06
    4dca:	ff 81       	ldd	r31, Y+7	; 0x07
    4dcc:	21 81       	ldd	r18, Z+1	; 0x01
    4dce:	32 81       	ldd	r19, Z+2	; 0x02
    4dd0:	8b 81       	ldd	r24, Y+3	; 0x03
    4dd2:	9c 81       	ldd	r25, Y+4	; 0x04
    4dd4:	82 17       	cp	r24, r18
    4dd6:	93 07       	cpc	r25, r19
    4dd8:	18 f0       	brcs	.+6      	; 0x4de0 <xTaskCheckForTimeOut+0x7c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    4dda:	81 e0       	ldi	r24, 0x01	; 1
    4ddc:	8d 83       	std	Y+5, r24	; 0x05
    4dde:	23 c0       	rjmp	.+70     	; 0x4e26 <xTaskCheckForTimeOut+0xc2>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    4de0:	e8 85       	ldd	r30, Y+8	; 0x08
    4de2:	f9 85       	ldd	r31, Y+9	; 0x09
    4de4:	20 81       	ld	r18, Z
    4de6:	31 81       	ldd	r19, Z+1	; 0x01
    4de8:	89 81       	ldd	r24, Y+1	; 0x01
    4dea:	9a 81       	ldd	r25, Y+2	; 0x02
    4dec:	82 17       	cp	r24, r18
    4dee:	93 07       	cpc	r25, r19
    4df0:	a0 f4       	brcc	.+40     	; 0x4e1a <xTaskCheckForTimeOut+0xb6>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    4df2:	e8 85       	ldd	r30, Y+8	; 0x08
    4df4:	f9 85       	ldd	r31, Y+9	; 0x09
    4df6:	20 81       	ld	r18, Z
    4df8:	31 81       	ldd	r19, Z+1	; 0x01
    4dfa:	89 81       	ldd	r24, Y+1	; 0x01
    4dfc:	9a 81       	ldd	r25, Y+2	; 0x02
    4dfe:	a9 01       	movw	r20, r18
    4e00:	48 1b       	sub	r20, r24
    4e02:	59 0b       	sbc	r21, r25
    4e04:	ca 01       	movw	r24, r20
    4e06:	e8 85       	ldd	r30, Y+8	; 0x08
    4e08:	f9 85       	ldd	r31, Y+9	; 0x09
    4e0a:	91 83       	std	Z+1, r25	; 0x01
    4e0c:	80 83       	st	Z, r24
			vTaskInternalSetTimeOutState( pxTimeOut );
    4e0e:	8e 81       	ldd	r24, Y+6	; 0x06
    4e10:	9f 81       	ldd	r25, Y+7	; 0x07
    4e12:	0e 94 99 26 	call	0x4d32	; 0x4d32 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    4e16:	1d 82       	std	Y+5, r1	; 0x05
    4e18:	06 c0       	rjmp	.+12     	; 0x4e26 <xTaskCheckForTimeOut+0xc2>
		}
		else
		{
			*pxTicksToWait = 0;
    4e1a:	e8 85       	ldd	r30, Y+8	; 0x08
    4e1c:	f9 85       	ldd	r31, Y+9	; 0x09
    4e1e:	11 82       	std	Z+1, r1	; 0x01
    4e20:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    4e22:	81 e0       	ldi	r24, 0x01	; 1
    4e24:	8d 83       	std	Y+5, r24	; 0x05
		}
	}
	taskEXIT_CRITICAL();
    4e26:	0f 90       	pop	r0
    4e28:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    4e2a:	8d 81       	ldd	r24, Y+5	; 0x05
}
    4e2c:	29 96       	adiw	r28, 0x09	; 9
    4e2e:	0f b6       	in	r0, 0x3f	; 63
    4e30:	f8 94       	cli
    4e32:	de bf       	out	0x3e, r29	; 62
    4e34:	0f be       	out	0x3f, r0	; 63
    4e36:	cd bf       	out	0x3d, r28	; 61
    4e38:	cf 91       	pop	r28
    4e3a:	df 91       	pop	r29
    4e3c:	08 95       	ret

00004e3e <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    4e3e:	df 93       	push	r29
    4e40:	cf 93       	push	r28
    4e42:	cd b7       	in	r28, 0x3d	; 61
    4e44:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    4e46:	81 e0       	ldi	r24, 0x01	; 1
    4e48:	80 93 a9 06 	sts	0x06A9, r24
}
    4e4c:	cf 91       	pop	r28
    4e4e:	df 91       	pop	r29
    4e50:	08 95       	ret

00004e52 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    4e52:	df 93       	push	r29
    4e54:	cf 93       	push	r28
    4e56:	00 d0       	rcall	.+0      	; 0x4e58 <prvIdleTask+0x6>
    4e58:	cd b7       	in	r28, 0x3d	; 61
    4e5a:	de b7       	in	r29, 0x3e	; 62
    4e5c:	9a 83       	std	Y+2, r25	; 0x02
    4e5e:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    4e60:	0e 94 76 27 	call	0x4eec	; 0x4eec <prvCheckTasksWaitingTermination>
		{
			/* If we are not using preemption we keep forcing a task switch to
			see if any other task has become available.  If we are using
			preemption we don't need to do this as any task becoming available
			will automatically get the processor anyway. */
			taskYIELD();
    4e64:	0e 94 8a 0f 	call	0x1f14	; 0x1f14 <vPortYield>
    4e68:	fb cf       	rjmp	.-10     	; 0x4e60 <prvIdleTask+0xe>

00004e6a <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    4e6a:	df 93       	push	r29
    4e6c:	cf 93       	push	r28
    4e6e:	0f 92       	push	r0
    4e70:	cd b7       	in	r28, 0x3d	; 61
    4e72:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4e74:	19 82       	std	Y+1, r1	; 0x01
    4e76:	13 c0       	rjmp	.+38     	; 0x4e9e <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    4e78:	89 81       	ldd	r24, Y+1	; 0x01
    4e7a:	28 2f       	mov	r18, r24
    4e7c:	30 e0       	ldi	r19, 0x00	; 0
    4e7e:	c9 01       	movw	r24, r18
    4e80:	88 0f       	add	r24, r24
    4e82:	99 1f       	adc	r25, r25
    4e84:	88 0f       	add	r24, r24
    4e86:	99 1f       	adc	r25, r25
    4e88:	88 0f       	add	r24, r24
    4e8a:	99 1f       	adc	r25, r25
    4e8c:	82 0f       	add	r24, r18
    4e8e:	93 1f       	adc	r25, r19
    4e90:	8f 54       	subi	r24, 0x4F	; 79
    4e92:	99 4f       	sbci	r25, 0xF9	; 249
    4e94:	0e 94 95 0c 	call	0x192a	; 0x192a <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4e98:	89 81       	ldd	r24, Y+1	; 0x01
    4e9a:	8f 5f       	subi	r24, 0xFF	; 255
    4e9c:	89 83       	std	Y+1, r24	; 0x01
    4e9e:	89 81       	ldd	r24, Y+1	; 0x01
    4ea0:	84 30       	cpi	r24, 0x04	; 4
    4ea2:	50 f3       	brcs	.-44     	; 0x4e78 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    4ea4:	85 ed       	ldi	r24, 0xD5	; 213
    4ea6:	96 e0       	ldi	r25, 0x06	; 6
    4ea8:	0e 94 95 0c 	call	0x192a	; 0x192a <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    4eac:	8e ed       	ldi	r24, 0xDE	; 222
    4eae:	96 e0       	ldi	r25, 0x06	; 6
    4eb0:	0e 94 95 0c 	call	0x192a	; 0x192a <vListInitialise>
	vListInitialise( &xPendingReadyList );
    4eb4:	8b ee       	ldi	r24, 0xEB	; 235
    4eb6:	96 e0       	ldi	r25, 0x06	; 6
    4eb8:	0e 94 95 0c 	call	0x192a	; 0x192a <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    4ebc:	84 ef       	ldi	r24, 0xF4	; 244
    4ebe:	96 e0       	ldi	r25, 0x06	; 6
    4ec0:	0e 94 95 0c 	call	0x192a	; 0x192a <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    4ec4:	8d ef       	ldi	r24, 0xFD	; 253
    4ec6:	96 e0       	ldi	r25, 0x06	; 6
    4ec8:	0e 94 95 0c 	call	0x192a	; 0x192a <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    4ecc:	85 ed       	ldi	r24, 0xD5	; 213
    4ece:	96 e0       	ldi	r25, 0x06	; 6
    4ed0:	90 93 e8 06 	sts	0x06E8, r25
    4ed4:	80 93 e7 06 	sts	0x06E7, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    4ed8:	8e ed       	ldi	r24, 0xDE	; 222
    4eda:	96 e0       	ldi	r25, 0x06	; 6
    4edc:	90 93 ea 06 	sts	0x06EA, r25
    4ee0:	80 93 e9 06 	sts	0x06E9, r24
}
    4ee4:	0f 90       	pop	r0
    4ee6:	cf 91       	pop	r28
    4ee8:	df 91       	pop	r29
    4eea:	08 95       	ret

00004eec <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    4eec:	df 93       	push	r29
    4eee:	cf 93       	push	r28
    4ef0:	00 d0       	rcall	.+0      	; 0x4ef2 <prvCheckTasksWaitingTermination+0x6>
    4ef2:	cd b7       	in	r28, 0x3d	; 61
    4ef4:	de b7       	in	r29, 0x3e	; 62
    4ef6:	20 c0       	rjmp	.+64     	; 0x4f38 <prvCheckTasksWaitingTermination+0x4c>

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			taskENTER_CRITICAL();
    4ef8:	0f b6       	in	r0, 0x3f	; 63
    4efa:	f8 94       	cli
    4efc:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4efe:	e0 91 f9 06 	lds	r30, 0x06F9
    4f02:	f0 91 fa 06 	lds	r31, 0x06FA
    4f06:	86 81       	ldd	r24, Z+6	; 0x06
    4f08:	97 81       	ldd	r25, Z+7	; 0x07
    4f0a:	9a 83       	std	Y+2, r25	; 0x02
    4f0c:	89 83       	std	Y+1, r24	; 0x01
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4f0e:	89 81       	ldd	r24, Y+1	; 0x01
    4f10:	9a 81       	ldd	r25, Y+2	; 0x02
    4f12:	02 96       	adiw	r24, 0x02	; 2
    4f14:	0e 94 7f 0d 	call	0x1afe	; 0x1afe <uxListRemove>
				--uxCurrentNumberOfTasks;
    4f18:	80 91 a3 06 	lds	r24, 0x06A3
    4f1c:	81 50       	subi	r24, 0x01	; 1
    4f1e:	80 93 a3 06 	sts	0x06A3, r24
				--uxDeletedTasksWaitingCleanUp;
    4f22:	80 91 a2 06 	lds	r24, 0x06A2
    4f26:	81 50       	subi	r24, 0x01	; 1
    4f28:	80 93 a2 06 	sts	0x06A2, r24
			}
			taskEXIT_CRITICAL();
    4f2c:	0f 90       	pop	r0
    4f2e:	0f be       	out	0x3f, r0	; 63

			prvDeleteTCB( pxTCB );
    4f30:	89 81       	ldd	r24, Y+1	; 0x01
    4f32:	9a 81       	ldd	r25, Y+2	; 0x02
    4f34:	0e 94 a5 27 	call	0x4f4a	; 0x4f4a <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    4f38:	80 91 a2 06 	lds	r24, 0x06A2
    4f3c:	88 23       	and	r24, r24
    4f3e:	e1 f6       	brne	.-72     	; 0x4ef8 <prvCheckTasksWaitingTermination+0xc>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    4f40:	0f 90       	pop	r0
    4f42:	0f 90       	pop	r0
    4f44:	cf 91       	pop	r28
    4f46:	df 91       	pop	r29
    4f48:	08 95       	ret

00004f4a <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    4f4a:	df 93       	push	r29
    4f4c:	cf 93       	push	r28
    4f4e:	00 d0       	rcall	.+0      	; 0x4f50 <prvDeleteTCB+0x6>
    4f50:	cd b7       	in	r28, 0x3d	; 61
    4f52:	de b7       	in	r29, 0x3e	; 62
    4f54:	9a 83       	std	Y+2, r25	; 0x02
    4f56:	89 83       	std	Y+1, r24	; 0x01

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    4f58:	e9 81       	ldd	r30, Y+1	; 0x01
    4f5a:	fa 81       	ldd	r31, Y+2	; 0x02
    4f5c:	87 89       	ldd	r24, Z+23	; 0x17
    4f5e:	90 8d       	ldd	r25, Z+24	; 0x18
    4f60:	0e 94 6f 0c 	call	0x18de	; 0x18de <vPortFree>
			vPortFree( pxTCB );
    4f64:	89 81       	ldd	r24, Y+1	; 0x01
    4f66:	9a 81       	ldd	r25, Y+2	; 0x02
    4f68:	0e 94 6f 0c 	call	0x18de	; 0x18de <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    4f6c:	0f 90       	pop	r0
    4f6e:	0f 90       	pop	r0
    4f70:	cf 91       	pop	r28
    4f72:	df 91       	pop	r29
    4f74:	08 95       	ret

00004f76 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    4f76:	df 93       	push	r29
    4f78:	cf 93       	push	r28
    4f7a:	00 d0       	rcall	.+0      	; 0x4f7c <prvResetNextTaskUnblockTime+0x6>
    4f7c:	cd b7       	in	r28, 0x3d	; 61
    4f7e:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4f80:	e0 91 e7 06 	lds	r30, 0x06E7
    4f84:	f0 91 e8 06 	lds	r31, 0x06E8
    4f88:	80 81       	ld	r24, Z
    4f8a:	88 23       	and	r24, r24
    4f8c:	39 f4       	brne	.+14     	; 0x4f9c <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    4f8e:	8f ef       	ldi	r24, 0xFF	; 255
    4f90:	9f ef       	ldi	r25, 0xFF	; 255
    4f92:	90 93 ad 06 	sts	0x06AD, r25
    4f96:	80 93 ac 06 	sts	0x06AC, r24
    4f9a:	13 c0       	rjmp	.+38     	; 0x4fc2 <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4f9c:	e0 91 e7 06 	lds	r30, 0x06E7
    4fa0:	f0 91 e8 06 	lds	r31, 0x06E8
    4fa4:	05 80       	ldd	r0, Z+5	; 0x05
    4fa6:	f6 81       	ldd	r31, Z+6	; 0x06
    4fa8:	e0 2d       	mov	r30, r0
    4faa:	86 81       	ldd	r24, Z+6	; 0x06
    4fac:	97 81       	ldd	r25, Z+7	; 0x07
    4fae:	9a 83       	std	Y+2, r25	; 0x02
    4fb0:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    4fb2:	e9 81       	ldd	r30, Y+1	; 0x01
    4fb4:	fa 81       	ldd	r31, Y+2	; 0x02
    4fb6:	82 81       	ldd	r24, Z+2	; 0x02
    4fb8:	93 81       	ldd	r25, Z+3	; 0x03
    4fba:	90 93 ad 06 	sts	0x06AD, r25
    4fbe:	80 93 ac 06 	sts	0x06AC, r24
	}
}
    4fc2:	0f 90       	pop	r0
    4fc4:	0f 90       	pop	r0
    4fc6:	cf 91       	pop	r28
    4fc8:	df 91       	pop	r29
    4fca:	08 95       	ret

00004fcc <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    4fcc:	df 93       	push	r29
    4fce:	cf 93       	push	r28
    4fd0:	00 d0       	rcall	.+0      	; 0x4fd2 <xTaskGetCurrentTaskHandle+0x6>
    4fd2:	cd b7       	in	r28, 0x3d	; 61
    4fd4:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    4fd6:	80 91 a0 06 	lds	r24, 0x06A0
    4fda:	90 91 a1 06 	lds	r25, 0x06A1
    4fde:	9a 83       	std	Y+2, r25	; 0x02
    4fe0:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    4fe2:	89 81       	ldd	r24, Y+1	; 0x01
    4fe4:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    4fe6:	0f 90       	pop	r0
    4fe8:	0f 90       	pop	r0
    4fea:	cf 91       	pop	r28
    4fec:	df 91       	pop	r29
    4fee:	08 95       	ret

00004ff0 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    4ff0:	df 93       	push	r29
    4ff2:	cf 93       	push	r28
    4ff4:	00 d0       	rcall	.+0      	; 0x4ff6 <uxTaskResetEventItemValue+0x6>
    4ff6:	cd b7       	in	r28, 0x3d	; 61
    4ff8:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    4ffa:	e0 91 a0 06 	lds	r30, 0x06A0
    4ffe:	f0 91 a1 06 	lds	r31, 0x06A1
    5002:	84 85       	ldd	r24, Z+12	; 0x0c
    5004:	95 85       	ldd	r25, Z+13	; 0x0d
    5006:	9a 83       	std	Y+2, r25	; 0x02
    5008:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    500a:	a0 91 a0 06 	lds	r26, 0x06A0
    500e:	b0 91 a1 06 	lds	r27, 0x06A1
    5012:	e0 91 a0 06 	lds	r30, 0x06A0
    5016:	f0 91 a1 06 	lds	r31, 0x06A1
    501a:	86 89       	ldd	r24, Z+22	; 0x16
    501c:	28 2f       	mov	r18, r24
    501e:	30 e0       	ldi	r19, 0x00	; 0
    5020:	84 e0       	ldi	r24, 0x04	; 4
    5022:	90 e0       	ldi	r25, 0x00	; 0
    5024:	82 1b       	sub	r24, r18
    5026:	93 0b       	sbc	r25, r19
    5028:	1d 96       	adiw	r26, 0x0d	; 13
    502a:	9c 93       	st	X, r25
    502c:	8e 93       	st	-X, r24
    502e:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    5030:	89 81       	ldd	r24, Y+1	; 0x01
    5032:	9a 81       	ldd	r25, Y+2	; 0x02
}
    5034:	0f 90       	pop	r0
    5036:	0f 90       	pop	r0
    5038:	cf 91       	pop	r28
    503a:	df 91       	pop	r29
    503c:	08 95       	ret

0000503e <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    503e:	df 93       	push	r29
    5040:	cf 93       	push	r28
    5042:	cd b7       	in	r28, 0x3d	; 61
    5044:	de b7       	in	r29, 0x3e	; 62
    5046:	27 97       	sbiw	r28, 0x07	; 7
    5048:	0f b6       	in	r0, 0x3f	; 63
    504a:	f8 94       	cli
    504c:	de bf       	out	0x3e, r29	; 62
    504e:	0f be       	out	0x3f, r0	; 63
    5050:	cd bf       	out	0x3d, r28	; 61
    5052:	8d 83       	std	Y+5, r24	; 0x05
    5054:	7f 83       	std	Y+7, r23	; 0x07
    5056:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    5058:	0f b6       	in	r0, 0x3f	; 63
    505a:	f8 94       	cli
    505c:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    505e:	e0 91 a0 06 	lds	r30, 0x06A0
    5062:	f0 91 a1 06 	lds	r31, 0x06A1
    5066:	81 a5       	ldd	r24, Z+41	; 0x29
    5068:	92 a5       	ldd	r25, Z+42	; 0x2a
    506a:	a3 a5       	ldd	r26, Z+43	; 0x2b
    506c:	b4 a5       	ldd	r27, Z+44	; 0x2c
    506e:	00 97       	sbiw	r24, 0x00	; 0
    5070:	a1 05       	cpc	r26, r1
    5072:	b1 05       	cpc	r27, r1
    5074:	89 f4       	brne	.+34     	; 0x5098 <ulTaskNotifyTake+0x5a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    5076:	e0 91 a0 06 	lds	r30, 0x06A0
    507a:	f0 91 a1 06 	lds	r31, 0x06A1
    507e:	81 e0       	ldi	r24, 0x01	; 1
    5080:	85 a7       	std	Z+45, r24	; 0x2d

				if( xTicksToWait > ( TickType_t ) 0 )
    5082:	8e 81       	ldd	r24, Y+6	; 0x06
    5084:	9f 81       	ldd	r25, Y+7	; 0x07
    5086:	00 97       	sbiw	r24, 0x00	; 0
    5088:	39 f0       	breq	.+14     	; 0x5098 <ulTaskNotifyTake+0x5a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    508a:	8e 81       	ldd	r24, Y+6	; 0x06
    508c:	9f 81       	ldd	r25, Y+7	; 0x07
    508e:	61 e0       	ldi	r22, 0x01	; 1
    5090:	0e 94 bf 2b 	call	0x577e	; 0x577e <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    5094:	0e 94 8a 0f 	call	0x1f14	; 0x1f14 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    5098:	0f 90       	pop	r0
    509a:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    509c:	0f b6       	in	r0, 0x3f	; 63
    509e:	f8 94       	cli
    50a0:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    50a2:	e0 91 a0 06 	lds	r30, 0x06A0
    50a6:	f0 91 a1 06 	lds	r31, 0x06A1
    50aa:	81 a5       	ldd	r24, Z+41	; 0x29
    50ac:	92 a5       	ldd	r25, Z+42	; 0x2a
    50ae:	a3 a5       	ldd	r26, Z+43	; 0x2b
    50b0:	b4 a5       	ldd	r27, Z+44	; 0x2c
    50b2:	89 83       	std	Y+1, r24	; 0x01
    50b4:	9a 83       	std	Y+2, r25	; 0x02
    50b6:	ab 83       	std	Y+3, r26	; 0x03
    50b8:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    50ba:	89 81       	ldd	r24, Y+1	; 0x01
    50bc:	9a 81       	ldd	r25, Y+2	; 0x02
    50be:	ab 81       	ldd	r26, Y+3	; 0x03
    50c0:	bc 81       	ldd	r27, Y+4	; 0x04
    50c2:	00 97       	sbiw	r24, 0x00	; 0
    50c4:	a1 05       	cpc	r26, r1
    50c6:	b1 05       	cpc	r27, r1
    50c8:	d9 f0       	breq	.+54     	; 0x5100 <ulTaskNotifyTake+0xc2>
			{
				if( xClearCountOnExit != pdFALSE )
    50ca:	8d 81       	ldd	r24, Y+5	; 0x05
    50cc:	88 23       	and	r24, r24
    50ce:	49 f0       	breq	.+18     	; 0x50e2 <ulTaskNotifyTake+0xa4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    50d0:	e0 91 a0 06 	lds	r30, 0x06A0
    50d4:	f0 91 a1 06 	lds	r31, 0x06A1
    50d8:	11 a6       	std	Z+41, r1	; 0x29
    50da:	12 a6       	std	Z+42, r1	; 0x2a
    50dc:	13 a6       	std	Z+43, r1	; 0x2b
    50de:	14 a6       	std	Z+44, r1	; 0x2c
    50e0:	0f c0       	rjmp	.+30     	; 0x5100 <ulTaskNotifyTake+0xc2>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    50e2:	e0 91 a0 06 	lds	r30, 0x06A0
    50e6:	f0 91 a1 06 	lds	r31, 0x06A1
    50ea:	89 81       	ldd	r24, Y+1	; 0x01
    50ec:	9a 81       	ldd	r25, Y+2	; 0x02
    50ee:	ab 81       	ldd	r26, Y+3	; 0x03
    50f0:	bc 81       	ldd	r27, Y+4	; 0x04
    50f2:	01 97       	sbiw	r24, 0x01	; 1
    50f4:	a1 09       	sbc	r26, r1
    50f6:	b1 09       	sbc	r27, r1
    50f8:	81 a7       	std	Z+41, r24	; 0x29
    50fa:	92 a7       	std	Z+42, r25	; 0x2a
    50fc:	a3 a7       	std	Z+43, r26	; 0x2b
    50fe:	b4 a7       	std	Z+44, r27	; 0x2c
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    5100:	e0 91 a0 06 	lds	r30, 0x06A0
    5104:	f0 91 a1 06 	lds	r31, 0x06A1
    5108:	15 a6       	std	Z+45, r1	; 0x2d
		}
		taskEXIT_CRITICAL();
    510a:	0f 90       	pop	r0
    510c:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    510e:	89 81       	ldd	r24, Y+1	; 0x01
    5110:	9a 81       	ldd	r25, Y+2	; 0x02
    5112:	ab 81       	ldd	r26, Y+3	; 0x03
    5114:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    5116:	bc 01       	movw	r22, r24
    5118:	cd 01       	movw	r24, r26
    511a:	27 96       	adiw	r28, 0x07	; 7
    511c:	0f b6       	in	r0, 0x3f	; 63
    511e:	f8 94       	cli
    5120:	de bf       	out	0x3e, r29	; 62
    5122:	0f be       	out	0x3f, r0	; 63
    5124:	cd bf       	out	0x3d, r28	; 61
    5126:	cf 91       	pop	r28
    5128:	df 91       	pop	r29
    512a:	08 95       	ret

0000512c <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    512c:	ef 92       	push	r14
    512e:	ff 92       	push	r15
    5130:	0f 93       	push	r16
    5132:	1f 93       	push	r17
    5134:	df 93       	push	r29
    5136:	cf 93       	push	r28
    5138:	cd b7       	in	r28, 0x3d	; 61
    513a:	de b7       	in	r29, 0x3e	; 62
    513c:	2d 97       	sbiw	r28, 0x0d	; 13
    513e:	0f b6       	in	r0, 0x3f	; 63
    5140:	f8 94       	cli
    5142:	de bf       	out	0x3e, r29	; 62
    5144:	0f be       	out	0x3f, r0	; 63
    5146:	cd bf       	out	0x3d, r28	; 61
    5148:	6a 83       	std	Y+2, r22	; 0x02
    514a:	7b 83       	std	Y+3, r23	; 0x03
    514c:	8c 83       	std	Y+4, r24	; 0x04
    514e:	9d 83       	std	Y+5, r25	; 0x05
    5150:	2e 83       	std	Y+6, r18	; 0x06
    5152:	3f 83       	std	Y+7, r19	; 0x07
    5154:	48 87       	std	Y+8, r20	; 0x08
    5156:	59 87       	std	Y+9, r21	; 0x09
    5158:	1b 87       	std	Y+11, r17	; 0x0b
    515a:	0a 87       	std	Y+10, r16	; 0x0a
    515c:	fd 86       	std	Y+13, r15	; 0x0d
    515e:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    5160:	0f b6       	in	r0, 0x3f	; 63
    5162:	f8 94       	cli
    5164:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    5166:	e0 91 a0 06 	lds	r30, 0x06A0
    516a:	f0 91 a1 06 	lds	r31, 0x06A1
    516e:	85 a5       	ldd	r24, Z+45	; 0x2d
    5170:	82 30       	cpi	r24, 0x02	; 2
    5172:	49 f1       	breq	.+82     	; 0x51c6 <xTaskNotifyWait+0x9a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    5174:	e0 91 a0 06 	lds	r30, 0x06A0
    5178:	f0 91 a1 06 	lds	r31, 0x06A1
    517c:	21 a5       	ldd	r18, Z+41	; 0x29
    517e:	32 a5       	ldd	r19, Z+42	; 0x2a
    5180:	43 a5       	ldd	r20, Z+43	; 0x2b
    5182:	54 a5       	ldd	r21, Z+44	; 0x2c
    5184:	8a 81       	ldd	r24, Y+2	; 0x02
    5186:	9b 81       	ldd	r25, Y+3	; 0x03
    5188:	ac 81       	ldd	r26, Y+4	; 0x04
    518a:	bd 81       	ldd	r27, Y+5	; 0x05
    518c:	80 95       	com	r24
    518e:	90 95       	com	r25
    5190:	a0 95       	com	r26
    5192:	b0 95       	com	r27
    5194:	82 23       	and	r24, r18
    5196:	93 23       	and	r25, r19
    5198:	a4 23       	and	r26, r20
    519a:	b5 23       	and	r27, r21
    519c:	81 a7       	std	Z+41, r24	; 0x29
    519e:	92 a7       	std	Z+42, r25	; 0x2a
    51a0:	a3 a7       	std	Z+43, r26	; 0x2b
    51a2:	b4 a7       	std	Z+44, r27	; 0x2c

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    51a4:	e0 91 a0 06 	lds	r30, 0x06A0
    51a8:	f0 91 a1 06 	lds	r31, 0x06A1
    51ac:	81 e0       	ldi	r24, 0x01	; 1
    51ae:	85 a7       	std	Z+45, r24	; 0x2d

				if( xTicksToWait > ( TickType_t ) 0 )
    51b0:	8c 85       	ldd	r24, Y+12	; 0x0c
    51b2:	9d 85       	ldd	r25, Y+13	; 0x0d
    51b4:	00 97       	sbiw	r24, 0x00	; 0
    51b6:	39 f0       	breq	.+14     	; 0x51c6 <xTaskNotifyWait+0x9a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    51b8:	8c 85       	ldd	r24, Y+12	; 0x0c
    51ba:	9d 85       	ldd	r25, Y+13	; 0x0d
    51bc:	61 e0       	ldi	r22, 0x01	; 1
    51be:	0e 94 bf 2b 	call	0x577e	; 0x577e <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    51c2:	0e 94 8a 0f 	call	0x1f14	; 0x1f14 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    51c6:	0f 90       	pop	r0
    51c8:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    51ca:	0f b6       	in	r0, 0x3f	; 63
    51cc:	f8 94       	cli
    51ce:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    51d0:	8a 85       	ldd	r24, Y+10	; 0x0a
    51d2:	9b 85       	ldd	r25, Y+11	; 0x0b
    51d4:	00 97       	sbiw	r24, 0x00	; 0
    51d6:	71 f0       	breq	.+28     	; 0x51f4 <xTaskNotifyWait+0xc8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    51d8:	e0 91 a0 06 	lds	r30, 0x06A0
    51dc:	f0 91 a1 06 	lds	r31, 0x06A1
    51e0:	81 a5       	ldd	r24, Z+41	; 0x29
    51e2:	92 a5       	ldd	r25, Z+42	; 0x2a
    51e4:	a3 a5       	ldd	r26, Z+43	; 0x2b
    51e6:	b4 a5       	ldd	r27, Z+44	; 0x2c
    51e8:	ea 85       	ldd	r30, Y+10	; 0x0a
    51ea:	fb 85       	ldd	r31, Y+11	; 0x0b
    51ec:	80 83       	st	Z, r24
    51ee:	91 83       	std	Z+1, r25	; 0x01
    51f0:	a2 83       	std	Z+2, r26	; 0x02
    51f2:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    51f4:	e0 91 a0 06 	lds	r30, 0x06A0
    51f8:	f0 91 a1 06 	lds	r31, 0x06A1
    51fc:	85 a5       	ldd	r24, Z+45	; 0x2d
    51fe:	82 30       	cpi	r24, 0x02	; 2
    5200:	11 f0       	breq	.+4      	; 0x5206 <xTaskNotifyWait+0xda>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    5202:	19 82       	std	Y+1, r1	; 0x01
    5204:	1a c0       	rjmp	.+52     	; 0x523a <xTaskNotifyWait+0x10e>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    5206:	e0 91 a0 06 	lds	r30, 0x06A0
    520a:	f0 91 a1 06 	lds	r31, 0x06A1
    520e:	21 a5       	ldd	r18, Z+41	; 0x29
    5210:	32 a5       	ldd	r19, Z+42	; 0x2a
    5212:	43 a5       	ldd	r20, Z+43	; 0x2b
    5214:	54 a5       	ldd	r21, Z+44	; 0x2c
    5216:	8e 81       	ldd	r24, Y+6	; 0x06
    5218:	9f 81       	ldd	r25, Y+7	; 0x07
    521a:	a8 85       	ldd	r26, Y+8	; 0x08
    521c:	b9 85       	ldd	r27, Y+9	; 0x09
    521e:	80 95       	com	r24
    5220:	90 95       	com	r25
    5222:	a0 95       	com	r26
    5224:	b0 95       	com	r27
    5226:	82 23       	and	r24, r18
    5228:	93 23       	and	r25, r19
    522a:	a4 23       	and	r26, r20
    522c:	b5 23       	and	r27, r21
    522e:	81 a7       	std	Z+41, r24	; 0x29
    5230:	92 a7       	std	Z+42, r25	; 0x2a
    5232:	a3 a7       	std	Z+43, r26	; 0x2b
    5234:	b4 a7       	std	Z+44, r27	; 0x2c
				xReturn = pdTRUE;
    5236:	81 e0       	ldi	r24, 0x01	; 1
    5238:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    523a:	e0 91 a0 06 	lds	r30, 0x06A0
    523e:	f0 91 a1 06 	lds	r31, 0x06A1
    5242:	15 a6       	std	Z+45, r1	; 0x2d
		}
		taskEXIT_CRITICAL();
    5244:	0f 90       	pop	r0
    5246:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    5248:	89 81       	ldd	r24, Y+1	; 0x01
	}
    524a:	2d 96       	adiw	r28, 0x0d	; 13
    524c:	0f b6       	in	r0, 0x3f	; 63
    524e:	f8 94       	cli
    5250:	de bf       	out	0x3e, r29	; 62
    5252:	0f be       	out	0x3f, r0	; 63
    5254:	cd bf       	out	0x3d, r28	; 61
    5256:	cf 91       	pop	r28
    5258:	df 91       	pop	r29
    525a:	1f 91       	pop	r17
    525c:	0f 91       	pop	r16
    525e:	ff 90       	pop	r15
    5260:	ef 90       	pop	r14
    5262:	08 95       	ret

00005264 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    5264:	0f 93       	push	r16
    5266:	1f 93       	push	r17
    5268:	df 93       	push	r29
    526a:	cf 93       	push	r28
    526c:	cd b7       	in	r28, 0x3d	; 61
    526e:	de b7       	in	r29, 0x3e	; 62
    5270:	61 97       	sbiw	r28, 0x11	; 17
    5272:	0f b6       	in	r0, 0x3f	; 63
    5274:	f8 94       	cli
    5276:	de bf       	out	0x3e, r29	; 62
    5278:	0f be       	out	0x3f, r0	; 63
    527a:	cd bf       	out	0x3d, r28	; 61
    527c:	9e 83       	std	Y+6, r25	; 0x06
    527e:	8d 83       	std	Y+5, r24	; 0x05
    5280:	4f 83       	std	Y+7, r20	; 0x07
    5282:	58 87       	std	Y+8, r21	; 0x08
    5284:	69 87       	std	Y+9, r22	; 0x09
    5286:	7a 87       	std	Y+10, r23	; 0x0a
    5288:	2b 87       	std	Y+11, r18	; 0x0b
    528a:	1d 87       	std	Y+13, r17	; 0x0d
    528c:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    528e:	81 e0       	ldi	r24, 0x01	; 1
    5290:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
    5292:	8d 81       	ldd	r24, Y+5	; 0x05
    5294:	9e 81       	ldd	r25, Y+6	; 0x06
    5296:	9c 83       	std	Y+4, r25	; 0x04
    5298:	8b 83       	std	Y+3, r24	; 0x03

		taskENTER_CRITICAL();
    529a:	0f b6       	in	r0, 0x3f	; 63
    529c:	f8 94       	cli
    529e:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    52a0:	8c 85       	ldd	r24, Y+12	; 0x0c
    52a2:	9d 85       	ldd	r25, Y+13	; 0x0d
    52a4:	00 97       	sbiw	r24, 0x00	; 0
    52a6:	61 f0       	breq	.+24     	; 0x52c0 <xTaskGenericNotify+0x5c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    52a8:	eb 81       	ldd	r30, Y+3	; 0x03
    52aa:	fc 81       	ldd	r31, Y+4	; 0x04
    52ac:	81 a5       	ldd	r24, Z+41	; 0x29
    52ae:	92 a5       	ldd	r25, Z+42	; 0x2a
    52b0:	a3 a5       	ldd	r26, Z+43	; 0x2b
    52b2:	b4 a5       	ldd	r27, Z+44	; 0x2c
    52b4:	ec 85       	ldd	r30, Y+12	; 0x0c
    52b6:	fd 85       	ldd	r31, Y+13	; 0x0d
    52b8:	80 83       	st	Z, r24
    52ba:	91 83       	std	Z+1, r25	; 0x01
    52bc:	a2 83       	std	Z+2, r26	; 0x02
    52be:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    52c0:	eb 81       	ldd	r30, Y+3	; 0x03
    52c2:	fc 81       	ldd	r31, Y+4	; 0x04
    52c4:	85 a5       	ldd	r24, Z+45	; 0x2d
    52c6:	89 83       	std	Y+1, r24	; 0x01

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    52c8:	eb 81       	ldd	r30, Y+3	; 0x03
    52ca:	fc 81       	ldd	r31, Y+4	; 0x04
    52cc:	82 e0       	ldi	r24, 0x02	; 2
    52ce:	85 a7       	std	Z+45, r24	; 0x2d

			switch( eAction )
    52d0:	8b 85       	ldd	r24, Y+11	; 0x0b
    52d2:	28 2f       	mov	r18, r24
    52d4:	30 e0       	ldi	r19, 0x00	; 0
    52d6:	39 8b       	std	Y+17, r19	; 0x11
    52d8:	28 8b       	std	Y+16, r18	; 0x10
    52da:	88 89       	ldd	r24, Y+16	; 0x10
    52dc:	99 89       	ldd	r25, Y+17	; 0x11
    52de:	82 30       	cpi	r24, 0x02	; 2
    52e0:	91 05       	cpc	r25, r1
    52e2:	59 f1       	breq	.+86     	; 0x533a <xTaskGenericNotify+0xd6>
    52e4:	28 89       	ldd	r18, Y+16	; 0x10
    52e6:	39 89       	ldd	r19, Y+17	; 0x11
    52e8:	23 30       	cpi	r18, 0x03	; 3
    52ea:	31 05       	cpc	r19, r1
    52ec:	34 f4       	brge	.+12     	; 0x52fa <xTaskGenericNotify+0x96>
    52ee:	88 89       	ldd	r24, Y+16	; 0x10
    52f0:	99 89       	ldd	r25, Y+17	; 0x11
    52f2:	81 30       	cpi	r24, 0x01	; 1
    52f4:	91 05       	cpc	r25, r1
    52f6:	61 f0       	breq	.+24     	; 0x5310 <xTaskGenericNotify+0xac>
    52f8:	4a c0       	rjmp	.+148    	; 0x538e <xTaskGenericNotify+0x12a>
    52fa:	28 89       	ldd	r18, Y+16	; 0x10
    52fc:	39 89       	ldd	r19, Y+17	; 0x11
    52fe:	23 30       	cpi	r18, 0x03	; 3
    5300:	31 05       	cpc	r19, r1
    5302:	59 f1       	breq	.+86     	; 0x535a <xTaskGenericNotify+0xf6>
    5304:	88 89       	ldd	r24, Y+16	; 0x10
    5306:	99 89       	ldd	r25, Y+17	; 0x11
    5308:	84 30       	cpi	r24, 0x04	; 4
    530a:	91 05       	cpc	r25, r1
    530c:	89 f1       	breq	.+98     	; 0x5370 <xTaskGenericNotify+0x10c>
    530e:	3f c0       	rjmp	.+126    	; 0x538e <xTaskGenericNotify+0x12a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    5310:	eb 81       	ldd	r30, Y+3	; 0x03
    5312:	fc 81       	ldd	r31, Y+4	; 0x04
    5314:	21 a5       	ldd	r18, Z+41	; 0x29
    5316:	32 a5       	ldd	r19, Z+42	; 0x2a
    5318:	43 a5       	ldd	r20, Z+43	; 0x2b
    531a:	54 a5       	ldd	r21, Z+44	; 0x2c
    531c:	8f 81       	ldd	r24, Y+7	; 0x07
    531e:	98 85       	ldd	r25, Y+8	; 0x08
    5320:	a9 85       	ldd	r26, Y+9	; 0x09
    5322:	ba 85       	ldd	r27, Y+10	; 0x0a
    5324:	82 2b       	or	r24, r18
    5326:	93 2b       	or	r25, r19
    5328:	a4 2b       	or	r26, r20
    532a:	b5 2b       	or	r27, r21
    532c:	eb 81       	ldd	r30, Y+3	; 0x03
    532e:	fc 81       	ldd	r31, Y+4	; 0x04
    5330:	81 a7       	std	Z+41, r24	; 0x29
    5332:	92 a7       	std	Z+42, r25	; 0x2a
    5334:	a3 a7       	std	Z+43, r26	; 0x2b
    5336:	b4 a7       	std	Z+44, r27	; 0x2c
    5338:	2a c0       	rjmp	.+84     	; 0x538e <xTaskGenericNotify+0x12a>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    533a:	eb 81       	ldd	r30, Y+3	; 0x03
    533c:	fc 81       	ldd	r31, Y+4	; 0x04
    533e:	81 a5       	ldd	r24, Z+41	; 0x29
    5340:	92 a5       	ldd	r25, Z+42	; 0x2a
    5342:	a3 a5       	ldd	r26, Z+43	; 0x2b
    5344:	b4 a5       	ldd	r27, Z+44	; 0x2c
    5346:	01 96       	adiw	r24, 0x01	; 1
    5348:	a1 1d       	adc	r26, r1
    534a:	b1 1d       	adc	r27, r1
    534c:	eb 81       	ldd	r30, Y+3	; 0x03
    534e:	fc 81       	ldd	r31, Y+4	; 0x04
    5350:	81 a7       	std	Z+41, r24	; 0x29
    5352:	92 a7       	std	Z+42, r25	; 0x2a
    5354:	a3 a7       	std	Z+43, r26	; 0x2b
    5356:	b4 a7       	std	Z+44, r27	; 0x2c
    5358:	1a c0       	rjmp	.+52     	; 0x538e <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    535a:	eb 81       	ldd	r30, Y+3	; 0x03
    535c:	fc 81       	ldd	r31, Y+4	; 0x04
    535e:	8f 81       	ldd	r24, Y+7	; 0x07
    5360:	98 85       	ldd	r25, Y+8	; 0x08
    5362:	a9 85       	ldd	r26, Y+9	; 0x09
    5364:	ba 85       	ldd	r27, Y+10	; 0x0a
    5366:	81 a7       	std	Z+41, r24	; 0x29
    5368:	92 a7       	std	Z+42, r25	; 0x2a
    536a:	a3 a7       	std	Z+43, r26	; 0x2b
    536c:	b4 a7       	std	Z+44, r27	; 0x2c
    536e:	0f c0       	rjmp	.+30     	; 0x538e <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    5370:	89 81       	ldd	r24, Y+1	; 0x01
    5372:	82 30       	cpi	r24, 0x02	; 2
    5374:	59 f0       	breq	.+22     	; 0x538c <xTaskGenericNotify+0x128>
					{
						pxTCB->ulNotifiedValue = ulValue;
    5376:	eb 81       	ldd	r30, Y+3	; 0x03
    5378:	fc 81       	ldd	r31, Y+4	; 0x04
    537a:	8f 81       	ldd	r24, Y+7	; 0x07
    537c:	98 85       	ldd	r25, Y+8	; 0x08
    537e:	a9 85       	ldd	r26, Y+9	; 0x09
    5380:	ba 85       	ldd	r27, Y+10	; 0x0a
    5382:	81 a7       	std	Z+41, r24	; 0x29
    5384:	92 a7       	std	Z+42, r25	; 0x2a
    5386:	a3 a7       	std	Z+43, r26	; 0x2b
    5388:	b4 a7       	std	Z+44, r27	; 0x2c
    538a:	01 c0       	rjmp	.+2      	; 0x538e <xTaskGenericNotify+0x12a>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    538c:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    538e:	89 81       	ldd	r24, Y+1	; 0x01
    5390:	81 30       	cpi	r24, 0x01	; 1
    5392:	79 f5       	brne	.+94     	; 0x53f2 <xTaskGenericNotify+0x18e>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5394:	8b 81       	ldd	r24, Y+3	; 0x03
    5396:	9c 81       	ldd	r25, Y+4	; 0x04
    5398:	02 96       	adiw	r24, 0x02	; 2
    539a:	0e 94 7f 0d 	call	0x1afe	; 0x1afe <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    539e:	eb 81       	ldd	r30, Y+3	; 0x03
    53a0:	fc 81       	ldd	r31, Y+4	; 0x04
    53a2:	96 89       	ldd	r25, Z+22	; 0x16
    53a4:	80 91 a6 06 	lds	r24, 0x06A6
    53a8:	89 17       	cp	r24, r25
    53aa:	28 f4       	brcc	.+10     	; 0x53b6 <xTaskGenericNotify+0x152>
    53ac:	eb 81       	ldd	r30, Y+3	; 0x03
    53ae:	fc 81       	ldd	r31, Y+4	; 0x04
    53b0:	86 89       	ldd	r24, Z+22	; 0x16
    53b2:	80 93 a6 06 	sts	0x06A6, r24
    53b6:	eb 81       	ldd	r30, Y+3	; 0x03
    53b8:	fc 81       	ldd	r31, Y+4	; 0x04
    53ba:	86 89       	ldd	r24, Z+22	; 0x16
    53bc:	28 2f       	mov	r18, r24
    53be:	30 e0       	ldi	r19, 0x00	; 0
    53c0:	c9 01       	movw	r24, r18
    53c2:	88 0f       	add	r24, r24
    53c4:	99 1f       	adc	r25, r25
    53c6:	88 0f       	add	r24, r24
    53c8:	99 1f       	adc	r25, r25
    53ca:	88 0f       	add	r24, r24
    53cc:	99 1f       	adc	r25, r25
    53ce:	82 0f       	add	r24, r18
    53d0:	93 1f       	adc	r25, r19
    53d2:	ac 01       	movw	r20, r24
    53d4:	4f 54       	subi	r20, 0x4F	; 79
    53d6:	59 4f       	sbci	r21, 0xF9	; 249
    53d8:	8b 81       	ldd	r24, Y+3	; 0x03
    53da:	9c 81       	ldd	r25, Y+4	; 0x04
    53dc:	9c 01       	movw	r18, r24
    53de:	2e 5f       	subi	r18, 0xFE	; 254
    53e0:	3f 4f       	sbci	r19, 0xFF	; 255
    53e2:	ca 01       	movw	r24, r20
    53e4:	b9 01       	movw	r22, r18
    53e6:	0e 94 cf 0c 	call	0x199e	; 0x199e <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    53ea:	20 91 a0 06 	lds	r18, 0x06A0
    53ee:	30 91 a1 06 	lds	r19, 0x06A1
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    53f2:	0f 90       	pop	r0
    53f4:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    53f6:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    53f8:	61 96       	adiw	r28, 0x11	; 17
    53fa:	0f b6       	in	r0, 0x3f	; 63
    53fc:	f8 94       	cli
    53fe:	de bf       	out	0x3e, r29	; 62
    5400:	0f be       	out	0x3f, r0	; 63
    5402:	cd bf       	out	0x3d, r28	; 61
    5404:	cf 91       	pop	r28
    5406:	df 91       	pop	r29
    5408:	1f 91       	pop	r17
    540a:	0f 91       	pop	r16
    540c:	08 95       	ret

0000540e <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    540e:	ef 92       	push	r14
    5410:	ff 92       	push	r15
    5412:	0f 93       	push	r16
    5414:	1f 93       	push	r17
    5416:	df 93       	push	r29
    5418:	cf 93       	push	r28
    541a:	cd b7       	in	r28, 0x3d	; 61
    541c:	de b7       	in	r29, 0x3e	; 62
    541e:	62 97       	sbiw	r28, 0x12	; 18
    5420:	0f b6       	in	r0, 0x3f	; 63
    5422:	f8 94       	cli
    5424:	de bf       	out	0x3e, r29	; 62
    5426:	0f be       	out	0x3f, r0	; 63
    5428:	cd bf       	out	0x3d, r28	; 61
    542a:	9f 83       	std	Y+7, r25	; 0x07
    542c:	8e 83       	std	Y+6, r24	; 0x06
    542e:	48 87       	std	Y+8, r20	; 0x08
    5430:	59 87       	std	Y+9, r21	; 0x09
    5432:	6a 87       	std	Y+10, r22	; 0x0a
    5434:	7b 87       	std	Y+11, r23	; 0x0b
    5436:	2c 87       	std	Y+12, r18	; 0x0c
    5438:	1e 87       	std	Y+14, r17	; 0x0e
    543a:	0d 87       	std	Y+13, r16	; 0x0d
    543c:	f8 8a       	std	Y+16, r15	; 0x10
    543e:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    5440:	81 e0       	ldi	r24, 0x01	; 1
    5442:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    5444:	8e 81       	ldd	r24, Y+6	; 0x06
    5446:	9f 81       	ldd	r25, Y+7	; 0x07
    5448:	9d 83       	std	Y+5, r25	; 0x05
    544a:	8c 83       	std	Y+4, r24	; 0x04

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    544c:	19 82       	std	Y+1, r1	; 0x01
		{
			if( pulPreviousNotificationValue != NULL )
    544e:	8d 85       	ldd	r24, Y+13	; 0x0d
    5450:	9e 85       	ldd	r25, Y+14	; 0x0e
    5452:	00 97       	sbiw	r24, 0x00	; 0
    5454:	61 f0       	breq	.+24     	; 0x546e <xTaskGenericNotifyFromISR+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    5456:	ec 81       	ldd	r30, Y+4	; 0x04
    5458:	fd 81       	ldd	r31, Y+5	; 0x05
    545a:	81 a5       	ldd	r24, Z+41	; 0x29
    545c:	92 a5       	ldd	r25, Z+42	; 0x2a
    545e:	a3 a5       	ldd	r26, Z+43	; 0x2b
    5460:	b4 a5       	ldd	r27, Z+44	; 0x2c
    5462:	ed 85       	ldd	r30, Y+13	; 0x0d
    5464:	fe 85       	ldd	r31, Y+14	; 0x0e
    5466:	80 83       	st	Z, r24
    5468:	91 83       	std	Z+1, r25	; 0x01
    546a:	a2 83       	std	Z+2, r26	; 0x02
    546c:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    546e:	ec 81       	ldd	r30, Y+4	; 0x04
    5470:	fd 81       	ldd	r31, Y+5	; 0x05
    5472:	85 a5       	ldd	r24, Z+45	; 0x2d
    5474:	8b 83       	std	Y+3, r24	; 0x03
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    5476:	ec 81       	ldd	r30, Y+4	; 0x04
    5478:	fd 81       	ldd	r31, Y+5	; 0x05
    547a:	82 e0       	ldi	r24, 0x02	; 2
    547c:	85 a7       	std	Z+45, r24	; 0x2d

			switch( eAction )
    547e:	8c 85       	ldd	r24, Y+12	; 0x0c
    5480:	28 2f       	mov	r18, r24
    5482:	30 e0       	ldi	r19, 0x00	; 0
    5484:	3a 8b       	std	Y+18, r19	; 0x12
    5486:	29 8b       	std	Y+17, r18	; 0x11
    5488:	89 89       	ldd	r24, Y+17	; 0x11
    548a:	9a 89       	ldd	r25, Y+18	; 0x12
    548c:	82 30       	cpi	r24, 0x02	; 2
    548e:	91 05       	cpc	r25, r1
    5490:	59 f1       	breq	.+86     	; 0x54e8 <xTaskGenericNotifyFromISR+0xda>
    5492:	29 89       	ldd	r18, Y+17	; 0x11
    5494:	3a 89       	ldd	r19, Y+18	; 0x12
    5496:	23 30       	cpi	r18, 0x03	; 3
    5498:	31 05       	cpc	r19, r1
    549a:	34 f4       	brge	.+12     	; 0x54a8 <xTaskGenericNotifyFromISR+0x9a>
    549c:	89 89       	ldd	r24, Y+17	; 0x11
    549e:	9a 89       	ldd	r25, Y+18	; 0x12
    54a0:	81 30       	cpi	r24, 0x01	; 1
    54a2:	91 05       	cpc	r25, r1
    54a4:	61 f0       	breq	.+24     	; 0x54be <xTaskGenericNotifyFromISR+0xb0>
    54a6:	4a c0       	rjmp	.+148    	; 0x553c <xTaskGenericNotifyFromISR+0x12e>
    54a8:	29 89       	ldd	r18, Y+17	; 0x11
    54aa:	3a 89       	ldd	r19, Y+18	; 0x12
    54ac:	23 30       	cpi	r18, 0x03	; 3
    54ae:	31 05       	cpc	r19, r1
    54b0:	59 f1       	breq	.+86     	; 0x5508 <xTaskGenericNotifyFromISR+0xfa>
    54b2:	89 89       	ldd	r24, Y+17	; 0x11
    54b4:	9a 89       	ldd	r25, Y+18	; 0x12
    54b6:	84 30       	cpi	r24, 0x04	; 4
    54b8:	91 05       	cpc	r25, r1
    54ba:	89 f1       	breq	.+98     	; 0x551e <xTaskGenericNotifyFromISR+0x110>
    54bc:	3f c0       	rjmp	.+126    	; 0x553c <xTaskGenericNotifyFromISR+0x12e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    54be:	ec 81       	ldd	r30, Y+4	; 0x04
    54c0:	fd 81       	ldd	r31, Y+5	; 0x05
    54c2:	21 a5       	ldd	r18, Z+41	; 0x29
    54c4:	32 a5       	ldd	r19, Z+42	; 0x2a
    54c6:	43 a5       	ldd	r20, Z+43	; 0x2b
    54c8:	54 a5       	ldd	r21, Z+44	; 0x2c
    54ca:	88 85       	ldd	r24, Y+8	; 0x08
    54cc:	99 85       	ldd	r25, Y+9	; 0x09
    54ce:	aa 85       	ldd	r26, Y+10	; 0x0a
    54d0:	bb 85       	ldd	r27, Y+11	; 0x0b
    54d2:	82 2b       	or	r24, r18
    54d4:	93 2b       	or	r25, r19
    54d6:	a4 2b       	or	r26, r20
    54d8:	b5 2b       	or	r27, r21
    54da:	ec 81       	ldd	r30, Y+4	; 0x04
    54dc:	fd 81       	ldd	r31, Y+5	; 0x05
    54de:	81 a7       	std	Z+41, r24	; 0x29
    54e0:	92 a7       	std	Z+42, r25	; 0x2a
    54e2:	a3 a7       	std	Z+43, r26	; 0x2b
    54e4:	b4 a7       	std	Z+44, r27	; 0x2c
    54e6:	2a c0       	rjmp	.+84     	; 0x553c <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    54e8:	ec 81       	ldd	r30, Y+4	; 0x04
    54ea:	fd 81       	ldd	r31, Y+5	; 0x05
    54ec:	81 a5       	ldd	r24, Z+41	; 0x29
    54ee:	92 a5       	ldd	r25, Z+42	; 0x2a
    54f0:	a3 a5       	ldd	r26, Z+43	; 0x2b
    54f2:	b4 a5       	ldd	r27, Z+44	; 0x2c
    54f4:	01 96       	adiw	r24, 0x01	; 1
    54f6:	a1 1d       	adc	r26, r1
    54f8:	b1 1d       	adc	r27, r1
    54fa:	ec 81       	ldd	r30, Y+4	; 0x04
    54fc:	fd 81       	ldd	r31, Y+5	; 0x05
    54fe:	81 a7       	std	Z+41, r24	; 0x29
    5500:	92 a7       	std	Z+42, r25	; 0x2a
    5502:	a3 a7       	std	Z+43, r26	; 0x2b
    5504:	b4 a7       	std	Z+44, r27	; 0x2c
    5506:	1a c0       	rjmp	.+52     	; 0x553c <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    5508:	ec 81       	ldd	r30, Y+4	; 0x04
    550a:	fd 81       	ldd	r31, Y+5	; 0x05
    550c:	88 85       	ldd	r24, Y+8	; 0x08
    550e:	99 85       	ldd	r25, Y+9	; 0x09
    5510:	aa 85       	ldd	r26, Y+10	; 0x0a
    5512:	bb 85       	ldd	r27, Y+11	; 0x0b
    5514:	81 a7       	std	Z+41, r24	; 0x29
    5516:	92 a7       	std	Z+42, r25	; 0x2a
    5518:	a3 a7       	std	Z+43, r26	; 0x2b
    551a:	b4 a7       	std	Z+44, r27	; 0x2c
    551c:	0f c0       	rjmp	.+30     	; 0x553c <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    551e:	8b 81       	ldd	r24, Y+3	; 0x03
    5520:	82 30       	cpi	r24, 0x02	; 2
    5522:	59 f0       	breq	.+22     	; 0x553a <xTaskGenericNotifyFromISR+0x12c>
					{
						pxTCB->ulNotifiedValue = ulValue;
    5524:	ec 81       	ldd	r30, Y+4	; 0x04
    5526:	fd 81       	ldd	r31, Y+5	; 0x05
    5528:	88 85       	ldd	r24, Y+8	; 0x08
    552a:	99 85       	ldd	r25, Y+9	; 0x09
    552c:	aa 85       	ldd	r26, Y+10	; 0x0a
    552e:	bb 85       	ldd	r27, Y+11	; 0x0b
    5530:	81 a7       	std	Z+41, r24	; 0x29
    5532:	92 a7       	std	Z+42, r25	; 0x2a
    5534:	a3 a7       	std	Z+43, r26	; 0x2b
    5536:	b4 a7       	std	Z+44, r27	; 0x2c
    5538:	01 c0       	rjmp	.+2      	; 0x553c <xTaskGenericNotifyFromISR+0x12e>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    553a:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    553c:	8b 81       	ldd	r24, Y+3	; 0x03
    553e:	81 30       	cpi	r24, 0x01	; 1
    5540:	09 f0       	breq	.+2      	; 0x5544 <xTaskGenericNotifyFromISR+0x136>
    5542:	4f c0       	rjmp	.+158    	; 0x55e2 <xTaskGenericNotifyFromISR+0x1d4>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5544:	80 91 b0 06 	lds	r24, 0x06B0
    5548:	88 23       	and	r24, r24
    554a:	61 f5       	brne	.+88     	; 0x55a4 <xTaskGenericNotifyFromISR+0x196>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    554c:	8c 81       	ldd	r24, Y+4	; 0x04
    554e:	9d 81       	ldd	r25, Y+5	; 0x05
    5550:	02 96       	adiw	r24, 0x02	; 2
    5552:	0e 94 7f 0d 	call	0x1afe	; 0x1afe <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    5556:	ec 81       	ldd	r30, Y+4	; 0x04
    5558:	fd 81       	ldd	r31, Y+5	; 0x05
    555a:	96 89       	ldd	r25, Z+22	; 0x16
    555c:	80 91 a6 06 	lds	r24, 0x06A6
    5560:	89 17       	cp	r24, r25
    5562:	28 f4       	brcc	.+10     	; 0x556e <xTaskGenericNotifyFromISR+0x160>
    5564:	ec 81       	ldd	r30, Y+4	; 0x04
    5566:	fd 81       	ldd	r31, Y+5	; 0x05
    5568:	86 89       	ldd	r24, Z+22	; 0x16
    556a:	80 93 a6 06 	sts	0x06A6, r24
    556e:	ec 81       	ldd	r30, Y+4	; 0x04
    5570:	fd 81       	ldd	r31, Y+5	; 0x05
    5572:	86 89       	ldd	r24, Z+22	; 0x16
    5574:	28 2f       	mov	r18, r24
    5576:	30 e0       	ldi	r19, 0x00	; 0
    5578:	c9 01       	movw	r24, r18
    557a:	88 0f       	add	r24, r24
    557c:	99 1f       	adc	r25, r25
    557e:	88 0f       	add	r24, r24
    5580:	99 1f       	adc	r25, r25
    5582:	88 0f       	add	r24, r24
    5584:	99 1f       	adc	r25, r25
    5586:	82 0f       	add	r24, r18
    5588:	93 1f       	adc	r25, r19
    558a:	ac 01       	movw	r20, r24
    558c:	4f 54       	subi	r20, 0x4F	; 79
    558e:	59 4f       	sbci	r21, 0xF9	; 249
    5590:	8c 81       	ldd	r24, Y+4	; 0x04
    5592:	9d 81       	ldd	r25, Y+5	; 0x05
    5594:	9c 01       	movw	r18, r24
    5596:	2e 5f       	subi	r18, 0xFE	; 254
    5598:	3f 4f       	sbci	r19, 0xFF	; 255
    559a:	ca 01       	movw	r24, r20
    559c:	b9 01       	movw	r22, r18
    559e:	0e 94 cf 0c 	call	0x199e	; 0x199e <vListInsertEnd>
    55a2:	0a c0       	rjmp	.+20     	; 0x55b8 <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    55a4:	8c 81       	ldd	r24, Y+4	; 0x04
    55a6:	9d 81       	ldd	r25, Y+5	; 0x05
    55a8:	9c 01       	movw	r18, r24
    55aa:	24 5f       	subi	r18, 0xF4	; 244
    55ac:	3f 4f       	sbci	r19, 0xFF	; 255
    55ae:	8b ee       	ldi	r24, 0xEB	; 235
    55b0:	96 e0       	ldi	r25, 0x06	; 6
    55b2:	b9 01       	movw	r22, r18
    55b4:	0e 94 cf 0c 	call	0x199e	; 0x199e <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    55b8:	ec 81       	ldd	r30, Y+4	; 0x04
    55ba:	fd 81       	ldd	r31, Y+5	; 0x05
    55bc:	96 89       	ldd	r25, Z+22	; 0x16
    55be:	e0 91 a0 06 	lds	r30, 0x06A0
    55c2:	f0 91 a1 06 	lds	r31, 0x06A1
    55c6:	86 89       	ldd	r24, Z+22	; 0x16
    55c8:	89 17       	cp	r24, r25
    55ca:	58 f4       	brcc	.+22     	; 0x55e2 <xTaskGenericNotifyFromISR+0x1d4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    55cc:	8f 85       	ldd	r24, Y+15	; 0x0f
    55ce:	98 89       	ldd	r25, Y+16	; 0x10
    55d0:	00 97       	sbiw	r24, 0x00	; 0
    55d2:	21 f0       	breq	.+8      	; 0x55dc <xTaskGenericNotifyFromISR+0x1ce>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    55d4:	ef 85       	ldd	r30, Y+15	; 0x0f
    55d6:	f8 89       	ldd	r31, Y+16	; 0x10
    55d8:	81 e0       	ldi	r24, 0x01	; 1
    55da:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    55dc:	81 e0       	ldi	r24, 0x01	; 1
    55de:	80 93 a9 06 	sts	0x06A9, r24
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    55e2:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    55e4:	62 96       	adiw	r28, 0x12	; 18
    55e6:	0f b6       	in	r0, 0x3f	; 63
    55e8:	f8 94       	cli
    55ea:	de bf       	out	0x3e, r29	; 62
    55ec:	0f be       	out	0x3f, r0	; 63
    55ee:	cd bf       	out	0x3d, r28	; 61
    55f0:	cf 91       	pop	r28
    55f2:	df 91       	pop	r29
    55f4:	1f 91       	pop	r17
    55f6:	0f 91       	pop	r16
    55f8:	ff 90       	pop	r15
    55fa:	ef 90       	pop	r14
    55fc:	08 95       	ret

000055fe <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    55fe:	df 93       	push	r29
    5600:	cf 93       	push	r28
    5602:	cd b7       	in	r28, 0x3d	; 61
    5604:	de b7       	in	r29, 0x3e	; 62
    5606:	28 97       	sbiw	r28, 0x08	; 8
    5608:	0f b6       	in	r0, 0x3f	; 63
    560a:	f8 94       	cli
    560c:	de bf       	out	0x3e, r29	; 62
    560e:	0f be       	out	0x3f, r0	; 63
    5610:	cd bf       	out	0x3d, r28	; 61
    5612:	9e 83       	std	Y+6, r25	; 0x06
    5614:	8d 83       	std	Y+5, r24	; 0x05
    5616:	78 87       	std	Y+8, r23	; 0x08
    5618:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    561a:	8d 81       	ldd	r24, Y+5	; 0x05
    561c:	9e 81       	ldd	r25, Y+6	; 0x06
    561e:	9c 83       	std	Y+4, r25	; 0x04
    5620:	8b 83       	std	Y+3, r24	; 0x03

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5622:	19 82       	std	Y+1, r1	; 0x01
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    5624:	eb 81       	ldd	r30, Y+3	; 0x03
    5626:	fc 81       	ldd	r31, Y+4	; 0x04
    5628:	85 a5       	ldd	r24, Z+45	; 0x2d
    562a:	8a 83       	std	Y+2, r24	; 0x02
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    562c:	eb 81       	ldd	r30, Y+3	; 0x03
    562e:	fc 81       	ldd	r31, Y+4	; 0x04
    5630:	82 e0       	ldi	r24, 0x02	; 2
    5632:	85 a7       	std	Z+45, r24	; 0x2d

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    5634:	eb 81       	ldd	r30, Y+3	; 0x03
    5636:	fc 81       	ldd	r31, Y+4	; 0x04
    5638:	81 a5       	ldd	r24, Z+41	; 0x29
    563a:	92 a5       	ldd	r25, Z+42	; 0x2a
    563c:	a3 a5       	ldd	r26, Z+43	; 0x2b
    563e:	b4 a5       	ldd	r27, Z+44	; 0x2c
    5640:	01 96       	adiw	r24, 0x01	; 1
    5642:	a1 1d       	adc	r26, r1
    5644:	b1 1d       	adc	r27, r1
    5646:	eb 81       	ldd	r30, Y+3	; 0x03
    5648:	fc 81       	ldd	r31, Y+4	; 0x04
    564a:	81 a7       	std	Z+41, r24	; 0x29
    564c:	92 a7       	std	Z+42, r25	; 0x2a
    564e:	a3 a7       	std	Z+43, r26	; 0x2b
    5650:	b4 a7       	std	Z+44, r27	; 0x2c

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5652:	8a 81       	ldd	r24, Y+2	; 0x02
    5654:	81 30       	cpi	r24, 0x01	; 1
    5656:	09 f0       	breq	.+2      	; 0x565a <vTaskNotifyGiveFromISR+0x5c>
    5658:	4f c0       	rjmp	.+158    	; 0x56f8 <vTaskNotifyGiveFromISR+0xfa>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    565a:	80 91 b0 06 	lds	r24, 0x06B0
    565e:	88 23       	and	r24, r24
    5660:	61 f5       	brne	.+88     	; 0x56ba <vTaskNotifyGiveFromISR+0xbc>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5662:	8b 81       	ldd	r24, Y+3	; 0x03
    5664:	9c 81       	ldd	r25, Y+4	; 0x04
    5666:	02 96       	adiw	r24, 0x02	; 2
    5668:	0e 94 7f 0d 	call	0x1afe	; 0x1afe <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    566c:	eb 81       	ldd	r30, Y+3	; 0x03
    566e:	fc 81       	ldd	r31, Y+4	; 0x04
    5670:	96 89       	ldd	r25, Z+22	; 0x16
    5672:	80 91 a6 06 	lds	r24, 0x06A6
    5676:	89 17       	cp	r24, r25
    5678:	28 f4       	brcc	.+10     	; 0x5684 <vTaskNotifyGiveFromISR+0x86>
    567a:	eb 81       	ldd	r30, Y+3	; 0x03
    567c:	fc 81       	ldd	r31, Y+4	; 0x04
    567e:	86 89       	ldd	r24, Z+22	; 0x16
    5680:	80 93 a6 06 	sts	0x06A6, r24
    5684:	eb 81       	ldd	r30, Y+3	; 0x03
    5686:	fc 81       	ldd	r31, Y+4	; 0x04
    5688:	86 89       	ldd	r24, Z+22	; 0x16
    568a:	28 2f       	mov	r18, r24
    568c:	30 e0       	ldi	r19, 0x00	; 0
    568e:	c9 01       	movw	r24, r18
    5690:	88 0f       	add	r24, r24
    5692:	99 1f       	adc	r25, r25
    5694:	88 0f       	add	r24, r24
    5696:	99 1f       	adc	r25, r25
    5698:	88 0f       	add	r24, r24
    569a:	99 1f       	adc	r25, r25
    569c:	82 0f       	add	r24, r18
    569e:	93 1f       	adc	r25, r19
    56a0:	ac 01       	movw	r20, r24
    56a2:	4f 54       	subi	r20, 0x4F	; 79
    56a4:	59 4f       	sbci	r21, 0xF9	; 249
    56a6:	8b 81       	ldd	r24, Y+3	; 0x03
    56a8:	9c 81       	ldd	r25, Y+4	; 0x04
    56aa:	9c 01       	movw	r18, r24
    56ac:	2e 5f       	subi	r18, 0xFE	; 254
    56ae:	3f 4f       	sbci	r19, 0xFF	; 255
    56b0:	ca 01       	movw	r24, r20
    56b2:	b9 01       	movw	r22, r18
    56b4:	0e 94 cf 0c 	call	0x199e	; 0x199e <vListInsertEnd>
    56b8:	0a c0       	rjmp	.+20     	; 0x56ce <vTaskNotifyGiveFromISR+0xd0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    56ba:	8b 81       	ldd	r24, Y+3	; 0x03
    56bc:	9c 81       	ldd	r25, Y+4	; 0x04
    56be:	9c 01       	movw	r18, r24
    56c0:	24 5f       	subi	r18, 0xF4	; 244
    56c2:	3f 4f       	sbci	r19, 0xFF	; 255
    56c4:	8b ee       	ldi	r24, 0xEB	; 235
    56c6:	96 e0       	ldi	r25, 0x06	; 6
    56c8:	b9 01       	movw	r22, r18
    56ca:	0e 94 cf 0c 	call	0x199e	; 0x199e <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    56ce:	eb 81       	ldd	r30, Y+3	; 0x03
    56d0:	fc 81       	ldd	r31, Y+4	; 0x04
    56d2:	96 89       	ldd	r25, Z+22	; 0x16
    56d4:	e0 91 a0 06 	lds	r30, 0x06A0
    56d8:	f0 91 a1 06 	lds	r31, 0x06A1
    56dc:	86 89       	ldd	r24, Z+22	; 0x16
    56de:	89 17       	cp	r24, r25
    56e0:	58 f4       	brcc	.+22     	; 0x56f8 <vTaskNotifyGiveFromISR+0xfa>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    56e2:	8f 81       	ldd	r24, Y+7	; 0x07
    56e4:	98 85       	ldd	r25, Y+8	; 0x08
    56e6:	00 97       	sbiw	r24, 0x00	; 0
    56e8:	21 f0       	breq	.+8      	; 0x56f2 <vTaskNotifyGiveFromISR+0xf4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    56ea:	ef 81       	ldd	r30, Y+7	; 0x07
    56ec:	f8 85       	ldd	r31, Y+8	; 0x08
    56ee:	81 e0       	ldi	r24, 0x01	; 1
    56f0:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    56f2:	81 e0       	ldi	r24, 0x01	; 1
    56f4:	80 93 a9 06 	sts	0x06A9, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    56f8:	28 96       	adiw	r28, 0x08	; 8
    56fa:	0f b6       	in	r0, 0x3f	; 63
    56fc:	f8 94       	cli
    56fe:	de bf       	out	0x3e, r29	; 62
    5700:	0f be       	out	0x3f, r0	; 63
    5702:	cd bf       	out	0x3d, r28	; 61
    5704:	cf 91       	pop	r28
    5706:	df 91       	pop	r29
    5708:	08 95       	ret

0000570a <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    570a:	df 93       	push	r29
    570c:	cf 93       	push	r28
    570e:	cd b7       	in	r28, 0x3d	; 61
    5710:	de b7       	in	r29, 0x3e	; 62
    5712:	27 97       	sbiw	r28, 0x07	; 7
    5714:	0f b6       	in	r0, 0x3f	; 63
    5716:	f8 94       	cli
    5718:	de bf       	out	0x3e, r29	; 62
    571a:	0f be       	out	0x3f, r0	; 63
    571c:	cd bf       	out	0x3d, r28	; 61
    571e:	9d 83       	std	Y+5, r25	; 0x05
    5720:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    5722:	8c 81       	ldd	r24, Y+4	; 0x04
    5724:	9d 81       	ldd	r25, Y+5	; 0x05
    5726:	00 97       	sbiw	r24, 0x00	; 0
    5728:	39 f4       	brne	.+14     	; 0x5738 <xTaskNotifyStateClear+0x2e>
    572a:	80 91 a0 06 	lds	r24, 0x06A0
    572e:	90 91 a1 06 	lds	r25, 0x06A1
    5732:	9f 83       	std	Y+7, r25	; 0x07
    5734:	8e 83       	std	Y+6, r24	; 0x06
    5736:	04 c0       	rjmp	.+8      	; 0x5740 <xTaskNotifyStateClear+0x36>
    5738:	8c 81       	ldd	r24, Y+4	; 0x04
    573a:	9d 81       	ldd	r25, Y+5	; 0x05
    573c:	9f 83       	std	Y+7, r25	; 0x07
    573e:	8e 83       	std	Y+6, r24	; 0x06
    5740:	8e 81       	ldd	r24, Y+6	; 0x06
    5742:	9f 81       	ldd	r25, Y+7	; 0x07
    5744:	9b 83       	std	Y+3, r25	; 0x03
    5746:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    5748:	0f b6       	in	r0, 0x3f	; 63
    574a:	f8 94       	cli
    574c:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    574e:	ea 81       	ldd	r30, Y+2	; 0x02
    5750:	fb 81       	ldd	r31, Y+3	; 0x03
    5752:	85 a5       	ldd	r24, Z+45	; 0x2d
    5754:	82 30       	cpi	r24, 0x02	; 2
    5756:	31 f4       	brne	.+12     	; 0x5764 <xTaskNotifyStateClear+0x5a>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    5758:	ea 81       	ldd	r30, Y+2	; 0x02
    575a:	fb 81       	ldd	r31, Y+3	; 0x03
    575c:	15 a6       	std	Z+45, r1	; 0x2d
				xReturn = pdPASS;
    575e:	81 e0       	ldi	r24, 0x01	; 1
    5760:	89 83       	std	Y+1, r24	; 0x01
    5762:	01 c0       	rjmp	.+2      	; 0x5766 <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
    5764:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    5766:	0f 90       	pop	r0
    5768:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    576a:	89 81       	ldd	r24, Y+1	; 0x01
	}
    576c:	27 96       	adiw	r28, 0x07	; 7
    576e:	0f b6       	in	r0, 0x3f	; 63
    5770:	f8 94       	cli
    5772:	de bf       	out	0x3e, r29	; 62
    5774:	0f be       	out	0x3f, r0	; 63
    5776:	cd bf       	out	0x3d, r28	; 61
    5778:	cf 91       	pop	r28
    577a:	df 91       	pop	r29
    577c:	08 95       	ret

0000577e <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    577e:	df 93       	push	r29
    5780:	cf 93       	push	r28
    5782:	cd b7       	in	r28, 0x3d	; 61
    5784:	de b7       	in	r29, 0x3e	; 62
    5786:	27 97       	sbiw	r28, 0x07	; 7
    5788:	0f b6       	in	r0, 0x3f	; 63
    578a:	f8 94       	cli
    578c:	de bf       	out	0x3e, r29	; 62
    578e:	0f be       	out	0x3f, r0	; 63
    5790:	cd bf       	out	0x3d, r28	; 61
    5792:	9e 83       	std	Y+6, r25	; 0x06
    5794:	8d 83       	std	Y+5, r24	; 0x05
    5796:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    5798:	80 91 a4 06 	lds	r24, 0x06A4
    579c:	90 91 a5 06 	lds	r25, 0x06A5
    57a0:	9a 83       	std	Y+2, r25	; 0x02
    57a2:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    57a4:	80 91 a0 06 	lds	r24, 0x06A0
    57a8:	90 91 a1 06 	lds	r25, 0x06A1
    57ac:	02 96       	adiw	r24, 0x02	; 2
    57ae:	0e 94 7f 0d 	call	0x1afe	; 0x1afe <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    57b2:	8d 81       	ldd	r24, Y+5	; 0x05
    57b4:	9e 81       	ldd	r25, Y+6	; 0x06
    57b6:	2f ef       	ldi	r18, 0xFF	; 255
    57b8:	8f 3f       	cpi	r24, 0xFF	; 255
    57ba:	92 07       	cpc	r25, r18
    57bc:	81 f4       	brne	.+32     	; 0x57de <prvAddCurrentTaskToDelayedList+0x60>
    57be:	8f 81       	ldd	r24, Y+7	; 0x07
    57c0:	88 23       	and	r24, r24
    57c2:	69 f0       	breq	.+26     	; 0x57de <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    57c4:	80 91 a0 06 	lds	r24, 0x06A0
    57c8:	90 91 a1 06 	lds	r25, 0x06A1
    57cc:	9c 01       	movw	r18, r24
    57ce:	2e 5f       	subi	r18, 0xFE	; 254
    57d0:	3f 4f       	sbci	r19, 0xFF	; 255
    57d2:	8d ef       	ldi	r24, 0xFD	; 253
    57d4:	96 e0       	ldi	r25, 0x06	; 6
    57d6:	b9 01       	movw	r22, r18
    57d8:	0e 94 cf 0c 	call	0x199e	; 0x199e <vListInsertEnd>
    57dc:	43 c0       	rjmp	.+134    	; 0x5864 <prvAddCurrentTaskToDelayedList+0xe6>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    57de:	29 81       	ldd	r18, Y+1	; 0x01
    57e0:	3a 81       	ldd	r19, Y+2	; 0x02
    57e2:	8d 81       	ldd	r24, Y+5	; 0x05
    57e4:	9e 81       	ldd	r25, Y+6	; 0x06
    57e6:	82 0f       	add	r24, r18
    57e8:	93 1f       	adc	r25, r19
    57ea:	9c 83       	std	Y+4, r25	; 0x04
    57ec:	8b 83       	std	Y+3, r24	; 0x03

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    57ee:	e0 91 a0 06 	lds	r30, 0x06A0
    57f2:	f0 91 a1 06 	lds	r31, 0x06A1
    57f6:	8b 81       	ldd	r24, Y+3	; 0x03
    57f8:	9c 81       	ldd	r25, Y+4	; 0x04
    57fa:	93 83       	std	Z+3, r25	; 0x03
    57fc:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xConstTickCount )
    57fe:	2b 81       	ldd	r18, Y+3	; 0x03
    5800:	3c 81       	ldd	r19, Y+4	; 0x04
    5802:	89 81       	ldd	r24, Y+1	; 0x01
    5804:	9a 81       	ldd	r25, Y+2	; 0x02
    5806:	28 17       	cp	r18, r24
    5808:	39 07       	cpc	r19, r25
    580a:	70 f4       	brcc	.+28     	; 0x5828 <prvAddCurrentTaskToDelayedList+0xaa>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    580c:	80 91 e9 06 	lds	r24, 0x06E9
    5810:	90 91 ea 06 	lds	r25, 0x06EA
    5814:	20 91 a0 06 	lds	r18, 0x06A0
    5818:	30 91 a1 06 	lds	r19, 0x06A1
    581c:	2e 5f       	subi	r18, 0xFE	; 254
    581e:	3f 4f       	sbci	r19, 0xFF	; 255
    5820:	b9 01       	movw	r22, r18
    5822:	0e 94 13 0d 	call	0x1a26	; 0x1a26 <vListInsert>
    5826:	1e c0       	rjmp	.+60     	; 0x5864 <prvAddCurrentTaskToDelayedList+0xe6>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5828:	40 91 e7 06 	lds	r20, 0x06E7
    582c:	50 91 e8 06 	lds	r21, 0x06E8
    5830:	80 91 a0 06 	lds	r24, 0x06A0
    5834:	90 91 a1 06 	lds	r25, 0x06A1
    5838:	9c 01       	movw	r18, r24
    583a:	2e 5f       	subi	r18, 0xFE	; 254
    583c:	3f 4f       	sbci	r19, 0xFF	; 255
    583e:	ca 01       	movw	r24, r20
    5840:	b9 01       	movw	r22, r18
    5842:	0e 94 13 0d 	call	0x1a26	; 0x1a26 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    5846:	20 91 ac 06 	lds	r18, 0x06AC
    584a:	30 91 ad 06 	lds	r19, 0x06AD
    584e:	8b 81       	ldd	r24, Y+3	; 0x03
    5850:	9c 81       	ldd	r25, Y+4	; 0x04
    5852:	82 17       	cp	r24, r18
    5854:	93 07       	cpc	r25, r19
    5856:	30 f4       	brcc	.+12     	; 0x5864 <prvAddCurrentTaskToDelayedList+0xe6>
				{
					xNextTaskUnblockTime = xTimeToWake;
    5858:	8b 81       	ldd	r24, Y+3	; 0x03
    585a:	9c 81       	ldd	r25, Y+4	; 0x04
    585c:	90 93 ad 06 	sts	0x06AD, r25
    5860:	80 93 ac 06 	sts	0x06AC, r24

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    5864:	27 96       	adiw	r28, 0x07	; 7
    5866:	0f b6       	in	r0, 0x3f	; 63
    5868:	f8 94       	cli
    586a:	de bf       	out	0x3e, r29	; 62
    586c:	0f be       	out	0x3f, r0	; 63
    586e:	cd bf       	out	0x3d, r28	; 61
    5870:	cf 91       	pop	r28
    5872:	df 91       	pop	r29
    5874:	08 95       	ret

00005876 <Led_Off>:

static uint8 led_Status = LED_OFF;


void Led_Off(uint8 Port_Num,uint8 Pin_Num)
{
    5876:	df 93       	push	r29
    5878:	cf 93       	push	r28
    587a:	00 d0       	rcall	.+0      	; 0x587c <Led_Off+0x6>
    587c:	cd b7       	in	r28, 0x3d	; 61
    587e:	de b7       	in	r29, 0x3e	; 62
    5880:	89 83       	std	Y+1, r24	; 0x01
    5882:	6a 83       	std	Y+2, r22	; 0x02

	DIO_write_pin_value(Port_Num,Pin_Num,0);
    5884:	89 81       	ldd	r24, Y+1	; 0x01
    5886:	6a 81       	ldd	r22, Y+2	; 0x02
    5888:	40 e0       	ldi	r20, 0x00	; 0
    588a:	0e 94 23 06 	call	0xc46	; 0xc46 <DIO_write_pin_value>
	led_Status = LED_OFF;
    588e:	10 92 06 07 	sts	0x0706, r1
}
    5892:	0f 90       	pop	r0
    5894:	0f 90       	pop	r0
    5896:	cf 91       	pop	r28
    5898:	df 91       	pop	r29
    589a:	08 95       	ret

0000589c <Led_On>:
void Led_On(uint8 Port_Num,uint8 Pin_Num)
{
    589c:	df 93       	push	r29
    589e:	cf 93       	push	r28
    58a0:	00 d0       	rcall	.+0      	; 0x58a2 <Led_On+0x6>
    58a2:	cd b7       	in	r28, 0x3d	; 61
    58a4:	de b7       	in	r29, 0x3e	; 62
    58a6:	89 83       	std	Y+1, r24	; 0x01
    58a8:	6a 83       	std	Y+2, r22	; 0x02

	DIO_write_pin_value(Port_Num,Pin_Num,1);
    58aa:	89 81       	ldd	r24, Y+1	; 0x01
    58ac:	6a 81       	ldd	r22, Y+2	; 0x02
    58ae:	41 e0       	ldi	r20, 0x01	; 1
    58b0:	0e 94 23 06 	call	0xc46	; 0xc46 <DIO_write_pin_value>
	led_Status = LED_ON;
    58b4:	81 e0       	ldi	r24, 0x01	; 1
    58b6:	80 93 06 07 	sts	0x0706, r24

}
    58ba:	0f 90       	pop	r0
    58bc:	0f 90       	pop	r0
    58be:	cf 91       	pop	r28
    58c0:	df 91       	pop	r29
    58c2:	08 95       	ret

000058c4 <Led_Toggle>:

void Led_Toggle(uint8 Port_Num,uint8 Pin_Num)
{
    58c4:	df 93       	push	r29
    58c6:	cf 93       	push	r28
    58c8:	00 d0       	rcall	.+0      	; 0x58ca <Led_Toggle+0x6>
    58ca:	cd b7       	in	r28, 0x3d	; 61
    58cc:	de b7       	in	r29, 0x3e	; 62
    58ce:	89 83       	std	Y+1, r24	; 0x01
    58d0:	6a 83       	std	Y+2, r22	; 0x02

	if(led_Status == LED_ON)
    58d2:	80 91 06 07 	lds	r24, 0x0706
    58d6:	81 30       	cpi	r24, 0x01	; 1
    58d8:	41 f4       	brne	.+16     	; 0x58ea <Led_Toggle+0x26>
	{
		DIO_write_pin_value(Port_Num,Pin_Num,0);
    58da:	89 81       	ldd	r24, Y+1	; 0x01
    58dc:	6a 81       	ldd	r22, Y+2	; 0x02
    58de:	40 e0       	ldi	r20, 0x00	; 0
    58e0:	0e 94 23 06 	call	0xc46	; 0xc46 <DIO_write_pin_value>
		led_Status = LED_OFF;
    58e4:	10 92 06 07 	sts	0x0706, r1
    58e8:	0c c0       	rjmp	.+24     	; 0x5902 <Led_Toggle+0x3e>

	}
	else if(led_Status == LED_OFF)
    58ea:	80 91 06 07 	lds	r24, 0x0706
    58ee:	88 23       	and	r24, r24
    58f0:	41 f4       	brne	.+16     	; 0x5902 <Led_Toggle+0x3e>
	{

		DIO_write_pin_value(Port_Num,Pin_Num,1);
    58f2:	89 81       	ldd	r24, Y+1	; 0x01
    58f4:	6a 81       	ldd	r22, Y+2	; 0x02
    58f6:	41 e0       	ldi	r20, 0x01	; 1
    58f8:	0e 94 23 06 	call	0xc46	; 0xc46 <DIO_write_pin_value>
		led_Status = LED_ON;
    58fc:	81 e0       	ldi	r24, 0x01	; 1
    58fe:	80 93 06 07 	sts	0x0706, r24

	}


}
    5902:	0f 90       	pop	r0
    5904:	0f 90       	pop	r0
    5906:	cf 91       	pop	r28
    5908:	df 91       	pop	r29
    590a:	08 95       	ret

0000590c <LCD_sendCommand>:




static uint8 LCD_sendCommand(uint8 LOC_Command)
{
    590c:	df 93       	push	r29
    590e:	cf 93       	push	r28
    5910:	00 d0       	rcall	.+0      	; 0x5912 <LCD_sendCommand+0x6>
    5912:	00 d0       	rcall	.+0      	; 0x5914 <LCD_sendCommand+0x8>
    5914:	00 d0       	rcall	.+0      	; 0x5916 <LCD_sendCommand+0xa>
    5916:	cd b7       	in	r28, 0x3d	; 61
    5918:	de b7       	in	r29, 0x3e	; 62
    591a:	8c 83       	std	Y+4, r24	; 0x04
	static uint8 LCD_state = SENDING_UPPER_FOUR_BITS;
	uint8 LOC_sendCommandFuncStatus;
	uint8 indx;
	uint8 bitValue=0;
    591c:	19 82       	std	Y+1, r1	; 0x01

	switch(LCD_state)
    591e:	80 91 af 00 	lds	r24, 0x00AF
    5922:	28 2f       	mov	r18, r24
    5924:	30 e0       	ldi	r19, 0x00	; 0
    5926:	3e 83       	std	Y+6, r19	; 0x06
    5928:	2d 83       	std	Y+5, r18	; 0x05
    592a:	4d 81       	ldd	r20, Y+5	; 0x05
    592c:	5e 81       	ldd	r21, Y+6	; 0x06
    592e:	42 30       	cpi	r20, 0x02	; 2
    5930:	51 05       	cpc	r21, r1
    5932:	09 f4       	brne	.+2      	; 0x5936 <LCD_sendCommand+0x2a>
    5934:	88 c0       	rjmp	.+272    	; 0x5a46 <LCD_sendCommand+0x13a>
    5936:	8d 81       	ldd	r24, Y+5	; 0x05
    5938:	9e 81       	ldd	r25, Y+6	; 0x06
    593a:	84 30       	cpi	r24, 0x04	; 4
    593c:	91 05       	cpc	r25, r1
    593e:	09 f4       	brne	.+2      	; 0x5942 <LCD_sendCommand+0x36>
    5940:	df c0       	rjmp	.+446    	; 0x5b00 <LCD_sendCommand+0x1f4>
    5942:	2d 81       	ldd	r18, Y+5	; 0x05
    5944:	3e 81       	ldd	r19, Y+6	; 0x06
    5946:	21 30       	cpi	r18, 0x01	; 1
    5948:	31 05       	cpc	r19, r1
    594a:	09 f0       	breq	.+2      	; 0x594e <LCD_sendCommand+0x42>
    594c:	de c0       	rjmp	.+444    	; 0x5b0a <LCD_sendCommand+0x1fe>
	{
	case SENDING_UPPER_FOUR_BITS:

		DIO_write_pin_value(LCD_ptrConfig->CTRL_port,LCD_ptrConfig->RS_pin,LOW);
    594e:	e0 91 bb 00 	lds	r30, 0x00BB
    5952:	f0 91 bc 00 	lds	r31, 0x00BC
    5956:	81 81       	ldd	r24, Z+1	; 0x01
    5958:	e0 91 bb 00 	lds	r30, 0x00BB
    595c:	f0 91 bc 00 	lds	r31, 0x00BC
    5960:	92 81       	ldd	r25, Z+2	; 0x02
    5962:	69 2f       	mov	r22, r25
    5964:	40 e0       	ldi	r20, 0x00	; 0
    5966:	0e 94 23 06 	call	0xc46	; 0xc46 <DIO_write_pin_value>
		DIO_write_pin_value(LCD_ptrConfig->CTRL_port,LCD_ptrConfig->RW_pin,LOW);
    596a:	e0 91 bb 00 	lds	r30, 0x00BB
    596e:	f0 91 bc 00 	lds	r31, 0x00BC
    5972:	81 81       	ldd	r24, Z+1	; 0x01
    5974:	e0 91 bb 00 	lds	r30, 0x00BB
    5978:	f0 91 bc 00 	lds	r31, 0x00BC
    597c:	93 81       	ldd	r25, Z+3	; 0x03
    597e:	69 2f       	mov	r22, r25
    5980:	40 e0       	ldi	r20, 0x00	; 0
    5982:	0e 94 23 06 	call	0xc46	; 0xc46 <DIO_write_pin_value>

		if(LCD_ptrConfig->mode == FOUR_BIT_MODE)
    5986:	e0 91 bb 00 	lds	r30, 0x00BB
    598a:	f0 91 bc 00 	lds	r31, 0x00BC
    598e:	80 81       	ld	r24, Z
    5990:	88 23       	and	r24, r24
    5992:	09 f0       	breq	.+2      	; 0x5996 <LCD_sendCommand+0x8a>
    5994:	48 c0       	rjmp	.+144    	; 0x5a26 <LCD_sendCommand+0x11a>
		{
			for(indx = 4 ; indx<8 ; indx++)
    5996:	84 e0       	ldi	r24, 0x04	; 4
    5998:	8a 83       	std	Y+2, r24	; 0x02
    599a:	25 c0       	rjmp	.+74     	; 0x59e6 <LCD_sendCommand+0xda>
			{
				bitValue = (LOC_Command>>indx)&(1u);
    599c:	8c 81       	ldd	r24, Y+4	; 0x04
    599e:	28 2f       	mov	r18, r24
    59a0:	30 e0       	ldi	r19, 0x00	; 0
    59a2:	8a 81       	ldd	r24, Y+2	; 0x02
    59a4:	88 2f       	mov	r24, r24
    59a6:	90 e0       	ldi	r25, 0x00	; 0
    59a8:	a9 01       	movw	r20, r18
    59aa:	02 c0       	rjmp	.+4      	; 0x59b0 <LCD_sendCommand+0xa4>
    59ac:	55 95       	asr	r21
    59ae:	47 95       	ror	r20
    59b0:	8a 95       	dec	r24
    59b2:	e2 f7       	brpl	.-8      	; 0x59ac <LCD_sendCommand+0xa0>
    59b4:	ca 01       	movw	r24, r20
    59b6:	81 70       	andi	r24, 0x01	; 1
    59b8:	89 83       	std	Y+1, r24	; 0x01
				DIO_write_pin_value(LCD_ptrConfig->DATA_port,(LCD_ptrConfig->DATA_startPin+indx-4),bitValue);
    59ba:	e0 91 bb 00 	lds	r30, 0x00BB
    59be:	f0 91 bc 00 	lds	r31, 0x00BC
    59c2:	25 81       	ldd	r18, Z+5	; 0x05
    59c4:	e0 91 bb 00 	lds	r30, 0x00BB
    59c8:	f0 91 bc 00 	lds	r31, 0x00BC
    59cc:	96 81       	ldd	r25, Z+6	; 0x06
    59ce:	8a 81       	ldd	r24, Y+2	; 0x02
    59d0:	89 0f       	add	r24, r25
    59d2:	98 2f       	mov	r25, r24
    59d4:	94 50       	subi	r25, 0x04	; 4
    59d6:	82 2f       	mov	r24, r18
    59d8:	69 2f       	mov	r22, r25
    59da:	49 81       	ldd	r20, Y+1	; 0x01
    59dc:	0e 94 23 06 	call	0xc46	; 0xc46 <DIO_write_pin_value>
		DIO_write_pin_value(LCD_ptrConfig->CTRL_port,LCD_ptrConfig->RS_pin,LOW);
		DIO_write_pin_value(LCD_ptrConfig->CTRL_port,LCD_ptrConfig->RW_pin,LOW);

		if(LCD_ptrConfig->mode == FOUR_BIT_MODE)
		{
			for(indx = 4 ; indx<8 ; indx++)
    59e0:	8a 81       	ldd	r24, Y+2	; 0x02
    59e2:	8f 5f       	subi	r24, 0xFF	; 255
    59e4:	8a 83       	std	Y+2, r24	; 0x02
    59e6:	8a 81       	ldd	r24, Y+2	; 0x02
    59e8:	88 30       	cpi	r24, 0x08	; 8
    59ea:	c0 f2       	brcs	.-80     	; 0x599c <LCD_sendCommand+0x90>
			{
				bitValue = (LOC_Command>>indx)&(1u);
				DIO_write_pin_value(LCD_ptrConfig->DATA_port,(LCD_ptrConfig->DATA_startPin+indx-4),bitValue);
			}
			DIO_write_pin_value(LCD_ptrConfig->CTRL_port,LCD_ptrConfig->En_pin,HIGH);
    59ec:	e0 91 bb 00 	lds	r30, 0x00BB
    59f0:	f0 91 bc 00 	lds	r31, 0x00BC
    59f4:	81 81       	ldd	r24, Z+1	; 0x01
    59f6:	e0 91 bb 00 	lds	r30, 0x00BB
    59fa:	f0 91 bc 00 	lds	r31, 0x00BC
    59fe:	94 81       	ldd	r25, Z+4	; 0x04
    5a00:	69 2f       	mov	r22, r25
    5a02:	41 e0       	ldi	r20, 0x01	; 1
    5a04:	0e 94 23 06 	call	0xc46	; 0xc46 <DIO_write_pin_value>
			DIO_write_pin_value(LCD_ptrConfig->CTRL_port,LCD_ptrConfig->En_pin,LOW);
    5a08:	e0 91 bb 00 	lds	r30, 0x00BB
    5a0c:	f0 91 bc 00 	lds	r31, 0x00BC
    5a10:	81 81       	ldd	r24, Z+1	; 0x01
    5a12:	e0 91 bb 00 	lds	r30, 0x00BB
    5a16:	f0 91 bc 00 	lds	r31, 0x00BC
    5a1a:	94 81       	ldd	r25, Z+4	; 0x04
    5a1c:	69 2f       	mov	r22, r25
    5a1e:	40 e0       	ldi	r20, 0x00	; 0
    5a20:	0e 94 23 06 	call	0xc46	; 0xc46 <DIO_write_pin_value>
    5a24:	09 c0       	rjmp	.+18     	; 0x5a38 <LCD_sendCommand+0x12c>
		}
		else if(LCD_ptrConfig->mode == EIGHT_BIT_MODE)
    5a26:	e0 91 bb 00 	lds	r30, 0x00BB
    5a2a:	f0 91 bc 00 	lds	r31, 0x00BC
    5a2e:	80 81       	ld	r24, Z
    5a30:	81 30       	cpi	r24, 0x01	; 1
    5a32:	11 f0       	breq	.+4      	; 0x5a38 <LCD_sendCommand+0x12c>
		{

		}
		else
		{
			LOC_sendCommandFuncStatus = LCD_wrongmode;
    5a34:	85 e0       	ldi	r24, 0x05	; 5
    5a36:	8b 83       	std	Y+3, r24	; 0x03
		}

		LCD_state = SENDING_LOWER_FOUR_BITS;
    5a38:	82 e0       	ldi	r24, 0x02	; 2
    5a3a:	80 93 af 00 	sts	0x00AF, r24
		LOC_sendCommandFuncStatus = LCD_state;
    5a3e:	80 91 af 00 	lds	r24, 0x00AF
    5a42:	8b 83       	std	Y+3, r24	; 0x03
    5a44:	62 c0       	rjmp	.+196    	; 0x5b0a <LCD_sendCommand+0x1fe>
		break;

	case SENDING_LOWER_FOUR_BITS:
		if(LCD_ptrConfig->mode == FOUR_BIT_MODE)
    5a46:	e0 91 bb 00 	lds	r30, 0x00BB
    5a4a:	f0 91 bc 00 	lds	r31, 0x00BC
    5a4e:	80 81       	ld	r24, Z
    5a50:	88 23       	and	r24, r24
    5a52:	09 f0       	breq	.+2      	; 0x5a56 <LCD_sendCommand+0x14a>
    5a54:	45 c0       	rjmp	.+138    	; 0x5ae0 <LCD_sendCommand+0x1d4>
		{
			for(indx = 0 ; indx<4 ; indx++)
    5a56:	1a 82       	std	Y+2, r1	; 0x02
    5a58:	23 c0       	rjmp	.+70     	; 0x5aa0 <LCD_sendCommand+0x194>
			{
				bitValue = (LOC_Command>>indx)&(1u);
    5a5a:	8c 81       	ldd	r24, Y+4	; 0x04
    5a5c:	28 2f       	mov	r18, r24
    5a5e:	30 e0       	ldi	r19, 0x00	; 0
    5a60:	8a 81       	ldd	r24, Y+2	; 0x02
    5a62:	88 2f       	mov	r24, r24
    5a64:	90 e0       	ldi	r25, 0x00	; 0
    5a66:	a9 01       	movw	r20, r18
    5a68:	02 c0       	rjmp	.+4      	; 0x5a6e <LCD_sendCommand+0x162>
    5a6a:	55 95       	asr	r21
    5a6c:	47 95       	ror	r20
    5a6e:	8a 95       	dec	r24
    5a70:	e2 f7       	brpl	.-8      	; 0x5a6a <LCD_sendCommand+0x15e>
    5a72:	ca 01       	movw	r24, r20
    5a74:	81 70       	andi	r24, 0x01	; 1
    5a76:	89 83       	std	Y+1, r24	; 0x01
				DIO_write_pin_value(LCD_ptrConfig->DATA_port,(LCD_ptrConfig->DATA_startPin+indx),bitValue);
    5a78:	e0 91 bb 00 	lds	r30, 0x00BB
    5a7c:	f0 91 bc 00 	lds	r31, 0x00BC
    5a80:	25 81       	ldd	r18, Z+5	; 0x05
    5a82:	e0 91 bb 00 	lds	r30, 0x00BB
    5a86:	f0 91 bc 00 	lds	r31, 0x00BC
    5a8a:	96 81       	ldd	r25, Z+6	; 0x06
    5a8c:	8a 81       	ldd	r24, Y+2	; 0x02
    5a8e:	98 0f       	add	r25, r24
    5a90:	82 2f       	mov	r24, r18
    5a92:	69 2f       	mov	r22, r25
    5a94:	49 81       	ldd	r20, Y+1	; 0x01
    5a96:	0e 94 23 06 	call	0xc46	; 0xc46 <DIO_write_pin_value>
		break;

	case SENDING_LOWER_FOUR_BITS:
		if(LCD_ptrConfig->mode == FOUR_BIT_MODE)
		{
			for(indx = 0 ; indx<4 ; indx++)
    5a9a:	8a 81       	ldd	r24, Y+2	; 0x02
    5a9c:	8f 5f       	subi	r24, 0xFF	; 255
    5a9e:	8a 83       	std	Y+2, r24	; 0x02
    5aa0:	8a 81       	ldd	r24, Y+2	; 0x02
    5aa2:	84 30       	cpi	r24, 0x04	; 4
    5aa4:	d0 f2       	brcs	.-76     	; 0x5a5a <LCD_sendCommand+0x14e>
			{
				bitValue = (LOC_Command>>indx)&(1u);
				DIO_write_pin_value(LCD_ptrConfig->DATA_port,(LCD_ptrConfig->DATA_startPin+indx),bitValue);
			}
			DIO_write_pin_value(LCD_ptrConfig->CTRL_port,LCD_ptrConfig->En_pin,HIGH);
    5aa6:	e0 91 bb 00 	lds	r30, 0x00BB
    5aaa:	f0 91 bc 00 	lds	r31, 0x00BC
    5aae:	81 81       	ldd	r24, Z+1	; 0x01
    5ab0:	e0 91 bb 00 	lds	r30, 0x00BB
    5ab4:	f0 91 bc 00 	lds	r31, 0x00BC
    5ab8:	94 81       	ldd	r25, Z+4	; 0x04
    5aba:	69 2f       	mov	r22, r25
    5abc:	41 e0       	ldi	r20, 0x01	; 1
    5abe:	0e 94 23 06 	call	0xc46	; 0xc46 <DIO_write_pin_value>
			DIO_write_pin_value(LCD_ptrConfig->CTRL_port,LCD_ptrConfig->En_pin,LOW);
    5ac2:	e0 91 bb 00 	lds	r30, 0x00BB
    5ac6:	f0 91 bc 00 	lds	r31, 0x00BC
    5aca:	81 81       	ldd	r24, Z+1	; 0x01
    5acc:	e0 91 bb 00 	lds	r30, 0x00BB
    5ad0:	f0 91 bc 00 	lds	r31, 0x00BC
    5ad4:	94 81       	ldd	r25, Z+4	; 0x04
    5ad6:	69 2f       	mov	r22, r25
    5ad8:	40 e0       	ldi	r20, 0x00	; 0
    5ada:	0e 94 23 06 	call	0xc46	; 0xc46 <DIO_write_pin_value>
    5ade:	09 c0       	rjmp	.+18     	; 0x5af2 <LCD_sendCommand+0x1e6>
		}
		else if(LCD_ptrConfig->mode == EIGHT_BIT_MODE)
    5ae0:	e0 91 bb 00 	lds	r30, 0x00BB
    5ae4:	f0 91 bc 00 	lds	r31, 0x00BC
    5ae8:	80 81       	ld	r24, Z
    5aea:	81 30       	cpi	r24, 0x01	; 1
    5aec:	11 f0       	breq	.+4      	; 0x5af2 <LCD_sendCommand+0x1e6>
		{

		}
		else
		{
			LOC_sendCommandFuncStatus = LCD_wrongmode;
    5aee:	85 e0       	ldi	r24, 0x05	; 5
    5af0:	8b 83       	std	Y+3, r24	; 0x03
		}
		LCD_state = LCD_WAITING;
    5af2:	84 e0       	ldi	r24, 0x04	; 4
    5af4:	80 93 af 00 	sts	0x00AF, r24
		LOC_sendCommandFuncStatus = LCD_state;
    5af8:	80 91 af 00 	lds	r24, 0x00AF
    5afc:	8b 83       	std	Y+3, r24	; 0x03
    5afe:	05 c0       	rjmp	.+10     	; 0x5b0a <LCD_sendCommand+0x1fe>

		break;
	case LCD_WAITING:
		LCD_state = SENDING_UPPER_FOUR_BITS;
    5b00:	81 e0       	ldi	r24, 0x01	; 1
    5b02:	80 93 af 00 	sts	0x00AF, r24
		LOC_sendCommandFuncStatus = LCD_DONE;
    5b06:	83 e0       	ldi	r24, 0x03	; 3
    5b08:	8b 83       	std	Y+3, r24	; 0x03

		_delay_us(1000);
	}*/


	return LOC_sendCommandFuncStatus;
    5b0a:	8b 81       	ldd	r24, Y+3	; 0x03
}
    5b0c:	26 96       	adiw	r28, 0x06	; 6
    5b0e:	0f b6       	in	r0, 0x3f	; 63
    5b10:	f8 94       	cli
    5b12:	de bf       	out	0x3e, r29	; 62
    5b14:	0f be       	out	0x3f, r0	; 63
    5b16:	cd bf       	out	0x3d, r28	; 61
    5b18:	cf 91       	pop	r28
    5b1a:	df 91       	pop	r29
    5b1c:	08 95       	ret

00005b1e <LCD_init>:


uint8 LCD_init(LCD_STconfig *COPY_LCD_ptrStrConfig)
{
    5b1e:	df 93       	push	r29
    5b20:	cf 93       	push	r28
    5b22:	00 d0       	rcall	.+0      	; 0x5b24 <LCD_init+0x6>
    5b24:	00 d0       	rcall	.+0      	; 0x5b26 <LCD_init+0x8>
    5b26:	0f 92       	push	r0
    5b28:	cd b7       	in	r28, 0x3d	; 61
    5b2a:	de b7       	in	r29, 0x3e	; 62
    5b2c:	9b 83       	std	Y+3, r25	; 0x03
    5b2e:	8a 83       	std	Y+2, r24	; 0x02
	uint8 LOC_initFuncStatus = LCD_WAITING;
    5b30:	84 e0       	ldi	r24, 0x04	; 4
    5b32:	89 83       	std	Y+1, r24	; 0x01
	static uint8 LCD_init_status = INIT_FIRST_FOURBIT_COMM;
	static uint8 commandStatus = LCD_WAITING;

	if(COPY_LCD_ptrStrConfig->mode == FOUR_BIT_MODE)
    5b34:	ea 81       	ldd	r30, Y+2	; 0x02
    5b36:	fb 81       	ldd	r31, Y+3	; 0x03
    5b38:	80 81       	ld	r24, Z
    5b3a:	88 23       	and	r24, r24
    5b3c:	59 f5       	brne	.+86     	; 0x5b94 <LCD_init+0x76>
	{
		switch(LCD_init_status)
    5b3e:	80 91 b1 00 	lds	r24, 0x00B1
    5b42:	28 2f       	mov	r18, r24
    5b44:	30 e0       	ldi	r19, 0x00	; 0
    5b46:	3d 83       	std	Y+5, r19	; 0x05
    5b48:	2c 83       	std	Y+4, r18	; 0x04
    5b4a:	8c 81       	ldd	r24, Y+4	; 0x04
    5b4c:	9d 81       	ldd	r25, Y+5	; 0x05
    5b4e:	86 30       	cpi	r24, 0x06	; 6
    5b50:	91 05       	cpc	r25, r1
    5b52:	31 f0       	breq	.+12     	; 0x5b60 <LCD_init+0x42>
    5b54:	2c 81       	ldd	r18, Y+4	; 0x04
    5b56:	3d 81       	ldd	r19, Y+5	; 0x05
    5b58:	27 30       	cpi	r18, 0x07	; 7
    5b5a:	31 05       	cpc	r19, r1
    5b5c:	71 f0       	breq	.+28     	; 0x5b7a <LCD_init+0x5c>
    5b5e:	21 c0       	rjmp	.+66     	; 0x5ba2 <LCD_init+0x84>
		{
		case INIT_FIRST_FOURBIT_COMM:

			commandStatus = LCD_sendCommand(FOUR_BIT_COMMAND);
    5b60:	82 e0       	ldi	r24, 0x02	; 2
    5b62:	0e 94 86 2c 	call	0x590c	; 0x590c <LCD_sendCommand>
    5b66:	80 93 b0 00 	sts	0x00B0, r24
			if(commandStatus == LCD_DONE)
    5b6a:	80 91 b0 00 	lds	r24, 0x00B0
    5b6e:	83 30       	cpi	r24, 0x03	; 3
    5b70:	c1 f4       	brne	.+48     	; 0x5ba2 <LCD_init+0x84>
			{
				LCD_init_status = INIT_SECOND_FOURBIT_COMM;
    5b72:	87 e0       	ldi	r24, 0x07	; 7
    5b74:	80 93 b1 00 	sts	0x00B1, r24
    5b78:	14 c0       	rjmp	.+40     	; 0x5ba2 <LCD_init+0x84>
			}
			break;
		case INIT_SECOND_FOURBIT_COMM:

			commandStatus = LCD_sendCommand(TWO_LINE_LCD_Four_BIT_MODE);
    5b7a:	88 e2       	ldi	r24, 0x28	; 40
    5b7c:	0e 94 86 2c 	call	0x590c	; 0x590c <LCD_sendCommand>
    5b80:	80 93 b0 00 	sts	0x00B0, r24
			if(commandStatus == LCD_DONE)
    5b84:	80 91 b0 00 	lds	r24, 0x00B0
    5b88:	83 30       	cpi	r24, 0x03	; 3
    5b8a:	59 f4       	brne	.+22     	; 0x5ba2 <LCD_init+0x84>
			{
				LCD_init_status = INIT_CURSOR_OFF_COMMAND;
    5b8c:	8a e0       	ldi	r24, 0x0A	; 10
    5b8e:	80 93 b1 00 	sts	0x00B1, r24
    5b92:	07 c0       	rjmp	.+14     	; 0x5ba2 <LCD_init+0x84>
			}
			break;
		}

	}
	else if(COPY_LCD_ptrStrConfig->mode == EIGHT_BIT_MODE)
    5b94:	ea 81       	ldd	r30, Y+2	; 0x02
    5b96:	fb 81       	ldd	r31, Y+3	; 0x03
    5b98:	80 81       	ld	r24, Z
    5b9a:	81 30       	cpi	r24, 0x01	; 1
    5b9c:	11 f0       	breq	.+4      	; 0x5ba2 <LCD_init+0x84>
	{
		//LCD_sendCommand(TWO_LINE_LCD_Eight_BIT_MODE);
	}
	else
	{
		LOC_initFuncStatus = LCD_wrongmode;
    5b9e:	85 e0       	ldi	r24, 0x05	; 5
    5ba0:	89 83       	std	Y+1, r24	; 0x01
	}

	if(LCD_init_status == INIT_CURSOR_OFF_COMMAND)
    5ba2:	80 91 b1 00 	lds	r24, 0x00B1
    5ba6:	8a 30       	cpi	r24, 0x0A	; 10
    5ba8:	79 f4       	brne	.+30     	; 0x5bc8 <LCD_init+0xaa>
	{
		commandStatus = LCD_sendCommand(CURSOR_OFF);
    5baa:	8c e0       	ldi	r24, 0x0C	; 12
    5bac:	0e 94 86 2c 	call	0x590c	; 0x590c <LCD_sendCommand>
    5bb0:	80 93 b0 00 	sts	0x00B0, r24
		if(commandStatus == LCD_DONE)
    5bb4:	80 91 b0 00 	lds	r24, 0x00B0
    5bb8:	83 30       	cpi	r24, 0x03	; 3
    5bba:	c1 f4       	brne	.+48     	; 0x5bec <LCD_init+0xce>
		{
			LOC_initFuncStatus = INIT_CLEAR_COMM;
    5bbc:	89 e0       	ldi	r24, 0x09	; 9
    5bbe:	89 83       	std	Y+1, r24	; 0x01
			LCD_init_status = INIT_CLEAR_COMM;
    5bc0:	89 e0       	ldi	r24, 0x09	; 9
    5bc2:	80 93 b1 00 	sts	0x00B1, r24
    5bc6:	12 c0       	rjmp	.+36     	; 0x5bec <LCD_init+0xce>
		}
	}
	else if(LCD_init_status == INIT_CLEAR_COMM)
    5bc8:	80 91 b1 00 	lds	r24, 0x00B1
    5bcc:	89 30       	cpi	r24, 0x09	; 9
    5bce:	71 f4       	brne	.+28     	; 0x5bec <LCD_init+0xce>
	{
		commandStatus = LCD_sendCommand(CLEAR_COMMAND);
    5bd0:	81 e0       	ldi	r24, 0x01	; 1
    5bd2:	0e 94 86 2c 	call	0x590c	; 0x590c <LCD_sendCommand>
    5bd6:	80 93 b0 00 	sts	0x00B0, r24
		if(commandStatus == LCD_DONE)
    5bda:	80 91 b0 00 	lds	r24, 0x00B0
    5bde:	83 30       	cpi	r24, 0x03	; 3
    5be0:	29 f4       	brne	.+10     	; 0x5bec <LCD_init+0xce>
		{
			LOC_initFuncStatus = LCD_DONE;
    5be2:	83 e0       	ldi	r24, 0x03	; 3
    5be4:	89 83       	std	Y+1, r24	; 0x01
			LCD_init_status = INIT_FIRST_FOURBIT_COMM;
    5be6:	86 e0       	ldi	r24, 0x06	; 6
    5be8:	80 93 b1 00 	sts	0x00B1, r24
		}
	}

	return LOC_initFuncStatus;
    5bec:	89 81       	ldd	r24, Y+1	; 0x01
}
    5bee:	0f 90       	pop	r0
    5bf0:	0f 90       	pop	r0
    5bf2:	0f 90       	pop	r0
    5bf4:	0f 90       	pop	r0
    5bf6:	0f 90       	pop	r0
    5bf8:	cf 91       	pop	r28
    5bfa:	df 91       	pop	r29
    5bfc:	08 95       	ret

00005bfe <LCD_displayChar>:



uint8 LCD_displayChar (uint8 LOC_Data)
{
    5bfe:	df 93       	push	r29
    5c00:	cf 93       	push	r28
    5c02:	00 d0       	rcall	.+0      	; 0x5c04 <LCD_displayChar+0x6>
    5c04:	00 d0       	rcall	.+0      	; 0x5c06 <LCD_displayChar+0x8>
    5c06:	00 d0       	rcall	.+0      	; 0x5c08 <LCD_displayChar+0xa>
    5c08:	cd b7       	in	r28, 0x3d	; 61
    5c0a:	de b7       	in	r29, 0x3e	; 62
    5c0c:	8c 83       	std	Y+4, r24	; 0x04
	uint8 LOC_dispCharFuncStatus;
	static uint8 LCD_state = SENDING_UPPER_FOUR_BITS;
	uint8 indx;
	uint8 bitValue=0;
    5c0e:	19 82       	std	Y+1, r1	; 0x01

	switch(LCD_state)
    5c10:	80 91 b2 00 	lds	r24, 0x00B2
    5c14:	28 2f       	mov	r18, r24
    5c16:	30 e0       	ldi	r19, 0x00	; 0
    5c18:	3e 83       	std	Y+6, r19	; 0x06
    5c1a:	2d 83       	std	Y+5, r18	; 0x05
    5c1c:	4d 81       	ldd	r20, Y+5	; 0x05
    5c1e:	5e 81       	ldd	r21, Y+6	; 0x06
    5c20:	42 30       	cpi	r20, 0x02	; 2
    5c22:	51 05       	cpc	r21, r1
    5c24:	09 f4       	brne	.+2      	; 0x5c28 <LCD_displayChar+0x2a>
    5c26:	79 c0       	rjmp	.+242    	; 0x5d1a <LCD_displayChar+0x11c>
    5c28:	8d 81       	ldd	r24, Y+5	; 0x05
    5c2a:	9e 81       	ldd	r25, Y+6	; 0x06
    5c2c:	84 30       	cpi	r24, 0x04	; 4
    5c2e:	91 05       	cpc	r25, r1
    5c30:	09 f4       	brne	.+2      	; 0x5c34 <LCD_displayChar+0x36>
    5c32:	de c0       	rjmp	.+444    	; 0x5df0 <LCD_displayChar+0x1f2>
    5c34:	2d 81       	ldd	r18, Y+5	; 0x05
    5c36:	3e 81       	ldd	r19, Y+6	; 0x06
    5c38:	21 30       	cpi	r18, 0x01	; 1
    5c3a:	31 05       	cpc	r19, r1
    5c3c:	09 f0       	breq	.+2      	; 0x5c40 <LCD_displayChar+0x42>
    5c3e:	dd c0       	rjmp	.+442    	; 0x5dfa <LCD_displayChar+0x1fc>
	{
	case SENDING_UPPER_FOUR_BITS:

		DIO_write_pin_value(LCD_ptrConfig->CTRL_port,LCD_ptrConfig->RS_pin,HIGH);
    5c40:	e0 91 bb 00 	lds	r30, 0x00BB
    5c44:	f0 91 bc 00 	lds	r31, 0x00BC
    5c48:	81 81       	ldd	r24, Z+1	; 0x01
    5c4a:	e0 91 bb 00 	lds	r30, 0x00BB
    5c4e:	f0 91 bc 00 	lds	r31, 0x00BC
    5c52:	92 81       	ldd	r25, Z+2	; 0x02
    5c54:	69 2f       	mov	r22, r25
    5c56:	41 e0       	ldi	r20, 0x01	; 1
    5c58:	0e 94 23 06 	call	0xc46	; 0xc46 <DIO_write_pin_value>
		DIO_write_pin_value(LCD_ptrConfig->CTRL_port,LCD_ptrConfig->RW_pin,LOW);
    5c5c:	e0 91 bb 00 	lds	r30, 0x00BB
    5c60:	f0 91 bc 00 	lds	r31, 0x00BC
    5c64:	81 81       	ldd	r24, Z+1	; 0x01
    5c66:	e0 91 bb 00 	lds	r30, 0x00BB
    5c6a:	f0 91 bc 00 	lds	r31, 0x00BC
    5c6e:	93 81       	ldd	r25, Z+3	; 0x03
    5c70:	69 2f       	mov	r22, r25
    5c72:	40 e0       	ldi	r20, 0x00	; 0
    5c74:	0e 94 23 06 	call	0xc46	; 0xc46 <DIO_write_pin_value>

		if(LCD_ptrConfig->mode == FOUR_BIT_MODE)
    5c78:	e0 91 bb 00 	lds	r30, 0x00BB
    5c7c:	f0 91 bc 00 	lds	r31, 0x00BC
    5c80:	80 81       	ld	r24, Z
    5c82:	88 23       	and	r24, r24
    5c84:	d1 f5       	brne	.+116    	; 0x5cfa <LCD_displayChar+0xfc>
		{
			for(indx = 4 ; indx<8 ; indx++)
    5c86:	84 e0       	ldi	r24, 0x04	; 4
    5c88:	8a 83       	std	Y+2, r24	; 0x02
    5c8a:	25 c0       	rjmp	.+74     	; 0x5cd6 <LCD_displayChar+0xd8>
			{
				bitValue = (LOC_Data>>indx)&(1u);
    5c8c:	8c 81       	ldd	r24, Y+4	; 0x04
    5c8e:	28 2f       	mov	r18, r24
    5c90:	30 e0       	ldi	r19, 0x00	; 0
    5c92:	8a 81       	ldd	r24, Y+2	; 0x02
    5c94:	88 2f       	mov	r24, r24
    5c96:	90 e0       	ldi	r25, 0x00	; 0
    5c98:	a9 01       	movw	r20, r18
    5c9a:	02 c0       	rjmp	.+4      	; 0x5ca0 <LCD_displayChar+0xa2>
    5c9c:	55 95       	asr	r21
    5c9e:	47 95       	ror	r20
    5ca0:	8a 95       	dec	r24
    5ca2:	e2 f7       	brpl	.-8      	; 0x5c9c <LCD_displayChar+0x9e>
    5ca4:	ca 01       	movw	r24, r20
    5ca6:	81 70       	andi	r24, 0x01	; 1
    5ca8:	89 83       	std	Y+1, r24	; 0x01
				DIO_write_pin_value(LCD_ptrConfig->DATA_port,(LCD_ptrConfig->DATA_startPin+indx-4),bitValue);
    5caa:	e0 91 bb 00 	lds	r30, 0x00BB
    5cae:	f0 91 bc 00 	lds	r31, 0x00BC
    5cb2:	25 81       	ldd	r18, Z+5	; 0x05
    5cb4:	e0 91 bb 00 	lds	r30, 0x00BB
    5cb8:	f0 91 bc 00 	lds	r31, 0x00BC
    5cbc:	96 81       	ldd	r25, Z+6	; 0x06
    5cbe:	8a 81       	ldd	r24, Y+2	; 0x02
    5cc0:	89 0f       	add	r24, r25
    5cc2:	98 2f       	mov	r25, r24
    5cc4:	94 50       	subi	r25, 0x04	; 4
    5cc6:	82 2f       	mov	r24, r18
    5cc8:	69 2f       	mov	r22, r25
    5cca:	49 81       	ldd	r20, Y+1	; 0x01
    5ccc:	0e 94 23 06 	call	0xc46	; 0xc46 <DIO_write_pin_value>
		DIO_write_pin_value(LCD_ptrConfig->CTRL_port,LCD_ptrConfig->RS_pin,HIGH);
		DIO_write_pin_value(LCD_ptrConfig->CTRL_port,LCD_ptrConfig->RW_pin,LOW);

		if(LCD_ptrConfig->mode == FOUR_BIT_MODE)
		{
			for(indx = 4 ; indx<8 ; indx++)
    5cd0:	8a 81       	ldd	r24, Y+2	; 0x02
    5cd2:	8f 5f       	subi	r24, 0xFF	; 255
    5cd4:	8a 83       	std	Y+2, r24	; 0x02
    5cd6:	8a 81       	ldd	r24, Y+2	; 0x02
    5cd8:	88 30       	cpi	r24, 0x08	; 8
    5cda:	c0 f2       	brcs	.-80     	; 0x5c8c <LCD_displayChar+0x8e>
			{
				bitValue = (LOC_Data>>indx)&(1u);
				DIO_write_pin_value(LCD_ptrConfig->DATA_port,(LCD_ptrConfig->DATA_startPin+indx-4),bitValue);
			}

			DIO_write_pin_value(LCD_ptrConfig->CTRL_port,LCD_ptrConfig->En_pin,HIGH);
    5cdc:	e0 91 bb 00 	lds	r30, 0x00BB
    5ce0:	f0 91 bc 00 	lds	r31, 0x00BC
    5ce4:	81 81       	ldd	r24, Z+1	; 0x01
    5ce6:	e0 91 bb 00 	lds	r30, 0x00BB
    5cea:	f0 91 bc 00 	lds	r31, 0x00BC
    5cee:	94 81       	ldd	r25, Z+4	; 0x04
    5cf0:	69 2f       	mov	r22, r25
    5cf2:	41 e0       	ldi	r20, 0x01	; 1
    5cf4:	0e 94 23 06 	call	0xc46	; 0xc46 <DIO_write_pin_value>
    5cf8:	09 c0       	rjmp	.+18     	; 0x5d0c <LCD_displayChar+0x10e>
		}
		else if(LCD_ptrConfig->mode == EIGHT_BIT_MODE)
    5cfa:	e0 91 bb 00 	lds	r30, 0x00BB
    5cfe:	f0 91 bc 00 	lds	r31, 0x00BC
    5d02:	80 81       	ld	r24, Z
    5d04:	81 30       	cpi	r24, 0x01	; 1
    5d06:	11 f0       	breq	.+4      	; 0x5d0c <LCD_displayChar+0x10e>
		{

		}
		else
		{
			LOC_dispCharFuncStatus = LCD_wrongmode;
    5d08:	85 e0       	ldi	r24, 0x05	; 5
    5d0a:	8b 83       	std	Y+3, r24	; 0x03
		}


		LCD_state = SENDING_LOWER_FOUR_BITS;
    5d0c:	82 e0       	ldi	r24, 0x02	; 2
    5d0e:	80 93 b2 00 	sts	0x00B2, r24
		LOC_dispCharFuncStatus = LCD_state;
    5d12:	80 91 b2 00 	lds	r24, 0x00B2
    5d16:	8b 83       	std	Y+3, r24	; 0x03
    5d18:	70 c0       	rjmp	.+224    	; 0x5dfa <LCD_displayChar+0x1fc>
		break;
	case SENDING_LOWER_FOUR_BITS:

		if(LCD_ptrConfig->mode == FOUR_BIT_MODE)
    5d1a:	e0 91 bb 00 	lds	r30, 0x00BB
    5d1e:	f0 91 bc 00 	lds	r31, 0x00BC
    5d22:	80 81       	ld	r24, Z
    5d24:	88 23       	and	r24, r24
    5d26:	09 f0       	breq	.+2      	; 0x5d2a <LCD_displayChar+0x12c>
    5d28:	53 c0       	rjmp	.+166    	; 0x5dd0 <LCD_displayChar+0x1d2>
		{
			DIO_write_pin_value(LCD_ptrConfig->CTRL_port,LCD_ptrConfig->En_pin,LOW);
    5d2a:	e0 91 bb 00 	lds	r30, 0x00BB
    5d2e:	f0 91 bc 00 	lds	r31, 0x00BC
    5d32:	81 81       	ldd	r24, Z+1	; 0x01
    5d34:	e0 91 bb 00 	lds	r30, 0x00BB
    5d38:	f0 91 bc 00 	lds	r31, 0x00BC
    5d3c:	94 81       	ldd	r25, Z+4	; 0x04
    5d3e:	69 2f       	mov	r22, r25
    5d40:	40 e0       	ldi	r20, 0x00	; 0
    5d42:	0e 94 23 06 	call	0xc46	; 0xc46 <DIO_write_pin_value>
			for(indx = 0 ; indx<4 ; indx++)
    5d46:	1a 82       	std	Y+2, r1	; 0x02
    5d48:	23 c0       	rjmp	.+70     	; 0x5d90 <LCD_displayChar+0x192>
			{
				bitValue = (LOC_Data>>indx)&(1u);
    5d4a:	8c 81       	ldd	r24, Y+4	; 0x04
    5d4c:	28 2f       	mov	r18, r24
    5d4e:	30 e0       	ldi	r19, 0x00	; 0
    5d50:	8a 81       	ldd	r24, Y+2	; 0x02
    5d52:	88 2f       	mov	r24, r24
    5d54:	90 e0       	ldi	r25, 0x00	; 0
    5d56:	a9 01       	movw	r20, r18
    5d58:	02 c0       	rjmp	.+4      	; 0x5d5e <LCD_displayChar+0x160>
    5d5a:	55 95       	asr	r21
    5d5c:	47 95       	ror	r20
    5d5e:	8a 95       	dec	r24
    5d60:	e2 f7       	brpl	.-8      	; 0x5d5a <LCD_displayChar+0x15c>
    5d62:	ca 01       	movw	r24, r20
    5d64:	81 70       	andi	r24, 0x01	; 1
    5d66:	89 83       	std	Y+1, r24	; 0x01
				DIO_write_pin_value(LCD_ptrConfig->DATA_port,(LCD_ptrConfig->DATA_startPin+indx),bitValue);
    5d68:	e0 91 bb 00 	lds	r30, 0x00BB
    5d6c:	f0 91 bc 00 	lds	r31, 0x00BC
    5d70:	25 81       	ldd	r18, Z+5	; 0x05
    5d72:	e0 91 bb 00 	lds	r30, 0x00BB
    5d76:	f0 91 bc 00 	lds	r31, 0x00BC
    5d7a:	96 81       	ldd	r25, Z+6	; 0x06
    5d7c:	8a 81       	ldd	r24, Y+2	; 0x02
    5d7e:	98 0f       	add	r25, r24
    5d80:	82 2f       	mov	r24, r18
    5d82:	69 2f       	mov	r22, r25
    5d84:	49 81       	ldd	r20, Y+1	; 0x01
    5d86:	0e 94 23 06 	call	0xc46	; 0xc46 <DIO_write_pin_value>
	case SENDING_LOWER_FOUR_BITS:

		if(LCD_ptrConfig->mode == FOUR_BIT_MODE)
		{
			DIO_write_pin_value(LCD_ptrConfig->CTRL_port,LCD_ptrConfig->En_pin,LOW);
			for(indx = 0 ; indx<4 ; indx++)
    5d8a:	8a 81       	ldd	r24, Y+2	; 0x02
    5d8c:	8f 5f       	subi	r24, 0xFF	; 255
    5d8e:	8a 83       	std	Y+2, r24	; 0x02
    5d90:	8a 81       	ldd	r24, Y+2	; 0x02
    5d92:	84 30       	cpi	r24, 0x04	; 4
    5d94:	d0 f2       	brcs	.-76     	; 0x5d4a <LCD_displayChar+0x14c>
			{
				bitValue = (LOC_Data>>indx)&(1u);
				DIO_write_pin_value(LCD_ptrConfig->DATA_port,(LCD_ptrConfig->DATA_startPin+indx),bitValue);
			}
			DIO_write_pin_value(LCD_ptrConfig->CTRL_port,LCD_ptrConfig->En_pin,HIGH);
    5d96:	e0 91 bb 00 	lds	r30, 0x00BB
    5d9a:	f0 91 bc 00 	lds	r31, 0x00BC
    5d9e:	81 81       	ldd	r24, Z+1	; 0x01
    5da0:	e0 91 bb 00 	lds	r30, 0x00BB
    5da4:	f0 91 bc 00 	lds	r31, 0x00BC
    5da8:	94 81       	ldd	r25, Z+4	; 0x04
    5daa:	69 2f       	mov	r22, r25
    5dac:	41 e0       	ldi	r20, 0x01	; 1
    5dae:	0e 94 23 06 	call	0xc46	; 0xc46 <DIO_write_pin_value>
			DIO_write_pin_value(LCD_ptrConfig->CTRL_port,LCD_ptrConfig->En_pin,LOW);
    5db2:	e0 91 bb 00 	lds	r30, 0x00BB
    5db6:	f0 91 bc 00 	lds	r31, 0x00BC
    5dba:	81 81       	ldd	r24, Z+1	; 0x01
    5dbc:	e0 91 bb 00 	lds	r30, 0x00BB
    5dc0:	f0 91 bc 00 	lds	r31, 0x00BC
    5dc4:	94 81       	ldd	r25, Z+4	; 0x04
    5dc6:	69 2f       	mov	r22, r25
    5dc8:	40 e0       	ldi	r20, 0x00	; 0
    5dca:	0e 94 23 06 	call	0xc46	; 0xc46 <DIO_write_pin_value>
    5dce:	09 c0       	rjmp	.+18     	; 0x5de2 <LCD_displayChar+0x1e4>
		}
		else if(LCD_ptrConfig->mode == EIGHT_BIT_MODE)
    5dd0:	e0 91 bb 00 	lds	r30, 0x00BB
    5dd4:	f0 91 bc 00 	lds	r31, 0x00BC
    5dd8:	80 81       	ld	r24, Z
    5dda:	81 30       	cpi	r24, 0x01	; 1
    5ddc:	11 f0       	breq	.+4      	; 0x5de2 <LCD_displayChar+0x1e4>
		{

		}
		else
		{
			LOC_dispCharFuncStatus = LCD_wrongmode;
    5dde:	85 e0       	ldi	r24, 0x05	; 5
    5de0:	8b 83       	std	Y+3, r24	; 0x03
		}

		LCD_state = LCD_WAITING;
    5de2:	84 e0       	ldi	r24, 0x04	; 4
    5de4:	80 93 b2 00 	sts	0x00B2, r24
		LOC_dispCharFuncStatus = LCD_state;
    5de8:	80 91 b2 00 	lds	r24, 0x00B2
    5dec:	8b 83       	std	Y+3, r24	; 0x03
    5dee:	05 c0       	rjmp	.+10     	; 0x5dfa <LCD_displayChar+0x1fc>
		break;
	case LCD_WAITING:
		LCD_state = SENDING_UPPER_FOUR_BITS;
    5df0:	81 e0       	ldi	r24, 0x01	; 1
    5df2:	80 93 b2 00 	sts	0x00B2, r24
		LOC_dispCharFuncStatus = LCD_DONE;
    5df6:	83 e0       	ldi	r24, 0x03	; 3
    5df8:	8b 83       	std	Y+3, r24	; 0x03

		_delay_us(1);
	}*/


	return LOC_dispCharFuncStatus;
    5dfa:	8b 81       	ldd	r24, Y+3	; 0x03
}
    5dfc:	26 96       	adiw	r28, 0x06	; 6
    5dfe:	0f b6       	in	r0, 0x3f	; 63
    5e00:	f8 94       	cli
    5e02:	de bf       	out	0x3e, r29	; 62
    5e04:	0f be       	out	0x3f, r0	; 63
    5e06:	cd bf       	out	0x3d, r28	; 61
    5e08:	cf 91       	pop	r28
    5e0a:	df 91       	pop	r29
    5e0c:	08 95       	ret

00005e0e <LCD_displayString>:

uint8 LCD_displayString (const uint8 *LOC_ptrString)
{
    5e0e:	df 93       	push	r29
    5e10:	cf 93       	push	r28
    5e12:	00 d0       	rcall	.+0      	; 0x5e14 <LCD_displayString+0x6>
    5e14:	00 d0       	rcall	.+0      	; 0x5e16 <LCD_displayString+0x8>
    5e16:	cd b7       	in	r28, 0x3d	; 61
    5e18:	de b7       	in	r29, 0x3e	; 62
    5e1a:	9c 83       	std	Y+4, r25	; 0x04
    5e1c:	8b 83       	std	Y+3, r24	; 0x03
	uint8 LOC_dispStr_FuncStatus= LCD_STR_NOT_COMPELET;
    5e1e:	8b e0       	ldi	r24, 0x0B	; 11
    5e20:	8a 83       	std	Y+2, r24	; 0x02
	uint8 Check_Char_Is_Done= LCD_WAITING;
    5e22:	84 e0       	ldi	r24, 0x04	; 4
    5e24:	89 83       	std	Y+1, r24	; 0x01
	static uint8 l_Str_Counter=0;
	static uint8 Check_Shift_Is_Done = LCD_WAITING;

	if(LOC_ptrString[l_Str_Counter]!='\0'){
    5e26:	80 91 07 07 	lds	r24, 0x0707
    5e2a:	28 2f       	mov	r18, r24
    5e2c:	30 e0       	ldi	r19, 0x00	; 0
    5e2e:	8b 81       	ldd	r24, Y+3	; 0x03
    5e30:	9c 81       	ldd	r25, Y+4	; 0x04
    5e32:	fc 01       	movw	r30, r24
    5e34:	e2 0f       	add	r30, r18
    5e36:	f3 1f       	adc	r31, r19
    5e38:	80 81       	ld	r24, Z
    5e3a:	88 23       	and	r24, r24
    5e3c:	41 f1       	breq	.+80     	; 0x5e8e <LCD_displayString+0x80>
		if((l_Str_Counter == 16) && (Check_Shift_Is_Done != LCD_DONE))
    5e3e:	80 91 07 07 	lds	r24, 0x0707
    5e42:	80 31       	cpi	r24, 0x10	; 16
    5e44:	59 f4       	brne	.+22     	; 0x5e5c <LCD_displayString+0x4e>
    5e46:	80 91 b3 00 	lds	r24, 0x00B3
    5e4a:	83 30       	cpi	r24, 0x03	; 3
    5e4c:	39 f0       	breq	.+14     	; 0x5e5c <LCD_displayString+0x4e>
		{
			Check_Shift_Is_Done = LCD_gotoRowColumn(1,0);
    5e4e:	81 e0       	ldi	r24, 0x01	; 1
    5e50:	60 e0       	ldi	r22, 0x00	; 0
    5e52:	0e 94 8a 2f 	call	0x5f14	; 0x5f14 <LCD_gotoRowColumn>
    5e56:	80 93 b3 00 	sts	0x00B3, r24
    5e5a:	29 c0       	rjmp	.+82     	; 0x5eae <LCD_displayString+0xa0>
		}
		else
		{
			Check_Char_Is_Done=LCD_displayChar(LOC_ptrString[l_Str_Counter]);
    5e5c:	80 91 07 07 	lds	r24, 0x0707
    5e60:	28 2f       	mov	r18, r24
    5e62:	30 e0       	ldi	r19, 0x00	; 0
    5e64:	8b 81       	ldd	r24, Y+3	; 0x03
    5e66:	9c 81       	ldd	r25, Y+4	; 0x04
    5e68:	fc 01       	movw	r30, r24
    5e6a:	e2 0f       	add	r30, r18
    5e6c:	f3 1f       	adc	r31, r19
    5e6e:	80 81       	ld	r24, Z
    5e70:	0e 94 ff 2d 	call	0x5bfe	; 0x5bfe <LCD_displayChar>
    5e74:	89 83       	std	Y+1, r24	; 0x01
			if(Check_Char_Is_Done==LCD_DONE){
    5e76:	89 81       	ldd	r24, Y+1	; 0x01
    5e78:	83 30       	cpi	r24, 0x03	; 3
    5e7a:	c9 f4       	brne	.+50     	; 0x5eae <LCD_displayString+0xa0>
				l_Str_Counter++;
    5e7c:	80 91 07 07 	lds	r24, 0x0707
    5e80:	8f 5f       	subi	r24, 0xFF	; 255
    5e82:	80 93 07 07 	sts	0x0707, r24
				Check_Shift_Is_Done = LCD_WAITING;
    5e86:	84 e0       	ldi	r24, 0x04	; 4
    5e88:	80 93 b3 00 	sts	0x00B3, r24
    5e8c:	10 c0       	rjmp	.+32     	; 0x5eae <LCD_displayString+0xa0>
			}
		}
	}
	else if(LOC_ptrString[l_Str_Counter]=='\0'){
    5e8e:	80 91 07 07 	lds	r24, 0x0707
    5e92:	28 2f       	mov	r18, r24
    5e94:	30 e0       	ldi	r19, 0x00	; 0
    5e96:	8b 81       	ldd	r24, Y+3	; 0x03
    5e98:	9c 81       	ldd	r25, Y+4	; 0x04
    5e9a:	fc 01       	movw	r30, r24
    5e9c:	e2 0f       	add	r30, r18
    5e9e:	f3 1f       	adc	r31, r19
    5ea0:	80 81       	ld	r24, Z
    5ea2:	88 23       	and	r24, r24
    5ea4:	21 f4       	brne	.+8      	; 0x5eae <LCD_displayString+0xa0>
		LOC_dispStr_FuncStatus=LCD_STR_COMPELET;
    5ea6:	8c e0       	ldi	r24, 0x0C	; 12
    5ea8:	8a 83       	std	Y+2, r24	; 0x02
		l_Str_Counter = 0;
    5eaa:	10 92 07 07 	sts	0x0707, r1
	}
	return LOC_dispStr_FuncStatus;
    5eae:	8a 81       	ldd	r24, Y+2	; 0x02
}
    5eb0:	0f 90       	pop	r0
    5eb2:	0f 90       	pop	r0
    5eb4:	0f 90       	pop	r0
    5eb6:	0f 90       	pop	r0
    5eb8:	cf 91       	pop	r28
    5eba:	df 91       	pop	r29
    5ebc:	08 95       	ret

00005ebe <LCD_displayStringRowColumn>:


uint8 LCD_displayStringRowColumn (uint8 LOC_row, uint8 LOC_col,const uint8 *LOC_ptrString)
{
    5ebe:	df 93       	push	r29
    5ec0:	cf 93       	push	r28
    5ec2:	00 d0       	rcall	.+0      	; 0x5ec4 <LCD_displayStringRowColumn+0x6>
    5ec4:	00 d0       	rcall	.+0      	; 0x5ec6 <LCD_displayStringRowColumn+0x8>
    5ec6:	0f 92       	push	r0
    5ec8:	cd b7       	in	r28, 0x3d	; 61
    5eca:	de b7       	in	r29, 0x3e	; 62
    5ecc:	8a 83       	std	Y+2, r24	; 0x02
    5ece:	6b 83       	std	Y+3, r22	; 0x03
    5ed0:	5d 83       	std	Y+5, r21	; 0x05
    5ed2:	4c 83       	std	Y+4, r20	; 0x04
	uint8 LOC_dispStrRowColFuncStatus;


	return LOC_dispStrRowColFuncStatus;
    5ed4:	89 81       	ldd	r24, Y+1	; 0x01
}
    5ed6:	0f 90       	pop	r0
    5ed8:	0f 90       	pop	r0
    5eda:	0f 90       	pop	r0
    5edc:	0f 90       	pop	r0
    5ede:	0f 90       	pop	r0
    5ee0:	cf 91       	pop	r28
    5ee2:	df 91       	pop	r29
    5ee4:	08 95       	ret

00005ee6 <LCD_clear>:

uint8 LCD_clear()
{
    5ee6:	df 93       	push	r29
    5ee8:	cf 93       	push	r28
    5eea:	00 d0       	rcall	.+0      	; 0x5eec <LCD_clear+0x6>
    5eec:	cd b7       	in	r28, 0x3d	; 61
    5eee:	de b7       	in	r29, 0x3e	; 62
	uint8 LOC_clearFuncStatus;
	uint8 commStatus;

	commStatus = LCD_sendCommand(CLEAR_COMMAND);
    5ef0:	81 e0       	ldi	r24, 0x01	; 1
    5ef2:	0e 94 86 2c 	call	0x590c	; 0x590c <LCD_sendCommand>
    5ef6:	89 83       	std	Y+1, r24	; 0x01

	if(commStatus == LCD_DONE)
    5ef8:	89 81       	ldd	r24, Y+1	; 0x01
    5efa:	83 30       	cpi	r24, 0x03	; 3
    5efc:	19 f4       	brne	.+6      	; 0x5f04 <LCD_clear+0x1e>
	{
		LOC_clearFuncStatus = LCD_DONE;
    5efe:	83 e0       	ldi	r24, 0x03	; 3
    5f00:	8a 83       	std	Y+2, r24	; 0x02
    5f02:	02 c0       	rjmp	.+4      	; 0x5f08 <LCD_clear+0x22>
	}
	else
	{
		LOC_clearFuncStatus = LCD_WAITING;
    5f04:	84 e0       	ldi	r24, 0x04	; 4
    5f06:	8a 83       	std	Y+2, r24	; 0x02
	}

	return LOC_clearFuncStatus;
    5f08:	8a 81       	ldd	r24, Y+2	; 0x02
}
    5f0a:	0f 90       	pop	r0
    5f0c:	0f 90       	pop	r0
    5f0e:	cf 91       	pop	r28
    5f10:	df 91       	pop	r29
    5f12:	08 95       	ret

00005f14 <LCD_gotoRowColumn>:

uint8 LCD_gotoRowColumn(uint8 LOC_row, uint8 LOC_col)
{
    5f14:	df 93       	push	r29
    5f16:	cf 93       	push	r28
    5f18:	cd b7       	in	r28, 0x3d	; 61
    5f1a:	de b7       	in	r29, 0x3e	; 62
    5f1c:	27 97       	sbiw	r28, 0x07	; 7
    5f1e:	0f b6       	in	r0, 0x3f	; 63
    5f20:	f8 94       	cli
    5f22:	de bf       	out	0x3e, r29	; 62
    5f24:	0f be       	out	0x3f, r0	; 63
    5f26:	cd bf       	out	0x3d, r28	; 61
    5f28:	8c 83       	std	Y+4, r24	; 0x04
    5f2a:	6d 83       	std	Y+5, r22	; 0x05
	uint8 LOC_goToRowColFuncStatus;
	uint8 Address;
	uint8 commStatus;
	switch(LOC_row)
    5f2c:	8c 81       	ldd	r24, Y+4	; 0x04
    5f2e:	28 2f       	mov	r18, r24
    5f30:	30 e0       	ldi	r19, 0x00	; 0
    5f32:	3f 83       	std	Y+7, r19	; 0x07
    5f34:	2e 83       	std	Y+6, r18	; 0x06
    5f36:	8e 81       	ldd	r24, Y+6	; 0x06
    5f38:	9f 81       	ldd	r25, Y+7	; 0x07
    5f3a:	00 97       	sbiw	r24, 0x00	; 0
    5f3c:	31 f0       	breq	.+12     	; 0x5f4a <LCD_gotoRowColumn+0x36>
    5f3e:	2e 81       	ldd	r18, Y+6	; 0x06
    5f40:	3f 81       	ldd	r19, Y+7	; 0x07
    5f42:	21 30       	cpi	r18, 0x01	; 1
    5f44:	31 05       	cpc	r19, r1
    5f46:	21 f0       	breq	.+8      	; 0x5f50 <LCD_gotoRowColumn+0x3c>
    5f48:	06 c0       	rjmp	.+12     	; 0x5f56 <LCD_gotoRowColumn+0x42>
	{
	case 0:
		Address=LOC_col;
    5f4a:	8d 81       	ldd	r24, Y+5	; 0x05
    5f4c:	8a 83       	std	Y+2, r24	; 0x02
    5f4e:	03 c0       	rjmp	.+6      	; 0x5f56 <LCD_gotoRowColumn+0x42>
		break;
	case 1:
		Address=LOC_col+0x40;
    5f50:	8d 81       	ldd	r24, Y+5	; 0x05
    5f52:	80 5c       	subi	r24, 0xC0	; 192
    5f54:	8a 83       	std	Y+2, r24	; 0x02
		break;
	}
	commStatus = LCD_sendCommand(Address|SET_CURSOR_LOCATION);
    5f56:	8a 81       	ldd	r24, Y+2	; 0x02
    5f58:	80 68       	ori	r24, 0x80	; 128
    5f5a:	0e 94 86 2c 	call	0x590c	; 0x590c <LCD_sendCommand>
    5f5e:	89 83       	std	Y+1, r24	; 0x01
	if(commStatus == LCD_DONE)
    5f60:	89 81       	ldd	r24, Y+1	; 0x01
    5f62:	83 30       	cpi	r24, 0x03	; 3
    5f64:	19 f4       	brne	.+6      	; 0x5f6c <LCD_gotoRowColumn+0x58>
	{
		LOC_goToRowColFuncStatus = LCD_DONE;
    5f66:	83 e0       	ldi	r24, 0x03	; 3
    5f68:	8b 83       	std	Y+3, r24	; 0x03
    5f6a:	02 c0       	rjmp	.+4      	; 0x5f70 <LCD_gotoRowColumn+0x5c>
	}
	else
	{
		LOC_goToRowColFuncStatus = LCD_WAITING;
    5f6c:	84 e0       	ldi	r24, 0x04	; 4
    5f6e:	8b 83       	std	Y+3, r24	; 0x03
	}
	return LOC_goToRowColFuncStatus;
    5f70:	8b 81       	ldd	r24, Y+3	; 0x03
}
    5f72:	27 96       	adiw	r28, 0x07	; 7
    5f74:	0f b6       	in	r0, 0x3f	; 63
    5f76:	f8 94       	cli
    5f78:	de bf       	out	0x3e, r29	; 62
    5f7a:	0f be       	out	0x3f, r0	; 63
    5f7c:	cd bf       	out	0x3d, r28	; 61
    5f7e:	cf 91       	pop	r28
    5f80:	df 91       	pop	r29
    5f82:	08 95       	ret

00005f84 <KeyPad_getPressedKey>:

/*******************************************************************************
 *                      Functions Definitions                                  *
 *******************************************************************************/
uint8 KeyPad_getPressedKey(uint8* Pressed_Key)
{
    5f84:	df 93       	push	r29
    5f86:	cf 93       	push	r28
    5f88:	cd b7       	in	r28, 0x3d	; 61
    5f8a:	de b7       	in	r29, 0x3e	; 62
    5f8c:	28 97       	sbiw	r28, 0x08	; 8
    5f8e:	0f b6       	in	r0, 0x3f	; 63
    5f90:	f8 94       	cli
    5f92:	de bf       	out	0x3e, r29	; 62
    5f94:	0f be       	out	0x3f, r0	; 63
    5f96:	cd bf       	out	0x3d, r28	; 61
    5f98:	98 87       	std	Y+8, r25	; 0x08
    5f9a:	8f 83       	std	Y+7, r24	; 0x07
	uint8 retVal=0;
    5f9c:	1d 82       	std	Y+5, r1	; 0x05
	uint8 keyFound = 0;
    5f9e:	1c 82       	std	Y+4, r1	; 0x04
	uint8 result=0;
    5fa0:	1b 82       	std	Y+3, r1	; 0x03
	static uint8 prevResult = NO_KEY_PRESSED;
	uint8 col,row,gotKey=1;
    5fa2:	81 e0       	ldi	r24, 0x01	; 1
    5fa4:	8e 83       	std	Y+6, r24	; 0x06
	*Pressed_Key = NO_KEY_PRESSED;
    5fa6:	ef 81       	ldd	r30, Y+7	; 0x07
    5fa8:	f8 85       	ldd	r31, Y+8	; 0x08
    5faa:	84 e1       	ldi	r24, 0x14	; 20
    5fac:	80 83       	st	Z, r24
	for(col=0;col<N_col;col++) /* loop for columns */
    5fae:	1a 82       	std	Y+2, r1	; 0x02
    5fb0:	47 c0       	rjmp	.+142    	; 0x6040 <KeyPad_getPressedKey+0xbc>
	{

		DIO_set_port_direction( PORT_C,(0b00100000<<col));
    5fb2:	8a 81       	ldd	r24, Y+2	; 0x02
    5fb4:	28 2f       	mov	r18, r24
    5fb6:	30 e0       	ldi	r19, 0x00	; 0
    5fb8:	80 e2       	ldi	r24, 0x20	; 32
    5fba:	90 e0       	ldi	r25, 0x00	; 0
    5fbc:	02 c0       	rjmp	.+4      	; 0x5fc2 <KeyPad_getPressedKey+0x3e>
    5fbe:	88 0f       	add	r24, r24
    5fc0:	99 1f       	adc	r25, r25
    5fc2:	2a 95       	dec	r18
    5fc4:	e2 f7       	brpl	.-8      	; 0x5fbe <KeyPad_getPressedKey+0x3a>
    5fc6:	98 2f       	mov	r25, r24
    5fc8:	82 e0       	ldi	r24, 0x02	; 2
    5fca:	69 2f       	mov	r22, r25
    5fcc:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <DIO_set_port_direction>

		DIO_write_port_value(PORT_C,(~(0b00100000<<col)));
    5fd0:	8a 81       	ldd	r24, Y+2	; 0x02
    5fd2:	28 2f       	mov	r18, r24
    5fd4:	30 e0       	ldi	r19, 0x00	; 0
    5fd6:	80 e2       	ldi	r24, 0x20	; 32
    5fd8:	90 e0       	ldi	r25, 0x00	; 0
    5fda:	02 c0       	rjmp	.+4      	; 0x5fe0 <KeyPad_getPressedKey+0x5c>
    5fdc:	88 0f       	add	r24, r24
    5fde:	99 1f       	adc	r25, r25
    5fe0:	2a 95       	dec	r18
    5fe2:	e2 f7       	brpl	.-8      	; 0x5fdc <KeyPad_getPressedKey+0x58>
    5fe4:	98 2f       	mov	r25, r24
    5fe6:	90 95       	com	r25
    5fe8:	82 e0       	ldi	r24, 0x02	; 2
    5fea:	69 2f       	mov	r22, r25
    5fec:	0e 94 3a 08 	call	0x1074	; 0x1074 <DIO_write_port_value>

		for(row=0;row<N_row;row++) /* loop for rows */
    5ff0:	19 82       	std	Y+1, r1	; 0x01
    5ff2:	20 c0       	rjmp	.+64     	; 0x6034 <KeyPad_getPressedKey+0xb0>
		{DIO_read_pin_value(PORT_C,(row+2),&gotKey);
    5ff4:	89 81       	ldd	r24, Y+1	; 0x01
    5ff6:	98 2f       	mov	r25, r24
    5ff8:	9e 5f       	subi	r25, 0xFE	; 254
    5ffa:	9e 01       	movw	r18, r28
    5ffc:	2a 5f       	subi	r18, 0xFA	; 250
    5ffe:	3f 4f       	sbci	r19, 0xFF	; 255
    6000:	82 e0       	ldi	r24, 0x02	; 2
    6002:	69 2f       	mov	r22, r25
    6004:	a9 01       	movw	r20, r18
    6006:	0e 94 2c 07 	call	0xe58	; 0xe58 <DIO_read_pin_value>
		if(gotKey==0) /* if the switch is press in this row */
    600a:	8e 81       	ldd	r24, Y+6	; 0x06
    600c:	88 23       	and	r24, r24
    600e:	79 f4       	brne	.+30     	; 0x602e <KeyPad_getPressedKey+0xaa>
		{
			result = (row*N_col)+col+1;
    6010:	89 81       	ldd	r24, Y+1	; 0x01
    6012:	28 2f       	mov	r18, r24
    6014:	30 e0       	ldi	r19, 0x00	; 0
    6016:	c9 01       	movw	r24, r18
    6018:	88 0f       	add	r24, r24
    601a:	99 1f       	adc	r25, r25
    601c:	82 0f       	add	r24, r18
    601e:	93 1f       	adc	r25, r19
    6020:	98 2f       	mov	r25, r24
    6022:	8a 81       	ldd	r24, Y+2	; 0x02
    6024:	89 0f       	add	r24, r25
    6026:	8f 5f       	subi	r24, 0xFF	; 255
    6028:	8b 83       	std	Y+3, r24	; 0x03
			//*Pressed_Key = result;
			keyFound = 1;
    602a:	81 e0       	ldi	r24, 0x01	; 1
    602c:	8c 83       	std	Y+4, r24	; 0x04

		DIO_set_port_direction( PORT_C,(0b00100000<<col));

		DIO_write_port_value(PORT_C,(~(0b00100000<<col)));

		for(row=0;row<N_row;row++) /* loop for rows */
    602e:	89 81       	ldd	r24, Y+1	; 0x01
    6030:	8f 5f       	subi	r24, 0xFF	; 255
    6032:	89 83       	std	Y+1, r24	; 0x01
    6034:	89 81       	ldd	r24, Y+1	; 0x01
    6036:	83 30       	cpi	r24, 0x03	; 3
    6038:	e8 f2       	brcs	.-70     	; 0x5ff4 <KeyPad_getPressedKey+0x70>
	uint8 keyFound = 0;
	uint8 result=0;
	static uint8 prevResult = NO_KEY_PRESSED;
	uint8 col,row,gotKey=1;
	*Pressed_Key = NO_KEY_PRESSED;
	for(col=0;col<N_col;col++) /* loop for columns */
    603a:	8a 81       	ldd	r24, Y+2	; 0x02
    603c:	8f 5f       	subi	r24, 0xFF	; 255
    603e:	8a 83       	std	Y+2, r24	; 0x02
    6040:	8a 81       	ldd	r24, Y+2	; 0x02
    6042:	83 30       	cpi	r24, 0x03	; 3
    6044:	08 f4       	brcc	.+2      	; 0x6048 <KeyPad_getPressedKey+0xc4>
    6046:	b5 cf       	rjmp	.-150    	; 0x5fb2 <KeyPad_getPressedKey+0x2e>
		}
		}
	}


	if(keyFound == 1)
    6048:	8c 81       	ldd	r24, Y+4	; 0x04
    604a:	81 30       	cpi	r24, 0x01	; 1
    604c:	c1 f4       	brne	.+48     	; 0x607e <KeyPad_getPressedKey+0xfa>
	{
		if(result == prevResult)
    604e:	90 91 bd 00 	lds	r25, 0x00BD
    6052:	8b 81       	ldd	r24, Y+3	; 0x03
    6054:	89 17       	cp	r24, r25
    6056:	39 f4       	brne	.+14     	; 0x6066 <KeyPad_getPressedKey+0xe2>
		{
			*Pressed_Key = result;
    6058:	ef 81       	ldd	r30, Y+7	; 0x07
    605a:	f8 85       	ldd	r31, Y+8	; 0x08
    605c:	8b 81       	ldd	r24, Y+3	; 0x03
    605e:	80 83       	st	Z, r24
			retVal = KEYPAD_DONE;
    6060:	8a e1       	ldi	r24, 0x1A	; 26
    6062:	8d 83       	std	Y+5, r24	; 0x05
    6064:	0a c0       	rjmp	.+20     	; 0x607a <KeyPad_getPressedKey+0xf6>

		}
		else if((result != prevResult))
    6066:	90 91 bd 00 	lds	r25, 0x00BD
    606a:	8b 81       	ldd	r24, Y+3	; 0x03
    606c:	89 17       	cp	r24, r25
    606e:	29 f0       	breq	.+10     	; 0x607a <KeyPad_getPressedKey+0xf6>
		{
			prevResult = result;
    6070:	8b 81       	ldd	r24, Y+3	; 0x03
    6072:	80 93 bd 00 	sts	0x00BD, r24
			retVal = NO_KEY_PRESSED;
    6076:	84 e1       	ldi	r24, 0x14	; 20
    6078:	8d 83       	std	Y+5, r24	; 0x05
		}

		keyFound = 0;
    607a:	1c 82       	std	Y+4, r1	; 0x04
    607c:	05 c0       	rjmp	.+10     	; 0x6088 <KeyPad_getPressedKey+0x104>
	}
	else
	{
		prevResult = NO_KEY_PRESSED;
    607e:	84 e1       	ldi	r24, 0x14	; 20
    6080:	80 93 bd 00 	sts	0x00BD, r24
		retVal = NO_KEY_PRESSED;
    6084:	84 e1       	ldi	r24, 0x14	; 20
    6086:	8d 83       	std	Y+5, r24	; 0x05
	}

	return retVal;
    6088:	8d 81       	ldd	r24, Y+5	; 0x05

}
    608a:	28 96       	adiw	r28, 0x08	; 8
    608c:	0f b6       	in	r0, 0x3f	; 63
    608e:	f8 94       	cli
    6090:	de bf       	out	0x3e, r29	; 62
    6092:	0f be       	out	0x3f, r0	; 63
    6094:	cd bf       	out	0x3d, r28	; 61
    6096:	cf 91       	pop	r28
    6098:	df 91       	pop	r29
    609a:	08 95       	ret

0000609c <main>:
void TASK_toggleLED(void * argumentPtr);
void TASK_keypad(void * argumentPtr);


void main(void)
{
    609c:	ef 92       	push	r14
    609e:	ff 92       	push	r15
    60a0:	0f 93       	push	r16
    60a2:	df 93       	push	r29
    60a4:	cf 93       	push	r28
    60a6:	cd b7       	in	r28, 0x3d	; 61
    60a8:	de b7       	in	r29, 0x3e	; 62
	xTaskCreate(
    60aa:	80 eb       	ldi	r24, 0xB0	; 176
    60ac:	90 e3       	ldi	r25, 0x30	; 48
    60ae:	25 e6       	ldi	r18, 0x65	; 101
    60b0:	30 e0       	ldi	r19, 0x00	; 0
    60b2:	e9 e0       	ldi	r30, 0x09	; 9
    60b4:	f7 e0       	ldi	r31, 0x07	; 7
    60b6:	b9 01       	movw	r22, r18
    60b8:	45 e5       	ldi	r20, 0x55	; 85
    60ba:	50 e0       	ldi	r21, 0x00	; 0
    60bc:	20 e0       	ldi	r18, 0x00	; 0
    60be:	30 e0       	ldi	r19, 0x00	; 0
    60c0:	03 e0       	ldi	r16, 0x03	; 3
    60c2:	7f 01       	movw	r14, r30
    60c4:	0e 94 62 1f 	call	0x3ec4	; 0x3ec4 <xTaskCreate>
			85,
			NULL,
			3,
			&xHandle_toggleLED);

	xTaskCreate(
    60c8:	85 e8       	ldi	r24, 0x85	; 133
    60ca:	90 e3       	ldi	r25, 0x30	; 48
    60cc:	2c e6       	ldi	r18, 0x6C	; 108
    60ce:	30 e0       	ldi	r19, 0x00	; 0
    60d0:	eb e0       	ldi	r30, 0x0B	; 11
    60d2:	f7 e0       	ldi	r31, 0x07	; 7
    60d4:	b9 01       	movw	r22, r18
    60d6:	45 e5       	ldi	r20, 0x55	; 85
    60d8:	50 e0       	ldi	r21, 0x00	; 0
    60da:	20 e0       	ldi	r18, 0x00	; 0
    60dc:	30 e0       	ldi	r19, 0x00	; 0
    60de:	03 e0       	ldi	r16, 0x03	; 3
    60e0:	7f 01       	movw	r14, r30
    60e2:	0e 94 62 1f 	call	0x3ec4	; 0x3ec4 <xTaskCreate>
			85,
			NULL,
			3,
			&xHandle_systemInit);

	xTaskCreate(
    60e6:	8a ed       	ldi	r24, 0xDA	; 218
    60e8:	90 e3       	ldi	r25, 0x30	; 48
    60ea:	21 e7       	ldi	r18, 0x71	; 113
    60ec:	30 e0       	ldi	r19, 0x00	; 0
    60ee:	ed e0       	ldi	r30, 0x0D	; 13
    60f0:	f7 e0       	ldi	r31, 0x07	; 7
    60f2:	b9 01       	movw	r22, r18
    60f4:	45 e5       	ldi	r20, 0x55	; 85
    60f6:	50 e0       	ldi	r21, 0x00	; 0
    60f8:	20 e0       	ldi	r18, 0x00	; 0
    60fa:	30 e0       	ldi	r19, 0x00	; 0
    60fc:	03 e0       	ldi	r16, 0x03	; 3
    60fe:	7f 01       	movw	r14, r30
    6100:	0e 94 62 1f 	call	0x3ec4	; 0x3ec4 <xTaskCreate>
			85,
			NULL,
			3,
			&xHandle_keypad);
	/* Start Scheduler */
	vTaskStartScheduler();
    6104:	0e 94 05 23 	call	0x460a	; 0x460a <vTaskStartScheduler>
    6108:	ff cf       	rjmp	.-2      	; 0x6108 <main+0x6c>

0000610a <TASK_systemInit>:

	}
}

void TASK_systemInit(void * argumentPtr)
{
    610a:	df 93       	push	r29
    610c:	cf 93       	push	r28
    610e:	00 d0       	rcall	.+0      	; 0x6110 <TASK_systemInit+0x6>
    6110:	cd b7       	in	r28, 0x3d	; 61
    6112:	de b7       	in	r29, 0x3e	; 62
    6114:	9a 83       	std	Y+2, r25	; 0x02
    6116:	89 83       	std	Y+1, r24	; 0x01
	static uint8 DIO_init_status = NOT_INIT_YET;

	while(1)
	{
		if(g_initFlag == NOT_INIT_YET)
    6118:	80 91 08 07 	lds	r24, 0x0708
    611c:	88 23       	and	r24, r24
    611e:	61 f4       	brne	.+24     	; 0x6138 <TASK_systemInit+0x2e>
		{
			if(DIO_init_status != INIT_DONE)
    6120:	80 91 0f 07 	lds	r24, 0x070F
    6124:	81 30       	cpi	r24, 0x01	; 1
    6126:	41 f0       	breq	.+16     	; 0x6138 <TASK_systemInit+0x2e>
			{
				DIO_init();
    6128:	0e 94 49 00 	call	0x92	; 0x92 <DIO_init>
				DIO_init_status = INIT_DONE;
    612c:	81 e0       	ldi	r24, 0x01	; 1
    612e:	80 93 0f 07 	sts	0x070F, r24
				g_initFlag = INIT_DONE;
    6132:	81 e0       	ldi	r24, 0x01	; 1
    6134:	80 93 08 07 	sts	0x0708, r24
			}
		}
		if(g_initFlag == NOT_INIT_YET)
    6138:	80 91 08 07 	lds	r24, 0x0708
    613c:	88 23       	and	r24, r24
    613e:	29 f4       	brne	.+10     	; 0x614a <TASK_systemInit+0x40>
		{
			vTaskDelay(1);
    6140:	81 e0       	ldi	r24, 0x01	; 1
    6142:	90 e0       	ldi	r25, 0x00	; 0
    6144:	0e 94 7b 21 	call	0x42f6	; 0x42f6 <vTaskDelay>
    6148:	e7 cf       	rjmp	.-50     	; 0x6118 <TASK_systemInit+0xe>
		}
		else if(g_initFlag == INIT_DONE)
    614a:	80 91 08 07 	lds	r24, 0x0708
    614e:	81 30       	cpi	r24, 0x01	; 1
    6150:	19 f7       	brne	.-58     	; 0x6118 <TASK_systemInit+0xe>
		{
			vTaskSuspend(xHandle_systemInit);
    6152:	80 91 0b 07 	lds	r24, 0x070B
    6156:	90 91 0c 07 	lds	r25, 0x070C
    615a:	0e 94 9d 21 	call	0x433a	; 0x433a <vTaskSuspend>
    615e:	dc cf       	rjmp	.-72     	; 0x6118 <TASK_systemInit+0xe>

00006160 <TASK_toggleLED>:
		}
	}
}

void TASK_toggleLED(void * argumentPtr)
{
    6160:	df 93       	push	r29
    6162:	cf 93       	push	r28
    6164:	00 d0       	rcall	.+0      	; 0x6166 <TASK_toggleLED+0x6>
    6166:	cd b7       	in	r28, 0x3d	; 61
    6168:	de b7       	in	r29, 0x3e	; 62
    616a:	9a 83       	std	Y+2, r25	; 0x02
    616c:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		if(g_Led_Request != DISABLE)
    616e:	80 91 be 00 	lds	r24, 0x00BE
    6172:	88 30       	cpi	r24, 0x08	; 8
    6174:	b1 f0       	breq	.+44     	; 0x61a2 <TASK_toggleLED+0x42>
		{
			Led_Toggle(PORT_B,PINB6);
    6176:	81 e0       	ldi	r24, 0x01	; 1
    6178:	66 e0       	ldi	r22, 0x06	; 6
    617a:	0e 94 62 2c 	call	0x58c4	; 0x58c4 <Led_Toggle>
			if(g_Led_Request == ENABLE_withONE_HUND_MILLIS)
    617e:	80 91 be 00 	lds	r24, 0x00BE
    6182:	82 30       	cpi	r24, 0x02	; 2
    6184:	29 f4       	brne	.+10     	; 0x6190 <TASK_toggleLED+0x30>
			{
				vTaskDelay(100);
    6186:	84 e6       	ldi	r24, 0x64	; 100
    6188:	90 e0       	ldi	r25, 0x00	; 0
    618a:	0e 94 7b 21 	call	0x42f6	; 0x42f6 <vTaskDelay>
    618e:	ef cf       	rjmp	.-34     	; 0x616e <TASK_toggleLED+0xe>
			}
			else if(g_Led_Request == ENABLE_withFOUR_HUND_MILLIS)
    6190:	80 91 be 00 	lds	r24, 0x00BE
    6194:	81 30       	cpi	r24, 0x01	; 1
    6196:	59 f7       	brne	.-42     	; 0x616e <TASK_toggleLED+0xe>
			{
				vTaskDelay(400);
    6198:	80 e9       	ldi	r24, 0x90	; 144
    619a:	91 e0       	ldi	r25, 0x01	; 1
    619c:	0e 94 7b 21 	call	0x42f6	; 0x42f6 <vTaskDelay>
    61a0:	e6 cf       	rjmp	.-52     	; 0x616e <TASK_toggleLED+0xe>
			}
		}
		else
		{
			Led_Off(PORT_B,PINB6);
    61a2:	81 e0       	ldi	r24, 0x01	; 1
    61a4:	66 e0       	ldi	r22, 0x06	; 6
    61a6:	0e 94 3b 2c 	call	0x5876	; 0x5876 <Led_Off>
			vTaskDelay(30);
    61aa:	8e e1       	ldi	r24, 0x1E	; 30
    61ac:	90 e0       	ldi	r25, 0x00	; 0
    61ae:	0e 94 7b 21 	call	0x42f6	; 0x42f6 <vTaskDelay>
    61b2:	dd cf       	rjmp	.-70     	; 0x616e <TASK_toggleLED+0xe>

000061b4 <TASK_keypad>:
		}
	}
}

void TASK_keypad(void * argumentPtr)
{
    61b4:	df 93       	push	r29
    61b6:	cf 93       	push	r28
    61b8:	00 d0       	rcall	.+0      	; 0x61ba <TASK_keypad+0x6>
    61ba:	00 d0       	rcall	.+0      	; 0x61bc <TASK_keypad+0x8>
    61bc:	cd b7       	in	r28, 0x3d	; 61
    61be:	de b7       	in	r29, 0x3e	; 62
    61c0:	9c 83       	std	Y+4, r25	; 0x04
    61c2:	8b 83       	std	Y+3, r24	; 0x03
	static uint8 prevKey = NO_KEY_PRESSED;
	static uint8 timeCount=0;

	while(1)
	{
		output = KeyPad_getPressedKey(&data);
    61c4:	ce 01       	movw	r24, r28
    61c6:	02 96       	adiw	r24, 0x02	; 2
    61c8:	0e 94 c2 2f 	call	0x5f84	; 0x5f84 <KeyPad_getPressedKey>
    61cc:	89 83       	std	Y+1, r24	; 0x01
		if(output == KEYPAD_DONE)
    61ce:	89 81       	ldd	r24, Y+1	; 0x01
    61d0:	8a 31       	cpi	r24, 0x1A	; 26
    61d2:	a9 f4       	brne	.+42     	; 0x61fe <TASK_keypad+0x4a>
		{
			timeCount++;
    61d4:	80 91 10 07 	lds	r24, 0x0710
    61d8:	8f 5f       	subi	r24, 0xFF	; 255
    61da:	80 93 10 07 	sts	0x0710, r24
			if(timeCount>150)
    61de:	80 91 10 07 	lds	r24, 0x0710
    61e2:	87 39       	cpi	r24, 0x97	; 151
    61e4:	18 f0       	brcs	.+6      	; 0x61ec <TASK_keypad+0x38>
			{
				timeCount=150;
    61e6:	86 e9       	ldi	r24, 0x96	; 150
    61e8:	80 93 10 07 	sts	0x0710, r24
			}
			if(prevKey != data)
    61ec:	90 91 bf 00 	lds	r25, 0x00BF
    61f0:	8a 81       	ldd	r24, Y+2	; 0x02
    61f2:	98 17       	cp	r25, r24
    61f4:	19 f1       	breq	.+70     	; 0x623c <TASK_keypad+0x88>
			{
				prevKey = data;
    61f6:	8a 81       	ldd	r24, Y+2	; 0x02
    61f8:	80 93 bf 00 	sts	0x00BF, r24
    61fc:	1f c0       	rjmp	.+62     	; 0x623c <TASK_keypad+0x88>
			}
		}
		else if(output == NO_KEY_PRESSED)
    61fe:	89 81       	ldd	r24, Y+1	; 0x01
    6200:	84 31       	cpi	r24, 0x14	; 20
    6202:	e1 f4       	brne	.+56     	; 0x623c <TASK_keypad+0x88>
		{
			if(prevKey != NO_KEY_PRESSED)
    6204:	80 91 bf 00 	lds	r24, 0x00BF
    6208:	84 31       	cpi	r24, 0x14	; 20
    620a:	c1 f0       	breq	.+48     	; 0x623c <TASK_keypad+0x88>
			{
				if(timeCount > 134)
    620c:	80 91 10 07 	lds	r24, 0x0710
    6210:	87 38       	cpi	r24, 0x87	; 135
    6212:	20 f0       	brcs	.+8      	; 0x621c <TASK_keypad+0x68>
				{
					g_Led_Request = ENABLE_withONE_HUND_MILLIS;
    6214:	82 e0       	ldi	r24, 0x02	; 2
    6216:	80 93 be 00 	sts	0x00BE, r24
    621a:	0b c0       	rjmp	.+22     	; 0x6232 <TASK_keypad+0x7e>
				}
				else if(timeCount > 67)
    621c:	80 91 10 07 	lds	r24, 0x0710
    6220:	84 34       	cpi	r24, 0x44	; 68
    6222:	20 f0       	brcs	.+8      	; 0x622c <TASK_keypad+0x78>
				{
					g_Led_Request = ENABLE_withFOUR_HUND_MILLIS;
    6224:	81 e0       	ldi	r24, 0x01	; 1
    6226:	80 93 be 00 	sts	0x00BE, r24
    622a:	03 c0       	rjmp	.+6      	; 0x6232 <TASK_keypad+0x7e>
				}
				else
				{
					g_Led_Request = DISABLE;
    622c:	88 e0       	ldi	r24, 0x08	; 8
    622e:	80 93 be 00 	sts	0x00BE, r24
				}
				timeCount=0;
    6232:	10 92 10 07 	sts	0x0710, r1
				prevKey = NO_KEY_PRESSED;
    6236:	84 e1       	ldi	r24, 0x14	; 20
    6238:	80 93 bf 00 	sts	0x00BF, r24
			}
		}
		vTaskDelay(30);
    623c:	8e e1       	ldi	r24, 0x1E	; 30
    623e:	90 e0       	ldi	r25, 0x00	; 0
    6240:	0e 94 7b 21 	call	0x42f6	; 0x42f6 <vTaskDelay>
    6244:	bf cf       	rjmp	.-130    	; 0x61c4 <TASK_keypad+0x10>

00006246 <memcpy>:
    6246:	fb 01       	movw	r30, r22
    6248:	dc 01       	movw	r26, r24
    624a:	02 c0       	rjmp	.+4      	; 0x6250 <memcpy+0xa>
    624c:	01 90       	ld	r0, Z+
    624e:	0d 92       	st	X+, r0
    6250:	41 50       	subi	r20, 0x01	; 1
    6252:	50 40       	sbci	r21, 0x00	; 0
    6254:	d8 f7       	brcc	.-10     	; 0x624c <memcpy+0x6>
    6256:	08 95       	ret

00006258 <memset>:
    6258:	dc 01       	movw	r26, r24
    625a:	01 c0       	rjmp	.+2      	; 0x625e <memset+0x6>
    625c:	6d 93       	st	X+, r22
    625e:	41 50       	subi	r20, 0x01	; 1
    6260:	50 40       	sbci	r21, 0x00	; 0
    6262:	e0 f7       	brcc	.-8      	; 0x625c <memset+0x4>
    6264:	08 95       	ret

00006266 <_exit>:
    6266:	f8 94       	cli

00006268 <__stop_program>:
    6268:	ff cf       	rjmp	.-2      	; 0x6268 <__stop_program>
